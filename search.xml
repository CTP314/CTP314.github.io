<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>从来没搞清楚的参考系变换</title>
    <url>/2022/02/10/%E4%BB%8E%E6%9D%A5%E6%B2%A1%E6%90%9E%E6%B8%85%E6%A5%9A%E7%9A%84%E5%8F%82%E8%80%83%E7%B3%BB%E5%8F%98%E6%8D%A2/</url>
    <content><![CDATA[<h2 id="碎碎念">碎碎念</h2>
<p>之前一直搞不清楚的有几个问题</p>
<ul>
<li>坐标系和参考系有什么区别？</li>
<li>更严谨和一般的参考系速度和加速度变换的推导？</li>
<li>各个离心力的数学理解和主观理解？</li>
</ul>
<h2 id="坐标系与参考系的关系">坐标系与参考系的关系</h2>
<p>由于初高中接触到的参考系变换都是来自于<strong>平动</strong>，所以对二者的关系理解不深。
引入<strong>相对转动</strong>后（更复杂的变换，一般是类似刚体运动，可以分解为平动和相对的复合），会出现理解上的困难。</p>
<p>经典力学中的参考系变换一般从伽利略变换引入，但是由于只关注了其形式</p>
<p><span class="math display">\[
    (x&#39;,y&#39;,z&#39;,t&#39;)=(x+vt,y,z,t)
\]</span> <a id="more"></a> 会造成对参考系径矢变换的一些细节上的忽视</p>
<p><span class="math display">\[
    \mathbf{r}_S=\mathbf{r}_{S&#39;}+\mathbf{r}_{SS&#39;}
\]</span></p>
<p>在运算时，必须放置在同一"坐标系"下，比如</p>
<p><span class="math display">\[
\begin{aligned}
    (\mathbf{r}_S)_S&amp;=(\mathbf{r}_{S&#39;})_S+(\mathbf{r}_{SS&#39;})_{S}\\
    (\mathbb{r}_S)_{S&#39;}&amp;=(\mathbf{r}_{S&#39;})_{S&#39;}+(\mathbf{r}_{SS&#39;})_{S&#39;}
\end{aligned}
\]</span></p>
<p>其中的"同一'坐标系'"是一个很宽泛的理解，指我们需要细致的去考虑对这些物理量的测量方式，参考系变换可以从一些测量方式地变换推出（如
<span class="math inline">\(\theta_{SS&#39;}=\theta_{S&#39;}+\theta_{SS&#39;}\)</span>），比如如果使用笛卡尔坐标系，那么它用来表征的三个单位向量
<span class="math inline">\(S\)</span> 系中使用的 <span class="math inline">\(\mathbf{\hat{x}},\mathbf{\hat{y}},\mathbf{\hat{z}}\)</span>
就不一定与 <span class="math inline">\(S&#39;\)</span> 系使用的 <span class="math inline">\(\mathbf{\hat{x&#39;}},\mathbf{\hat{y&#39;}},\mathbf{\hat{z&#39;}}\)</span>
相同，或者比如极坐标的表征方式 <span class="math inline">\((r,\theta)\)</span> 也和 <span class="math inline">\((r&#39;,\theta&#39;)\)</span> 需要做区分。</p>
<p>实际上在转动坐标系下的速度变换的 <span class="math inline">\(\mathbf{\omega}\times\mathbf{r}\)</span>
以及加速度变换所带来的惯性力，即离心力和科里奥利力，都是来自于 <span class="math inline">\((\mathbf{v}_{S})_{S}\)</span> 和 <span class="math inline">\((\mathbf{v}_{S})_{S}\)</span>，<span class="math inline">\((\mathbf{a}_{S})_{S}\)</span> 和 <span class="math inline">\((\mathbf{a}_{S})_{S}\)</span> 的不同所带来的。</p>
<h2 id="参考系速度变换推导">参考系速度变换推导</h2>
<p>我们根据</p>
<p><span class="math display">\[
    \mathbf{r}_S=\mathbf{r}_{S&#39;}+\mathbf{r}_{SS&#39;}
\]</span></p>
<p>对两侧同时关于 <span class="math inline">\(t\)</span> 求导得</p>
<p><span class="math display">\[
    （\mathbf{v}_S)_S=\dfrac{\mathrm{d}}{\mathrm{d}t}(\mathbf{r}_{S&#39;})_S+(\mathbf{v}_{r})_S
\]</span></p>
<p>通过笛卡尔坐标，或者我们用一些基去表征 <span class="math inline">\(S\)</span> 和 <span class="math inline">\(S&#39;\)</span> 中的物理量，引入将 <span class="math inline">\(S&#39;\)</span> 的基变化成 <span class="math inline">\(S\)</span> 的基的矩阵 <span class="math inline">\(\mathbf{R}_{SS&#39;}\)</span>（结合大一上线代换基的知识可知，<span class="math inline">\(\mathbf{R}_{SS&#39;}=[\mathsf{I}]_{S&#39;}^{S}\)</span>，实际上就是在
<span class="math inline">\(S\)</span> 中去观察 <span class="math inline">\(S&#39;\)</span> 中的情况，<del>之前总会搞成在
<span class="math inline">\(S&#39;\)</span> 中去描述 <span class="math inline">\(S\)</span> 的转动</del>），简记为 <span class="math inline">\(\mathbf{R}\)</span>，我们有诸如下述的变化</p>
<p><span class="math display">\[
    (\mathbf{r}_{S&#39;})_S=\mathbf{R}(\mathbf{r}_{S&#39;})_{S&#39;},(\mathbf{v}_{S&#39;})_S=\mathbf{R}(\mathbf{v}_{S&#39;})_{S&#39;},(\mathbf{a}_{S&#39;})_S=\mathbf{R}(\mathbf{a}_{S&#39;})_{S&#39;}
\]</span></p>
<p>故</p>
<p><span class="math display">\[
\begin{aligned}
    （\mathbf{v}_S)_S&amp;=\mathbf{R}(\mathbf{v}_{S&#39;})_{S&#39;}+\dot{\mathbf{R}}(\mathbf{r}_{S&#39;})_{S&#39;}+(\mathbf{v}_{r})_S\\
    &amp;=(\mathbf{v}_{S&#39;})_S+\mathbf{\Omega}_{SS&#39;}(\mathbf{r}_{S&#39;})_{S}+(\mathbf{v}_{r})_S\\
    &amp;=(\mathbf{v}_{S&#39;})_S+(\pmb{\omega}_{SS&#39;}\times\mathbf{r}_{S&#39;})_{S}+(\mathbf{v}_{SS&#39;})_S\\
\end{aligned}
\]</span></p>
<p>（中间 <span class="math inline">\(\dot{\mathbf{R}}=\mathbf{\Omega
R}\)</span> 实际上是类似 <span class="math inline">\([\dot{\mathbf{R}}]_S=[\mathbf{\Omega
R}]_S=[\mathbf{\Omega}]_S[\mathbf{I}]_{S&#39;}^{S}\)</span>，这里有疑问就是这样的推导能否适用于广泛的三维旋转，感觉没有问题？）</p>
<p>我们将式子整理为</p>
<p><span class="math display">\[
\mathbf{v}_S=\mathbf{v}_{S&#39;}+\mathbf{v}_r=\mathbf{v}_{S&#39;}+(\pmb{\omega}_{SS&#39;}\times\mathbf{r}_{S&#39;}+\mathbf{v}_{SS&#39;})
\]</span></p>
<p>或者我们可以使用极坐标系进行类似推导二维平面的情况（三维可以使用球坐标系或圆柱坐标系）</p>
<p><span class="math display">\[
\begin{aligned}
    （\mathbf{v}_S)_S&amp;=\dfrac{\mathrm{d}}{\mathrm{d}t}((r_{S&#39;})_S\hat{\mathbf{r}}(\theta_S))+(\mathbf{v}_{r})_S\\
    &amp;=(v_{S&#39;})_S\hat{\mathbf{r}}(\theta_S)+(r_{S&#39;})_S\dfrac{\mathrm{d}}{\mathrm{d}\theta_{S}}\hat{\mathbf{r}}(\theta_{S})\dfrac{\mathrm{d}}{\mathrm{d}t}\theta_{S}+(\mathbf{v}_{r})_S\\
    &amp;=(v_{S&#39;})_S\hat{\mathbf{r}}(\theta_S)+(r_{S&#39;})_S\hat{\mathbf{\theta}}(\theta_{S})(\omega_{SS&#39;}+\omega_{S&#39;})+(\mathbf{v}_{r})_S\\
    &amp;=(\mathbf{v}_{S&#39;})_S+(\pmb{\omega}_{SS&#39;}\times\mathbf{r}_{S&#39;})_{S}+(\mathbf{v}_{SS&#39;})_S\\
\end{aligned}
\]</span></p>
<p>可以得出一致的结果（不过其中还需要保证测量标量 <span class="math inline">\(r\)</span> 时，用的"刻度"是一致的）</p>
<h2 id="参考系加速度变换与惯性力">参考系加速度变换与惯性力</h2>
<p>根据</p>
<p><span class="math display">\[
\mathbf{v}_S=\mathbf{v}_{S&#39;}+\mathbf{v}_r=\mathbf{v}_{S&#39;}+(\pmb{\omega}_{SS&#39;}\times\mathbf{r}_{S&#39;}+\mathbf{v}_{SS&#39;})
\]</span></p>
<p>两侧关于时间 <span class="math inline">\(t\)</span> 求导可知</p>
<p><span class="math display">\[
    (\mathbf{a}_S)_S=\dfrac{\mathrm{d}}{\mathrm{d}t}(\mathbf{v}_{S&#39;})_S+(\dot{\pmb{\omega}}_{SS&#39;})_S\times(\mathbf{r}_{S&#39;})_S+(\pmb{\omega}_{SS&#39;})_S\times((\mathbf{v}_{S&#39;})_S+(\pmb{\omega}_{SS&#39;})_S\times(\mathbf{r}_{S&#39;})_S)+(\mathbf{a}_{SS&#39;})_S
\]</span></p>
<p>利用旋转矩阵</p>
<p><span class="math display">\[
\begin{aligned}
    \dfrac{\mathrm{d}}{\mathrm{d}t}(\mathbf{v}_{S&#39;})_S&amp;=(\mathbf{a}_{S&#39;})_S+\dot{\mathbf{R}}(\mathbf{v}_{S&#39;})_{S&#39;}\\
    &amp;=(\mathbf{a}_{S&#39;})_S+\mathbf{\Omega}(\mathbf{v}_{S&#39;})_{S}\\
    &amp;=(\mathbf{a}_{S&#39;})_S+(\pmb{\omega}_{SS&#39;})_S\times(\mathbf{v}_{S&#39;})_S
\end{aligned}
\]</span></p>
<p>整理得</p>
<p><span class="math display">\[
    \mathbf{a}_S=\mathbf{a}_{S&#39;}+\mathbf{a}_{SS&#39;}+\dot{\pmb{\omega}}_{SS&#39;}\times\mathbf{r}_{S&#39;}+\pmb{\omega}_{SS&#39;}\times(\pmb{\omega}_{SS&#39;}\times\mathbf{r}_S)+2\pmb{\omega}_{SS&#39;}\times\mathbf{v}_{S&#39;}
\]</span></p>
<p>惯性力本质上就是 <span class="math inline">\(S\)</span>
系是一个惯性系，在对 <span class="math inline">\(S&#39;\)</span>
系进行研究时，由于需要保证惯性定律成立，引入惯性力 <span class="math inline">\(\mathbf{f}_{S&#39;S}\)</span>（简记为 <span class="math inline">\(\mathbf{f}\)</span>）（极端地想，在刚开始移动的车上有一个小球，在地面参考系
<span class="math inline">\(S\)</span> 中，车以 <span class="math inline">\(\mathbf{a}\)</span> 加速，而球静止，真实力为 <span class="math inline">\(\mathbf{0}\)</span>，在车参考系 <span class="math inline">\(S&#39;\)</span> 中，小球以 <span class="math inline">\(-\mathbf{a}\)</span>
减速，然而却找不施力物体，所以是 <span class="math inline">\(S&#39;\)</span> 相对于 <span class="math inline">\(S\)</span> 系移动造成的，引入惯性力 <span class="math inline">\(\mathbf{f}=-m\mathbf{a}\)</span>，同理，在一个旋转的圆盘上有一个小球，当小球与圆盘<strong>相对静止</strong>时，在
<span class="math inline">\(S\)</span>
系中的观测到的是小球做圆周运动，存在向心力，在视角跟着圆盘一起旋转的
<span class="math inline">\(S&#39;\)</span>
系，小球静止不动，但是我们却可以观测到施加了向心力的物体，比如圆盘摩擦产生的热，圆盘支持力的形变等，这一部分同也是
<span class="math inline">\(S&#39;\)</span> 相当于 <span class="math inline">\(S\)</span>
系造成的，引入了离心力，同样的场景，考虑刚开始旋转时小球在 <span class="math inline">\(S\)</span> 系中静止，<span class="math inline">\(S&#39;\)</span>
系中做圆周运动，这时根据前文，小球首先受到了离心力，但是小球产生离心的运动状态，所以收到了另一种惯性力——科里奥利力，在这种情况下二倍且反方向于离心力，而且若
<span class="math inline">\(S&#39;\)</span> 对于 <span class="math inline">\(S\)</span> 是逆时针旋转，那么 <span class="math inline">\(S’\)</span>
中观测到小球就是顺时针，这个变换同样可以从科里奥利力中得出） 有</p>
<p><span class="math display">\[
m\mathbf{a}_{S&#39;}=\mathbf{f}_{S&#39;S}+m\mathbf{a}_S
\]</span></p>
<p>其中 <span class="math inline">\(-2\pmb{\omega}_{SS&#39;}\times\mathbf{v}_{S&#39;}=2\mathbf{v}_{S&#39;}\times\pmb{\omega}_{SS&#39;}\)</span>
便是科里奥利加速度，<span class="math inline">\(-\pmb{\omega}_{SS&#39;}\times(\pmb{\omega}_{SS&#39;}\times\mathbf{r}_S)\)</span>
便是离心加速度。</p>
<p>叉乘是不满足结合律的，但是有</p>
<p><span class="math display">\[
    \mathbf{a}\times(\mathbf{b}\times\mathbf{c})=(\mathbf{a}\cdot
\mathbf{c})\mathbf{b}-(\mathbf{a}\cdot \mathbf{b})\mathbf{c}
\]</span></p>
<p>我们可以得到另一个式子</p>
<p><span class="math display">\[
    \mathbf{a}_S=\mathbf{a}_{S&#39;}+\mathbf{a}_{SS&#39;}+\dot{\pmb{\omega}}_{SS&#39;}\times\mathbf{r}_{S&#39;}+(\pmb{\omega}_{SS&#39;}\cdot\mathbf{r}_S)\pmb{\omega}_{SS&#39;}-\omega_{SS&#39;}^2\mathbf{r}_S+2\pmb{\omega}_{SS&#39;}\times\mathbf{v}_{S&#39;}
\]</span></p>
<p>当 <span class="math inline">\(\pmb\omega\perp\mathbf{r}_{S&#39;}\)</span>
时，其中 <span class="math inline">\(\omega_{SS&#39;}^2\mathbf{r}_S\)</span>
便是离心加速度的一种为人熟知的情形。</p>
<p>我们同理可以用极坐标推导二维的情况（这种方法推导一般的情况远没有上述方法容易，方面起见，我们将
<span class="math inline">\(\theta_{S&#39;}=0\)</span>，即 <span class="math inline">\(S&#39;\)</span> 系中与研究对象没有相对转动）</p>
<p><span class="math display">\[
\begin{aligned}
    （\mathbf{a}_{S&#39;})_S&amp;=\dfrac{\mathrm{d^2}}{\mathrm{d}t^2}((r_{S&#39;})_S\hat{\mathbf{r}}(\theta_S))\\
    &amp;=(\ddot{r}_{S&#39;})_S\hat{\mathbf{r}}(\theta_S)+2(\dot
r_{S&#39;})_S\dfrac{\mathrm{d}}{\mathrm{d}t}\hat{\mathbf{r}}(\theta_S)+(r_{S&#39;})_S\dfrac{\mathrm{d^2}}{\mathrm{d}t^2}\hat{\mathbf{r}}(\theta_S)\\
    &amp;=(\ddot{r}_{S&#39;})_S\hat{\mathbf{r}}(\theta_S)+2(v_{S&#39;})_S\hat{\pmb{\theta}}(\theta_S)(\omega_{SS&#39;})_S+(r_{S&#39;})_S\hat{\pmb{\theta}}(\theta_S)(\dot\omega_{SS&#39;})_S-(r_{S&#39;})_S(\hat{\mathbf{r}}(\theta_S)(\omega_{SS&#39;})_S^2\\
    &amp;=\mathbf{a}_{S&#39;}+\dot{\pmb{\omega}}_{SS&#39;}\times\mathbf{r}_{S&#39;}+\pmb{\omega}_{SS&#39;}\times(\pmb{\omega}_{SS&#39;}\times\mathbf{r}_S)+2\pmb{\omega}_{SS&#39;}\times\mathbf{v}_{S&#39;}
\end{aligned}
\]</span></p>
<p>（二维情况下，<span class="math inline">\(\pmb\omega\perp\mathbf{r}\)</span>）</p>
<h2 id="参考资料">参考资料</h2>
<p><a href="https://zh.wikipedia.ahmu.cf/wiki/%E5%9D%90%E6%A8%99%E7%B3%BB">https://zh.wikipedia.ahmu.cf/wiki/%E5%9D%90%E6%A8%99%E7%B3%BB</a></p>
<p><a href="https://zh.wikipedia.ahmu.cf/wiki/%E4%BC%BD%E5%88%A9%E7%95%A5%E5%8F%98%E6%8D%A2">https://zh.wikipedia.ahmu.cf/wiki/%E4%BC%BD%E5%88%A9%E7%95%A5%E5%8F%98%E6%8D%A2</a></p>
<p><a href="https://wuli.wiki/online/Vtrans.html">https://wuli.wiki/online/Vtrans.html</a></p>
<p><a href="https://wuli.wiki/online/Iner.html">https://wuli.wiki/online/Iner.html</a></p>
]]></content>
      <categories>
        <category>学不明白的东西</category>
      </categories>
      <tags>
        <tag>物理</tag>
      </tags>
  </entry>
  <entry>
    <title>关于一类容斥的思考</title>
    <url>/2022/01/24/%E5%85%B3%E4%BA%8E%E4%B8%80%E7%B1%BB%E5%AE%B9%E6%96%A5%E7%9A%84%E6%80%9D%E8%80%83/</url>
    <content><![CDATA[<h2 id="正文">正文</h2>
<p>我们常见到一类关于等价类划分的容斥问题，大致抽象如下：设集合 <span class="math inline">\(S\)</span> 大小为 <span class="math inline">\(n\)</span>，方案集合 <span class="math inline">\(M\)</span>，对于 <span class="math inline">\(x\in
S\)</span>，有 <span class="math inline">\(x\)</span> 的方案集合 <span class="math inline">\(M_x\)</span>，存在定义在 <span class="math inline">\(M\)</span> 上的等价关系 <span class="math inline">\(\sim\)</span>。需要求出 <span class="math display">\[
\sum_{m_x\in M_x}\prod_{a,b\in S}[m_a\nsim m_b]
\]</span></p>
<p>的值。 <a id="more"></a>
对于这类问题，我们有直接做法，即枚举成立的等价关系进行容斥 <span class="math display">\[
    \sum_{E\subseteq S\times S}(-1)^{|E|}\prod_{S\in C(E)}f(S)
\]</span></p>
<p>其中 <span class="math inline">\(C(E)\)</span> 是 <span class="math inline">\(E\)</span> 形成的等价类划分，直观地理解就是边集为
<span class="math inline">\(E\)</span>
时形成的连通块，每个联通块是一个等价类，<span class="math inline">\(f(S)\)</span>
则是这个等价类对应地方案集合大小。</p>
<p>这个一般做法是 <span class="math inline">\(O(4^n)\)</span>
的。但我们会发现 <span class="math inline">\(C(E)\)</span>
是大量重复的，并且等价于集合划分，因此考虑变换枚举顺序，有</p>
<p><span class="math display">\[
\sum_{P}\prod_{S\in P}f(S)\sum_{E\subseteq S\times S,P=C(E)}(-1)^{|E|}
\]</span></p>
<p>关于后者，首先我们会发现它的贡献对于划分的每一个部分是独立的，因为两两之间不可能有变，否则就属于同一个等价了，所以我们现在只需要对于一个连通块进行考虑，假设其大小为
<span class="math inline">\(k\)</span>，定义图的价值为 <span class="math inline">\((-1)^{|E|}\)</span>，<span class="math inline">\(E\)</span> 为它的边集。那么我们就是要求所有大小为
<span class="math inline">\(k\)</span> 的连通图的价值和 <span class="math inline">\(f_k\)</span>。不难联系到连通图计数，对于一般图的价值，我们有</p>
<p><span class="math display">\[
\sum_{i=0}\dbinom{\binom{k}{2}}{i}(-1)^i=(1-1)^{\binom{k}{2}}=[k\le 1]
\]</span></p>
<p>那么对于 <span class="math inline">\(f_k\)</span> 的 egf</p>
<p><span class="math display">\[
F(z)=\sum_{k\ge 1}f_k\dfrac{z^k}{k!}
\]</span></p>
<p>（其中 <span class="math inline">\(k\ge 1\)</span>
也是方便讨论，也比较自然，因为在容斥里不会用到 <span class="math inline">\(f_0\)</span> 的值），有</p>
<p><span class="math display">\[
\exp F(z)=1+z
\]</span></p>
<p>因此</p>
<p><span class="math display">\[
F(z)=\ln(1+z),f_k=[x^k]\ln(1+z)=(-1)^{k-1}(k-1)!
\]</span></p>
<p>那么我们有最后的容斥式子</p>
<p><span class="math display">\[
\sum_{P}\prod_{S\in P}f(S)(-1)^{|S|-1}(|S|-1)!
\]</span></p>
<p>这个直接枚举集合划分的复杂度不低于 <span class="math inline">\(O(B(n))\)</span>，<span class="math inline">\(B(n)\)</span> 为 <span class="math inline">\(\text{Bell}\)</span> 数，大概是 <span class="math inline">\(O((\dfrac{e^{-0.6+\epsilon}n}{\ln(n+1)})^n)\)</span>，最多处理
<span class="math inline">\(n\approx 13\)</span>。改用带一定技巧的状压为
<span class="math inline">\(O(3^n)\)</span>，直接使用集合幂级数的 <span class="math inline">\(\exp\)</span> 为 <span class="math inline">\(O(n^22^n)\)</span>。</p>
<p>这个问题应该进一步扩展到图染色问题中（实际上这个问题某种程度是带限制的完全图染色），或者可以用斯特林数，或一些组合解释对这个容斥产生说明。</p>
<h2 id="参考资料">参考资料</h2>
<p><a href="https://en.wikipedia.org/wiki/Bell_number">Bell
number</a></p>
<p><a href="https://blog.csdn.net/qq_35950004/article/details/106150520">省选模拟
幻化成风（容斥原理，状压DP）</a></p>
<p><a href="https://atcoder.jp/contests/abc236/tasks/abc236_h">Distinct
Multiples</a></p>
]]></content>
      <categories>
        <category>研究</category>
      </categories>
      <tags>
        <tag>容斥</tag>
      </tags>
  </entry>
  <entry>
    <title>朝花夕拾</title>
    <url>/2022/01/08/%E6%9C%9D%E8%8A%B1%E5%A4%95%E6%8B%BE/</url>
    <content><![CDATA[<h2 id="碎碎念">碎碎念</h2>
]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>回忆录</tag>
      </tags>
  </entry>
  <entry>
    <title>组合趣题合集</title>
    <url>/2021/07/15/%E7%BB%84%E5%90%88%E8%B6%A3%E9%A2%98%E5%90%88%E9%9B%86/</url>
    <content><![CDATA[<h2 id="section">7.15</h2>
<h3 id="一列">一列</h3>
<h4 id="题面">题面</h4>
<p>设有 <span class="math inline">\(2^{n-1}\)</span>
个不同的数列，每个数列有 <span class="math inline">\(n\)</span>
项，每项都等于 <span class="math inline">\(0\)</span> 或 <span class="math inline">\(1\)</span>。已知，对于这些数列任意 <span class="math inline">\(3\)</span>个数列，都存在正整数 <span class="math inline">\(p\)</span>，使得这 <span class="math inline">\(3\)</span> 个数列的第 <span class="math inline">\(p\)</span> 项都为 <span class="math inline">\(1\)</span>，证明存在唯一的正整数 <span class="math inline">\(k\)</span>，使得对所有 <span class="math inline">\(2^{n-1}\)</span> 个数列的第 <span class="math inline">\(k\)</span> 项都等于 <span class="math inline">\(1\)</span>。 <a id="more"></a> #### 题解</p>
<p>记 <span class="math inline">\(S\)</span> 为这 <span class="math inline">\(2^{n-1}\)</span> 个不同序列构成的集合，那么 <span class="math inline">\(S\subseteq
\lbrace0,1\rbrace^n\)</span>，定义元素之间的按位与运算 <span class="math inline">\(\circ\)</span>，和按位取反运算 <span class="math inline">\(\overline{\mathrm{x}}\)</span>。</p>
<p>首先证明 <span class="math inline">\((0,0,\dotsc,0)\notin
S\)</span>，否则任取其余两个元素 <span class="math inline">\(\mathrm{x}\)</span> 和 <span class="math inline">\(\mathrm{y}\)</span>，则 <span class="math inline">\(\mathrm{x}\circ\mathrm{y}\circ\mathrm{0}=\mathrm{0}\)</span>；</p>
<p>再证明若 <span class="math inline">\(\mathrm{x}\)</span>，则 <span class="math inline">\(\overline{\mathrm{x}}\notin S\)</span>，否则取
<span class="math inline">\(\mathrm{x}\circ\overline{\mathrm{x}}\circ\mathrm{y}=\mathrm{0}\)</span>，矛盾。得到推论
<span class="math inline">\((\mathrm{x},\overline{\mathrm{x}})\)</span>
必有其一 <span class="math inline">\(\in S\)</span>，否则不足 <span class="math inline">\(2^{n-1}\)</span> 个；</p>
<p>最后证明，若 <span class="math inline">\(\mathrm{x},\mathrm{y}\in
S\)</span>，则 <span class="math inline">\(\mathrm{x}\circ\mathrm{y}\in
S\)</span>，否则 <span class="math inline">\(\overline{\mathrm{x}\circ\mathrm{y}}\in
S\)</span>，则 <span class="math inline">\(x\circ y\circ
\overline{\mathrm{x}\circ\mathrm{y}}=\mathrm{0}\)</span> 矛盾。</p>
<p>所以 <span class="math inline">\(\bigcirc_{\mathrm{x}\in
S}\mathrm{x}\)</span> 不为 <span class="math inline">\(\mathrm{0}\)</span>，若有 <span class="math inline">\(k\)</span> 个位置为 <span class="math inline">\(1\)</span>，则 <span class="math inline">\(|S|\)</span> 最大只能为 <span class="math inline">\(2^{n-k}\)</span>，故 <span class="math inline">\(k\)</span> 只能为 <span class="math inline">\(1\)</span>。</p>
]]></content>
      <categories>
        <category>学不明白的东西</category>
      </categories>
  </entry>
  <entry>
    <title>Matrix67 博客笔记</title>
    <url>/2021/04/19/Matrix67-%E5%8D%9A%E5%AE%A2%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="section">4.19</h2>
<h3 id="面积与格点">面积与格点</h3>
<h4 id="题面">题面</h4>
<p>设想一个平面上布满间距为 <span class="math inline">\(1\)</span>
的横纵直线，形成由一个个 <span class="math inline">\(1\times 1\)</span>
正方形组成的网格。任意给一个面积小于 <span class="math inline">\(1\)</span>
个单位的图形，证明这个图形总能放在网格中而不包含任何一个格点。
<a id="more"></a> #### 题解</p>
<p>将该图形 <span class="math inline">\(A\)</span>
先随意放置于网格中，之后将每一个彼此分开，位于网格上的 <span class="math inline">\(A\)</span> 也一起分开，将 <span class="math inline">\(1\times 1\)</span>
的格子只通过平移堆叠在一起，所有 <span class="math inline">\(A\)</span>
的部分取并集，由于 <span class="math inline">\(S_A&lt;1\)</span>，所以一定存在一点满足该点没有被
<span class="math inline">\(A\)</span>
的部分的并覆盖，我们将该点集还原于原网格，在这个点集的基础上构造新的网格即可。</p>
<h4 id="拓展">拓展</h4>
<p><strong>Blichfeldt 定理</strong>：一个面积为 <span class="math inline">\(A\)</span> 的闭区域 <span class="math inline">\(F\)</span> 一定存在大小为 <span class="math inline">\(\lceil A\rceil\)</span>
的点集，满足点集内部的点两两之间横纵坐标差为整数。</p>
<p>同样将所有网格堆叠在一起，假设最多只存在 <span class="math inline">\(\lceil A\rceil-1\)</span>
个格点，那么对于所有点而言，每个点最多只被 <span class="math inline">\(\lceil A\rceil-1\)</span> 个点覆盖，所以 <span class="math inline">\(S_F\le\lceil A\rceil-1&lt; A\)</span>，矛盾。</p>
<p><strong>Minkowski 定理</strong>：坐标平面上任何含 <span class="math inline">\((0,0)\)</span> 且中心对称的凸包 <span class="math inline">\(F\)</span> 满足 <span class="math inline">\(S_F&gt;4\)</span> 一定含有异于原点的整点。</p>
<p>由 <strong>Blichfeldt 定理</strong> 可知，<span class="math inline">\(F\)</span> 内至少有 <span class="math inline">\(2\)</span>
个点满足横纵坐标差为偶数（先放缩），记为 <span class="math inline">\((x,y),(x+p,y+q)\)</span>，由于中心对称，所以存在
<span class="math inline">\((-x-p,-y-q)\in F\)</span>，由于 <span class="math inline">\(F\)</span> 为凸包，取中点得 <span class="math inline">\((\dfrac{p}{2},\dfrac{q}{2})\in
F\)</span>，故存在。</p>
<p>这两个定理都可以拓展到 <span class="math inline">\(\mathbb{R}^n\)</span>
的形式，在密码学中有应用。</p>
<h2 id="section-1">4.19</h2>
<h3 id="升维">升维</h3>
<h4 id="题面-1">题面</h4>
<p>平面上四条直线，任两条不平行，任三条不共点。四个旅行者 <span class="math inline">\(A,B,C,D\)</span>
分别匀速地走在这四条直线上（他们的速度可以不相同）。若 <span class="math inline">\(A\)</span> 在行走过程中与 <span class="math inline">\(B,C,D\)</span> 相遇，<span class="math inline">\(B\)</span> 在行走过程后与 <span class="math inline">\(C,D\)</span> 相遇（当然也遇见了 <span class="math inline">\(A\)</span>），<span class="math inline">\(A,B,C\)</span> 不同时相遇，<span class="math inline">\(A,B,D\)</span> 不同时相遇，求证：<span class="math inline">\(C,D\)</span> 在行走过程中相遇。</p>
<h4 id="题解">题解</h4>
<p>引入时间 <span class="math inline">\(t\)</span>
轴垂直于平面，每个人的位置可以唯一表示为一条直线 <span class="math inline">\(l(x,y,t)\)</span>，由于 <span class="math inline">\(A,B\)</span> 相遇，则 <span class="math inline">\(l_A\)</span> 交与 <span class="math inline">\(l_B\)</span> 确定了平面 <span class="math inline">\(F\)</span>，由于 <span class="math inline">\(C\)</span> 与 <span class="math inline">\(l_A\)</span> 和 <span class="math inline">\(l_B\)</span> 有互异的两个交点，故 <span class="math inline">\(l_C\subset F\)</span>，同理 <span class="math inline">\(l_D\subset F\)</span>，<span class="math inline">\(l_C\)</span> 与 <span class="math inline">\(l_D\)</span> 不平行必有交点。</p>
<h3 id="停机问题">停机问题</h3>
<h4 id="题面-2">题面</h4>
<p>是否存在一个程序 <span class="math inline">\(P\)</span>，对于任意输入的程序 <span class="math inline">\(Q\)</span> 和输入 <span class="math inline">\(w\)</span>，能够判断 <span class="math inline">\(Q(w)\)</span> 会在有限时间内结束或者死循环。</p>
<h4 id="题解-1">题解</h4>
<p>不存在，假设有解，则给定 <span class="math inline">\(H(w)\)</span>
描述为调用 <span class="math inline">\(P(H,w)\)</span>，若 <span class="math inline">\(P(H,w)\)</span> 判断为死循环，否则结束，那么 <span class="math inline">\(H(H)\)</span> 就是反例，矛盾。</p>
<h2 id="section-2">7.14</h2>
<h3 id="丢失的机票">丢失的机票</h3>
<h4 id="题面-3">题面</h4>
<p>一架客机上有 <span class="math inline">\(100\)</span> 个座位，<span class="math inline">\(100\)</span>
个人排队依次登机。第一个乘客把机票搞丢了，但他仍被允许登机。由于他不知道他的座位在哪儿，他就随机选了一个座位坐下。以后每一个乘客登机时，如果他的座位是空着的，那么就在他的座位坐下；否则，他就随机选一个仍然空着的座位坐下。请问，最后一个人登机时发现唯一剩下的空位正好就是他的，其概率是多少？</p>
<h4 id="题解-2">题解</h4>
<p>当第 <span class="math inline">\(i\in [2,99]\)</span>
个人遇到自己的位置被第 <span class="math inline">\(1\)</span>
个人占据后，那么可以理解成第 <span class="math inline">\(1\)</span>
个人要坐第 <span class="math inline">\(i\)</span> 个人的位置，而第 <span class="math inline">\(i\)</span>
人依然是原位置，那么问题规约为最后只剩两个位置，<span class="math inline">\(1\)</span> 号随机选自己，那么答案就是 <span class="math inline">\(\dfrac{1}{2}\)</span>。</p>
<p>或者更细致的，我们设总共有 <span class="math inline">\(n\)</span>
个人， <span class="math inline">\(p_k\)</span> 为第 <span class="math inline">\(k\)</span> 个人座位被占用的概率，那么：</p>
<p><span class="math display">\[
p_k=\dfrac{1}{n}+\sum_{i=2}^{k-1}p_i\dfrac{1}{n+1-i}
\]</span></p>
<p>归纳得 <span class="math inline">\(p_k=\dfrac{1}{n+2-k}\)</span></p>
<h3 id="和-9"><span class="math inline">\(0\)</span> 和 <span class="math inline">\(9\)</span></h3>
<h4 id="题面-4">题面</h4>
<p>任意写下一个数 <span class="math inline">\(N\)</span>，再在它下面写下它的 <span class="math inline">\(2\sim 9\)</span>
倍。把这些数按位对齐，每一列里恰好有 <span class="math inline">\(9\)</span>
个数字（前面几行中的首位为空时该位置视作0）。证明，每一列中至少有一个数字0或者数字9。</p>
<h4 id="题解-3">题解</h4>
<p>假设存在某一列不存在，那么由鸽巢原理得，<span class="math inline">\(aN\)</span> 和 <span class="math inline">\(bN\)</span> 必定有一位相同，那么 <span class="math inline">\((a-b)N\)</span> 该位一定要么是 <span class="math inline">\(9\)</span> 要么是 <span class="math inline">\(0\)</span>，矛盾。</p>
]]></content>
      <categories>
        <category>学不明白的东西</category>
      </categories>
  </entry>
  <entry>
    <title>循环、模、单位根的思考</title>
    <url>/2021/02/22/%E5%BE%AA%E7%8E%AF%E3%80%81%E6%A8%A1%E3%80%81%E5%8D%95%E4%BD%8D%E6%A0%B9%E7%9A%84%E6%80%9D%E8%80%83/</url>
    <content><![CDATA[<p>今天用多项式的角度重新审视 <code>[六省联考2017]组合数问题</code>
这道题。</p>
<p>题干要求</p>
<p><span class="math display">\[
\sum_{i\bmod k=r}\dbinom{nk}{i}
\]</span></p>
<p>的值。 <a id="more"></a>
前年做这一道题是直接看了题解，通过找与之等价的组合意义完成的，现在让我们重新做一遍。</p>
<p>很容易化简得到</p>
<p><span class="math display">\[
\sum_{i\bmod k=r}\lbrack x^i\rbrack(1+x)^{nk}
\]</span></p>
<p>现在看来这个式子意义十分显然，即 <span class="math inline">\((1+x)^{nk}\)</span> 做 <span class="math inline">\(k\)</span>
循环卷积即可。关于循环卷积运算，一直以来有对其正确性的疑问，但现在似乎是搞明白了。</p>
<p>假设 <span class="math inline">\(D_k\)</span>
是对多项式进行约化的算子，即</p>
<p><span class="math display">\[
D_k(f)=\sum_i([x^i]f)x^{i\bmod k}
\]</span></p>
<p>而 <span class="math inline">\(\circ\)</span>
表示循环卷积的算符，很容易验证其对 <span class="math inline">\(+\)</span> 有分配律。</p>
<p>下面讨论命题</p>
<p><span class="math display">\[
D_k(f\times g)=D_k(f)\circ D_k(g)
\]</span></p>
<p>的正确性。</p>
<p>我们对左式展开</p>
<p><span class="math display">\[
\begin{aligned}
D_k(f\times g)&amp;=\sum_i([x^i](f\times g))x^{i\bmod k}\\\\
&amp;=\sum_a\sum_b([x^a]f\times[x^b]g)x^{a+b\bmod k}\\\\
&amp;=\sum_a ([x^a]f)x^{a\bmod k}\circ \sum_{b}([x^b]f)x^{b\bmod k}\\\\
&amp;=D_k(f)\circ D_k(g)
\end{aligned}
\]</span></p>
<p>而今天看到 <span class="math inline">\(\mathrm{jiangly}\)</span> 对
<span class="math inline">\(D_k\)</span> 有另外的表述即</p>
<p><span class="math display">\[
D_k(f)=f\bmod x^k-1
\]</span></p>
<p>这是我第一次见到这样的表述，题解没有细说，它的正确性我口胡了一个证明。</p>
<p>容易验证多项式模运算与整数模运算性质类似，我们不妨考虑 <span class="math inline">\(x^n\bmod x^k-1\)</span> 的值，显然有</p>
<p><span class="math display">\[
x^n=(\sum_{i=1}^{\lfloor\frac{n}{k}\rfloor}x^{n-ik})(x^k-1)+x^{n\bmod k}
\]</span></p>
<p>即 <span class="math inline">\(x^n\equiv x^{n\bmod k}\bmod
x^k-1\)</span> 。</p>
<p>所以对最开始命题的正确性可以用 <span class="math inline">\(\bmod
x^k-1\)</span> 相关运算的性质来说明。</p>
<p>另外，在看到这道题时，还有一个思路就是单位根反演，即</p>
<p><span class="math display">\[
[n|k]=\dfrac{1}{n}\sum_{i=0}^{n-1}\omega_n^{ik}
\]</span></p>
<p>我们将此式联系题目，即</p>
<p><span class="math display">\[
\begin{aligned}
\mathbf{Ans}&amp;=\sum_{r=0}^{k-1}\sum_{i}[k|i-r]\lbrack
x^i\rbrack(1+x)^{nk}\\\\
&amp;=\dfrac{1}{k}\sum_{r=0}^{k-1}\sum_{i}\sum_{j=0}^{k-1}\omega_k^{(i-r)j}\lbrack
x^i\rbrack(1+x)^{nk}\\\\
&amp;=\dfrac{1}{k}\sum_{r=0}^{k-1}\sum_{j=0}^{k-1}\omega_{k}^{-rj}\sum_{i}\omega_k^{ij}\lbrack
x^i\rbrack(1+x)^{nk}\\\\
&amp;=\dfrac{1}{k}\sum_{r=0}^{k-1}\sum_{j=0}^{k-1}\omega_{k}^{-rj}(1+\omega_k^j)^{nk}\\\\
&amp;=\mathbf{IDFT}_k[\mathbf{DFT}_k[(1+x)^{nk}]]
\end{aligned}
\]</span></p>
<p>换句话说 <span class="math inline">\(\mathbf{IDFT}_k[\mathbf{DFT}_k[·]]=D_k(·)\)</span></p>
]]></content>
      <categories>
        <category>研究</category>
      </categories>
  </entry>
  <entry>
    <title>CFR691D2 题解</title>
    <url>/2020/12/20/CFR691D2-%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<h2 id="cf1459e-latin-square"><a href="https://codeforces.com/contest/1459/problem/E">CF1459E Latin
Square</a></h2>
<p>把矩形抽象为 <span class="math inline">\((x,y,z)\)</span> 意思为
<span class="math inline">\(A_{x,y}=z\)</span> 这样位移操作就对应 <span class="math inline">\(X\)</span> 轴或 <span class="math inline">\(Y\)</span> 轴的加减，求逆操作就对应 <span class="math inline">\(X\)</span> 轴或 <span class="math inline">\(Y\)</span> 轴与 <span class="math inline">\(Z\)</span>
轴的交换，我们对于最初的每一维维护它们最终对应的位置和加减情况即可。
<a id="more"></a> <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb(x) push_back(x)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> i64;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> f32;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e3</span>+<span class="number">5</span>, M = <span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> T, n, m, A[N][N], B[N][N], u[<span class="number">3</span>], v[<span class="number">3</span>], w[<span class="number">3</span>]; <span class="keyword">char</span> o[M]; <span class="function"><span class="keyword">void</span> <span class="title">fix</span><span class="params">(<span class="keyword">int</span> &amp;x)</span> </span>&#123; x&lt;n?<span class="number">0</span>:x-=n; &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;T); T--; )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, A[i]+j), --A[i][j];</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, o); <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i) u[i] = i, v[i] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i)</span><br><span class="line">            <span class="keyword">if</span>(o[i] == <span class="string">&#x27;R&#x27;</span>) fix(++v[<span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(o[i] == <span class="string">&#x27;L&#x27;</span>) fix(v[<span class="number">1</span>] += n<span class="number">-1</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(o[i] == <span class="string">&#x27;D&#x27;</span>)  fix(++v[<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(o[i] == <span class="string">&#x27;U&#x27;</span>) fix(v[<span class="number">0</span>] += n<span class="number">-1</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(o[i] == <span class="string">&#x27;I&#x27;</span>) swap(v[<span class="number">1</span>], v[<span class="number">2</span>]), swap(u[<span class="number">1</span>], u[<span class="number">2</span>]);</span><br><span class="line">            <span class="keyword">else</span> swap(v[<span class="number">0</span>], v[<span class="number">2</span>]), swap(u[<span class="number">0</span>], u[<span class="number">2</span>]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">3</span>; ++k) fix(w[k] = (u[k] == <span class="number">2</span>?A[i][j]:u[k]?j:i)+v[k]);</span><br><span class="line">            B[w[<span class="number">0</span>]][w[<span class="number">1</span>]] = w[<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>), ++i) <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, B[i][j]+<span class="number">1</span>);</span><br><span class="line">     &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="cf1459f-flip-and-reverse"><a href="https://codeforces.com/contest/1459/problem/F">CF1459F Flip and
Reverse</a></h2>
<p>我们记 <span class="math inline">\(d_x=\sum_{i=1}^x[s_i=0]-[s_i=1]\)</span>，作出
<span class="math inline">\(x\in[0,n]\)</span>，<span class="math inline">\((x,d_x)\)</span> 的图象，会发现对 <span class="math inline">\([l,r]\)</span> 进行操作需要满足 <span class="math inline">\(d_{l-1}=d_r\)</span>，操作的结果是 <span class="math inline">\(x\in[l,r-1]\)</span> 的 <span class="math inline">\((x,d_x)\)</span> 做左右翻转。</p>
<p>不难发现，无论如何操作 <span class="math inline">\(d_x\)</span>
的值集合都不会发生变化，我们将 <span class="math inline">\((d_{x-1},d_x)\)</span> 连有向边构成边集 <span class="math inline">\(E\)</span> 也不会变化（从合法的区间如果存在 <span class="math inline">\((x,y)\)</span> 必须存在 <span class="math inline">\((y, x)\)</span>
可以得到），那么一个合法的折线图就是 <span class="math inline">\(E\)</span> 与由 <span class="math inline">\(d_x\)</span> 构成的点集 <span class="math inline">\(V\)</span> 决定的图 <span class="math inline">\(G\)</span>，从 <span class="math inline">\(0\)</span> 到 <span class="math inline">\(d_n\)</span> 的一条欧拉路，我们优先走 <span class="math inline">\((x,x+1)\)</span> 这类边即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> T, n, L[N], R[N], m, a[N]; <span class="keyword">char</span> s[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(R[x]) --R[x], dfs(x+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(L[x]) --L[x], dfs(x<span class="number">-1</span>);</span><br><span class="line">    a[++m] = x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;T); T--; )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s+<span class="number">1</span>), n = <span class="built_in">strlen</span>(s+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>, x = n; i &lt;= n; ++i) <span class="keyword">if</span>(s[i] == <span class="string">&#x27;0&#x27;</span>) ++R[x], ++x; <span class="keyword">else</span> ++L[x], --x;</span><br><span class="line">        m = <span class="number">0</span>, dfs(n); <span class="keyword">for</span>(<span class="keyword">int</span> i = m; i &gt; <span class="number">1</span>; --i) <span class="built_in">putchar</span>(a[i<span class="number">-1</span>]-a[i] == <span class="number">1</span>?<span class="string">&#x27;0&#x27;</span>:<span class="string">&#x27;1&#x27;</span>); <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title>[WF2014H]Pachinko</title>
    <url>/2020/10/14/WF2014H-Pachinko/</url>
    <content><![CDATA[<h2 id="题目描述">题目描述</h2>
<p>你已被 <span class="math inline">\(\text{Addictive  Coin
Machines}\)</span>
聘用去帮助设计风靡全球赌场弹球盘系列的下一款夺人眼球，一本万利，让玩家不能自拔的热门产品。</p>
<p>玩弹球盘需要将球发射到存在着钉子，障碍和靶子的网格中。球会在网格间反弹，直到击中任意一个靶子。玩家会根据击中的靶子获得相应的得分。
<a id="more"></a>
下一款弹球盘的网格布局已经设计好了，但是靶子的分值尚未分配。这些分值必须被精心设置，以便像所有赌场设备一样，该游戏是有利可图的，又不至于<em>过于</em>有利可图。因此，弄清楚一个球击中任意特定靶子的概率非常重要。这就是你的工作！</p>
<p>为简单起见，网格被当作一个高矩形，其中有开放的格间（每个用 <span class="math inline">\(.\)</span> 表示），不能穿过的障碍（每个用 <span class="math inline">\(‘“\text{X}&quot;’\)</span> 表示）以及靶子 （每个用
<span class="math inline">\(“\text{T}&quot;\)</span> 表示）。</p>
<p>球会被均匀随机地发射到网格第一层开放的格间中。从那时起，与钉子的碰撞会使以给定概率向上，向下，向左或向右反弹。为简单起见，假定网格中每个格间的这些概率都是对应相等的。如果球反弹到障碍物或试图弹出网格，则球实际上只会停留在原地再次与钉子碰撞。当球击中靶子时，游戏则会立即结束。</p>
<p>你可以放心假定，在击中靶子以前，球到达的平均格间数量不会超过 <span class="math inline">\(10^9\)</span>。如果球一直在弹来弹去，这就不是一款好玩的游戏了。</p>
<p>对于每一个靶子，计算它被发射的球击中的概率。</p>
<h2 id="输入格式">输入格式</h2>
<p>输入只包含一组测试用例。第一行包含整数 <span class="math inline">\(w\)</span> 和 <span class="math inline">\(h\)</span>，分别是弹球盘网格的宽和高（<span class="math inline">\(1\le w\le 20\)</span> 且 <span class="math inline">\(2\le h \le 10\ 000\)</span>）。下一行包含和为
<span class="math inline">\(100\)</span> 的四个非负整数 <span class="math inline">\(u,d,l\)</span> 和 <span class="math inline">\(r\)</span>，分别为在任意一个开放格间中，向上、向下、向左或向右反弹的百分比概率。</p>
<p>接下来 <span class="math inline">\(h\)</span> 行每一行包含 <span class="math inline">\(w\)</span> 个字符，每个字符是 <span class="math inline">\(“.&quot;\)</span>，<span class="math inline">\(“\text{X}&quot;\)</span>，和 <span class="math inline">\(“\text{T}&quot;\)</span>
三者之一。这些行描述了弹球盘的网格布局。第一行描述了网格第一层的情况，包含了至少一个
<span class="math inline">\(.\)</span> 且不含 <span class="math inline">\(“\text{T}&quot;\)</span>。</p>
<h2 id="输出格式">输出格式</h2>
<p>对于每一个网格中的 <span class="math inline">\(“\text{T}&quot;\)</span>
按照从上到下，若在同一行则按从左到右的顺序输出被球击中的概率。输出答案与标准答案的绝对误差最多为
<span class="math inline">\(10^{-6}\)</span>。</p>
<h2 id="题解">题解</h2>
<p>首先直接 dp
是不行的，因为题干中没有拓扑序进行后效性的转移。我们不妨设第一列有 <span class="math inline">\(c\)</span>
个开放格间，我们不妨考虑将题目转化为第一行的开放格间每个有 <span class="math inline">\(\dfrac{1}{c}\)</span> 的贡献，其余开放格间有 <span class="math inline">\(0\)</span>
的贡献，求靶子被击中时球获得贡献的期望，因为原题虽然让求出概率，但这样会有诸多限制，并且在非靶子节点的概率会定义不清，所以改为直接求期望更合适。</p>
<p>这样就变成了图的随机游走模型，我们设整体矩形区域为对角线端点为 <span class="math inline">\((0,0)\)</span> 和 <span class="math inline">\((h-1,w-1)\)</span> 的矩形区域 <span class="math inline">\(A\)</span>，<span class="math inline">\(f_{(i,j)}\)</span> 表示到达 <span class="math inline">\((i,j)\)</span> 这个格间的期望，<span class="math inline">\((i,j)\)</span> 上的字符为 <span class="math inline">\(s_{(i,j)}\)</span>，向上，向下，向左，向右的位移向量依次是
<span class="math inline">\(v_0\)</span> 到 <span class="math inline">\(v_3\)</span>。通过分类讨论，很容易列出方程：</p>
<p>首先，当 <span class="math inline">\(s_{(i,j)}=“\text{X}&quot;\)</span> 时，<span class="math inline">\((i,j)\)</span> 无法到达，<span class="math inline">\(f_{(i,j)}\)</span> 无定义。</p>
<p>之后有，</p>
<p><span class="math display">\[ f_{(i,j)}\ = \sum_{k=0}^{3}\
\begin{cases}
p_{v_{k\oplus 1}}f_{(i,j)+v_k}&amp;(i,j)+v_k\notin A\land
s_{(i,j)+v_k=“.&quot;}\\\\
p_{v_k}f_{(i,j)}&amp;((i,j)+v_k\notin A\lor
s_{(i,j)+v_k}=“\text{X}&quot;)\land s_{(i,j)=“.&quot;}\\\\
0&amp;\text{otherwise}
\end{cases}
\]</span></p>
<p>之后就会有 <span class="math inline">\(wh\)</span>
个线性方程组，直接用高斯消元求解则为 <span class="math inline">\(O((wh)^3)\)</span>。考虑优化，我们不难发现这个矩阵十分稀疏，更具体的，若设
<span class="math inline">\(f_{(i,j)}\)</span> 对应未知数 <span class="math inline">\(x_{wi+j}\)</span> 那么对于第 <span class="math inline">\(x_{wi+j}\)</span>
个方程，它包含的未知数的下标范围即为 <span class="math inline">\([w(i-1)+j,w(i+1)+j]\)</span>，最终高斯消元矩阵的有效部分形态如图所示。</p>
<div data-align="center">
<p><img src="/2020/10/14/WF2014H-Pachinko/a.jpg"></p>
</div>
<p>我们会发现每次我们对第 <span class="math inline">\(i\)</span>
行只需要进行一个大小为 <span class="math inline">\(w\times w\)</span>
的有效矩阵的消元即可，单次复杂度为 <span class="math inline">\(O(w^2)\)</span>，总复杂度为 <span class="math inline">\(O(hw^3)\)</span>。</p>
<p>然而有一种情况需要特殊考虑，即处理第 <span class="math inline">\(i\)</span> 行时，矩阵 <span class="math inline">\((i,i)\)</span> 的值已经为 <span class="math inline">\(0\)</span>
了，如果按照常规的高斯消元，现在需要做的是交换行，在这里也是同理，如图：</p>
<div data-align="center">
<p><img src="/2020/10/14/WF2014H-Pachinko/b.jpg"></p>
</div>
<p>这是已经遇到 <span class="math inline">\(2\)</span>
次该情况，而现在处理黄色行 <span class="math inline">\(i\)</span>
时又遇到了 <span class="math inline">\((i,i)\)</span> 为 <span class="math inline">\(0\)</span> 的情况，这是我们遍历 <span class="math inline">\([i-w,i+w]\)</span>
的每一行，若发现一个灰色行，即已经在之前已经被处理过的直接跳过，若遇到一个红色行
<span class="math inline">\(p\)</span>，满足 <span class="math inline">\((p,i)\)</span> 不为 <span class="math inline">\(0\)</span>，则把 <span class="math inline">\(p\)</span> 行当作当前处理的行，这时要用 <span class="math inline">\(p\)</span> 行的 <span class="math inline">\([i,p+w]\)</span> 对 <span class="math inline">\([p+1,i+w]\)</span> 行进行消元。若不存在符合条件的
<span class="math inline">\(p\)</span>，则说明从题干的角度看 <span class="math inline">\((\lfloor\dfrac{i}{w}\rfloor,i\mod w)\)</span>
不可达，或者无法到达靶子格间，从矩阵的角度看这一行无解或者有无穷多的解。</p>
<p>但实际上还有一种特殊情况未考虑，即考虑如下数据：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2 4</span><br><span class="line">20 40 0 40</span><br><span class="line">.X</span><br><span class="line">..</span><br><span class="line">.X</span><br><span class="line">.T</span><br></pre></td></tr></table></figure>
<p>对于位于 <span class="math inline">\((1,1)\)</span>
的点来说，只要进入这个点就再也走不出去了，期望在这里没有定义，但是这与通过一开始分类讨论得到方程
<span class="math inline">\(0=\frac{2}{5}f_{(1,0)}\)</span>
这是矛盾的，所以我们要对这样的方程进行调整，通过连通性特判这种情况，或者是令方程中由于移向做差让系数变为
<span class="math inline">\(0\)</span> 的 <span class="math inline">\(f_{(1,1)}\)</span>
的系数调整一个很小的实数，由于该点出不去，所以也无法对其他点造成影响，也恰好印证了题干中的假设，经过的房间平均个数不超过
<span class="math inline">\(10^9\)</span>。</p>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
  </entry>
  <entry>
    <title>[NEERC2016(NR)G] Gangsters in Central City</title>
    <url>/2020/10/13/NEERC2016-NR-G-Gangsters-in-Central-City/</url>
    <content><![CDATA[<h2 id="题目描述">题目描述</h2>
<p>长期以来，中心市的水没有什么问题。城市的下水道系统是一种有根树结构：中央水库位于树的根节点，房屋位于树的叶节点。水从中央水库通过管道延树边流向每间房屋，所有房屋都可以使用到水。</p>
<p>突然，强盗们占领了一些房屋。作为市长，你非常忧虑并且想要驱逐这些强盗。所以，你打算停止向那些强盗占领的房屋供水。为此，你可能需要阻断下水道系统的某些管道。如果从水库到某房屋的路径中至少有一条被阻断的管道，那么该房屋将无法取水。
<a id="more"></a>
你非常害怕强盗，所以你决定阻断最小数量的管道以免发生意外。同时，你关心居民，因此对于已确定数量的被阻断的管道，你希望最大限度减少没有强盗且无法取水的房屋的数量。</p>
<p>不幸的是，强盗们可能出现或消失在某些房屋里。所以在每次强盗位置改变后，你要询问科学家被阻断管道的最小数量和没有强盗且无法取水的房屋的最小数量。</p>
<h2 id="输入格式">输入格式</h2>
<p>第一行的输入包含两个整数 <span class="math inline">\(n\)</span> 和
<span class="math inline">\(q\)</span>，下水道系统中节点的数量和强盗位置改变的次数
<span class="math inline">\((2\le n \le 10^5;1\le q \le
10^5)\)</span>。</p>
<p>第二行包含对下水道系统的描述：一个有 <span class="math inline">\(n-1\)</span> 个整数的序列 <span class="math inline">\(p_2,p_3,\dots,p_n\)</span>，其中 <span class="math inline">\(p_i\)</span> 表示节点 <span class="math inline">\(i\)</span> 的父节点 <span class="math inline">\((1\le p_i &lt; i)\)</span>。中央水库位于 <span class="math inline">\(1\)</span> 号节点。</p>
<p>接下来 <span class="math inline">\(q\)</span>
行表示强盗位置的变化。每次改变为下面两种方式之一：<span class="math inline">\(“+\ v”\)</span> — 强盗占领了位于节点 <span class="math inline">\(v\)</span> 的房屋；<span class="math inline">\(“-\
v”\)</span> — 强盗离开了位于节点 <span class="math inline">\(v\)</span>
的房屋。</p>
<p>一开始，所有房屋都没有强盗。所有更改以正确的顺序进行：强盗不能占领它们已经占领的房屋，并且不能离开它们尚未占领的房屋。</p>
<h2 id="输出格式">输出格式</h2>
<p>输出应包含 <span class="math inline">\(2q\)</span>
个整数，每行有两个：<span class="math inline">\(c_i\)</span> —
被阻断的管道的最小数量以及 <span class="math inline">\(h_i\)</span> —
在阻断 <span class="math inline">\(c_i\)</span>
个管道的情况下没有强盗且无法取水的房屋的最小数量。</p>
<h2 id="题解">题解</h2>
<p>首先考虑最优化被阻断的管道个数，我们将叶节点按照所属 <span class="math inline">\(1\)</span>
子节点的子树分组，对于分别位于两组的一对占领节点，我们无法找到一条管道阻断后使这两个节点同时不可达，而对于存在占领节点的一组而言，设占领节点构成的集合为
<span class="math inline">\(S\)</span>，我们总能找到一条管道切断根节点到
<span class="math inline">\(S\)</span> 的路径，具体的，这条管道就是
<span class="math inline">\(\operatorname{LCA}(S)\)</span>
到根节点路径上任意一条边。综上，<span class="math inline">\(c\)</span>
的值即为 <span class="math inline">\(1\)</span>
子节点含有被占领节点的子树个数。</p>
<p>之后最优化没有强盗且无法取水的房屋的最小数量。根据上述分析，每组相互独立，<span class="math inline">\(h\)</span> 为选择阻断的边 <span class="math inline">\((p_x,\ x)\)</span> 中 <span class="math inline">\(x\)</span>
内叶节点的个数减去该组占领节点的个数，<span class="math inline">\(x\)</span> 取值为 <span class="math inline">\(\operatorname{LCA}(S)\)</span>
到根节点（不含根节点）的路径上的任意一点，<span class="math inline">\(x\)</span> 深度越浅，叶节点的个数就越多，因此
<span class="math inline">\(x\)</span> 取 <span class="math inline">\(\operatorname{LCA}(S)\)</span> 最优。</p>
<p>所以我们将问题转化为求 <span class="math inline">\(\operatorname{LCA}(S)\)</span>。我们对树进行从
<span class="math inline">\(1\)</span> 节点开始的 DFS，记 <span class="math inline">\(x\)</span> 的 DFS 序为 <span class="math inline">\(dfn_x\)</span>。存在下述性质：</p>
<p><span class="math display">\[
dfn_x=\min_{v\in S}dfn_v,dfn_y=\max_{v\in S}dfn_v\Rightarrow
\operatorname{LCA}(S)=\operatorname{LCA}(x,y)
\]</span></p>
<p>证明：假设存在 <span class="math inline">\(z\)</span> 满足 <span class="math inline">\(dfn_z\in(dfn_x,dfn_y)\)</span> 使得 <span class="math inline">\(\operatorname{LCA}(x,y)\)</span> 不是 <span class="math inline">\(z\)</span> 的祖先，那么在 DFS 进行对 <span class="math inline">\(\operatorname{LCA}(x,y)\)</span>
的子树遍历时就不会访问到节点 <span class="math inline">\(z\)</span>，所以 <span class="math inline">\(dfn_z\notin(dfn_x,dfn_y)\)</span>，与假设矛盾，所以上述性质成立。</p>
<p>因此我们需要找到一个支持加入和删除，查询最值得数据结构。使用堆或平衡树即可在单次修改
<span class="math inline">\(O(\log n)\)</span> 得时间内维护。而 <span class="math inline">\(\operatorname{LCA}\)</span>
的计算，我们可以使用倍增，树链剖分，欧拉序等轻松得出。标程的复杂度为
<span class="math inline">\(O((n+q)\log n)\)</span>。</p>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
  </entry>
  <entry>
    <title>[WF2015L]Weather Report</title>
    <url>/2020/10/12/WF2015L-Weather-Report/</url>
    <content><![CDATA[<h2 id="题目描述">题目描述</h2>
<p>你已被气候测量协会聘用，该协会是致力于追踪全球气候在长时间内变化趋势的科学组织。
当然，这绝非易事。
他们在世界各地部署了许多小型设备，旨在对当地天气状况进行定期测量。
这些是廉价的设备，它们的功能受到某些限制。每天，它们观测一次可能会发生于当天的四类标准天气中的一种：<span class="math inline">\(Sunny\)</span>、<span class="math inline">\(Cloudy\)</span>、<span class="math inline">\(Rainy\)</span> 或 <span class="math inline">\(Frogs\)</span>。每进行 <span class="math inline">\(n\)</span>
次观测之后，将结果报告给主服务器进行分析。但是，大量的设备导致可用的通信带宽过载。协会需要你帮忙提出一种压缩这些报告序列位数的方法。
<a id="more"></a>
对于一个特定的设备所处的位置，你可以假设该地每天的天气是一个独立的随机事件，并且你会得知上述四种天气发生的概率。设备的
<span class="math inline">\(4^n\)</span>
个可能报告中的每一个都必须编码为唯一的二进制序列，满足任意序列都不是其它任意序列的前缀（重要性质，若不满足则服务器将不知道每个序列何时结束）。你的目标是使用一种编码方式，以最大减少期望的传输位数。</p>
<h2 id="输入格式">输入格式</h2>
<p>第一行包含一个整数 <span class="math inline">\(n\)</span>（<span class="math inline">\(1\le n\le 20\)</span>）
代表每个设备进行的观测次数。</p>
<p>第二行包含四个正实数，<span class="math inline">\(p_{\operatorname{sunny}}\)</span>，<span class="math inline">\(p_{\operatorname{cloudy}}\)</span>，<span class="math inline">\(p_{\operatorname{rainy}}\)</span> 和 <span class="math inline">\(p_{\operatorname{frogs}}\)</span>
代表各自天气发生的概率。保证这 <span class="math inline">\(4\)</span>
个概率小数点后不超过 <span class="math inline">\(6\)</span> 位且和为
<span class="math inline">\(1\)</span>。</p>
<h2 id="输出格式">输出格式</h2>
<p>输出报告编码的最小期望位数，要求误差不超过 <span class="math inline">\(10^{-4}\)</span>。</p>
<h2 id="题解">题解</h2>
<p>设一个设备 <span class="math inline">\(4^n\)</span>
个可能报告构成的集合 <span class="math inline">\(S\)</span>，报告 <span class="math inline">\(x\)</span> 的编码长度 <span class="math inline">\(l_x\)</span>，出现概率为 <span class="math inline">\(w_x\)</span>，则最后的期望：</p>
<p><span class="math display">\[
\sum_{x\in S}w_xl_x
\]</span></p>
<p>我们不难发现这个恰好满足哈夫曼编码的代价，启发我们使用哈夫曼树来解决这类问题。</p>
<p>首先一个很粗糙的想法就是暴力枚举 <span class="math inline">\(4^n\)</span>
个不同的报告序列再执行哈夫曼树算法的过程。但实际上我们注意到可以分成较少的组，满足每个组内的
<span class="math inline">\(w_x\)</span>
的值相同。这样我们就可以用二元组 <span class="math inline">\((c,w)\)</span> 来表示一个大小为 <span class="math inline">\(c\)</span> 权值为 <span class="math inline">\(w\)</span> 的组。一开始，对于一个权值形如 <span class="math inline">\(p_{\operatorname{sunny}}^ap_{\operatorname{cloudy}}^bp_{\operatorname{rainy}}^cp_{\operatorname{frogs}}^d(a+b+c+d=n)\)</span>
的组而言，其大小为 <span class="math inline">\(\binom{n}{a\ b\ c\
d}\)</span>。之后我们执行哈夫曼树算法的流程，每次取出堆顶的二元组 <span class="math inline">\((c,w)\)</span> 并弹出，根据 <span class="math inline">\(c\)</span> 的大小进行讨论： * 若 <span class="math inline">\(c=1\)</span> 则再次取出堆顶的二元组 <span class="math inline">\((c&#39;,w&#39;)\)</span>，将 <span class="math inline">\((1,w+w&#39;)\)</span> 和 <span class="math inline">\((c&#39;-1,w)\)</span> 重新加入堆中，答案加上 <span class="math inline">\(w+w&#39;\)</span>。 * 若 <span class="math inline">\(c&gt;1\)</span> 且 <span class="math inline">\(c\)</span> 为奇数，则将 <span class="math inline">\((\frac{c-1}{2},2w)\)</span> 和 <span class="math inline">\((1,w)\)</span> 加入堆中，答案加上 <span class="math inline">\(2w\)</span>。 * 若 <span class="math inline">\(c&gt;0\)</span> 且 <span class="math inline">\(c\)</span> 为偶数，则将 <span class="math inline">\((\frac{c}{2},2w)\)</span> 加入堆中，答案加上 <span class="math inline">\(2w\)</span>。</p>
<p>重复上述步骤直到堆中只有一个二元组，且该二元组大小为 <span class="math inline">\(1\)</span>。</p>
<p>时间复杂度限于笔者能力，不能给出一个精确的计算，只能给出一个粗略的上下界。首先一开始初始的二元组个数为
<span class="math inline">\(O(n^3)\)</span>，上界即通过假定每个二元组中
<span class="math inline">\(c\)</span> 的 <span class="math inline">\(\log n!\)</span> 个二进制位都取 <span class="math inline">\(1\)</span> 得到，此时堆中最多会有 <span class="math inline">\(O(n^3\log n!)\)</span> 即 <span class="math inline">\(O(n^4\log n)\)</span> 个二元组，那么复杂度上界为
<span class="math inline">\(O(n^4\log n\log(n^4\log n))\)</span> 即
<span class="math inline">\(O(n^4\log^2 n)\)</span>
级别；下界为假设每次都恰好使当前方案数总和减半，那么复杂度为 <span class="math inline">\(O(n^3\log 4^n\log n^4)\)</span> 即 <span class="math inline">\(O(n^4\log n)\)</span>
级别，若有读者知道如何精确分析上下界欢迎与笔者讨论。</p>
<p>通过实际的检验，在题目数据范围内该算法的实际运行与上面估计有较好的拟合，但若出现概率为
<span class="math inline">\(0\)</span>
的情况（在数据范围外），则会呈现明显高于上文估计的上界的增长，这大概是由于上述分析忽略情况
<span class="math inline">\(1\)</span> 对 <span class="math inline">\(c&#39;\)</span> 减 <span class="math inline">\(1\)</span> 的结果，但笔者尚未清楚其中的机理。</p>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>哈夫曼编码</tag>
      </tags>
  </entry>
  <entry>
    <title>绝对做不完的IOI2021集训队作业</title>
    <url>/2020/10/12/%E7%BB%9D%E5%AF%B9%E5%81%9A%E4%B8%8D%E5%AE%8C%E7%9A%84IOI2021%E9%9B%86%E8%AE%AD%E9%98%9F%E4%BD%9C%E4%B8%9A/</url>
    <content><![CDATA[<p><del>希望不要丢人</del> <a id="more"></a></p>
<p>这篇文章咕了，而且已经丢人了。</p>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
  </entry>
  <entry>
    <title>退役前的做题记录</title>
    <url>/2020/10/08/%E9%80%80%E5%BD%B9%E5%89%8D%E7%9A%84%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<p>由于集训队作业出来了，所以这篇文章就不再更新了QwQ</p>
<p><span class="math inline">\(\color{red}{\bullet}\)</span>
是抄的题解</p>
<h2 id="section">10.8</h2>
<h3 id="pkuwc2018随机游走-colorredbullet"><a href="https://loj.ac/problem/2542">[PKUWC2018]随机游走</a> <span class="math inline">\(\color{red}{\bullet}\)</span></h3>
<p>显然用 <span class="math inline">\(\min-\max\)</span>
容斥将所求变成到达一个点集的最早期望时间。考虑最早时间如何求出，对于一个点集
<span class="math inline">\(S\)</span>，不妨设 <span class="math inline">\(f_x\)</span> 为 <span class="math inline">\(x\)</span> 内的点到 <span class="math inline">\(S\)</span> 的最早期望时间。 <a id="more"></a> 则对于
<span class="math inline">\(x\in S\)</span> 有 <span class="math inline">\(f_x=0\)</span>。</p>
<p>对于 <span class="math inline">\(x\notin S\)</span> 有</p>
<p><span class="math display">\[
f_x=1+\frac{1}{\deg x}\sum_{(x,y)\in E}f_y
\]</span></p>
<p>这样需要高斯消元，但考虑到本题的树形结构，我们以起点 <span class="math inline">\(x\)</span>
为根，通过一次函数来分离父子关系，即设</p>
<p><span class="math display">\[
f_x=A_x\times f_{fa_x}+B_x
\]</span></p>
<p>那么对于 <span class="math inline">\(x\notin S\)</span>
即可改写为</p>
<p><span class="math display">\[
f_x=1+\frac{1}{\deg x}(f_{fa_x}+\sum_{y\in son_x}(A_yf_x+B_y))
\]</span></p>
<p>化简得</p>
<p><span class="math display">\[
\begin{aligned}
A_x&amp;=\frac{1}{\deg x-\sum_{y\in son_x}A_x}\\\\B_x&amp;=\frac{\deg
x+\sum_{y\in son_x}B_x}{\deg x-\sum_{y\in son_x}A_x}    
\end{aligned}
\]</span></p>
<p>显然对于起点 <span class="math inline">\(x\)</span> 而言，<span class="math inline">\(f_x=B_x\)</span>，对于 <span class="math inline">\(x\in S\)</span> 而言 <span class="math inline">\(A_x=B_x=0\)</span>。</p>
<p>之后就是一个高维前缀和了，复杂度 <span class="math inline">\(O(n2^n\log P+q)\)</span>。</p>
<p><a href="https://loj.ac/submission/950752">code</a></p>
<h3 id="cf1422f-boring-queries-colorredbullet"><a href="http://codeforces.com/problemset/problem/1422/F">CF1422F Boring
Queries</a> <span class="math inline">\(\color{red}{\bullet}\)</span></h3>
<p>这道题就类似于在线区间数颜色。先离线考虑，会发现确定右端点后存在一个类似单调栈的结构，用主席树存下来就行了。</p>
<p><a href="http://codeforces.com/contest/1422/submission/94895847">code</a></p>
<h3 id="cf1422e-minlexes-colorredbullet"><a href="http://codeforces.com/problemset/problem/1422/E">CF1422E
Minlexes</a> <span class="math inline">\(\color{red}{\bullet}\)</span></h3>
<p>会发现题中的最优化具有最优子结构，直接 dp
就行了，比较字典序大小的时候大力猜结论，需要比较的前缀一定都是同一个字母就好了，或者封装一个哈希表。</p>
<p><a href="http://codeforces.com/contest/1422/submission/94912287">code</a></p>
<h3 id="cf1422d-returning-home-colorredbullet"><a href="http://codeforces.com/problemset/problem/1422/D">CF1422D Returning
Home</a> <span class="math inline">\(\color{red}{\bullet}\)</span></h3>
<p>降智题，自己写的时候优化建图写歪了。正解就是排序后按顺序连边。</p>
<p><a href="http://codeforces.com/contest/1422/submission/94904208">code</a></p>
<h3 id="模拟赛-石子游戏-colorredbullet">[10.8模拟赛] 石子游戏 <span class="math inline">\(\color{red}{\bullet}\)</span></h3>
<p>根据 <span class="math inline">\((x-y)_2{[j]}=(x-y-k\times2^{j+1})_2{[j]}\)</span>
进行合理的后缀和加减即可得出。</p>
<h2 id="section-1">10.9</h2>
<p>今天什么是也没干，帮学弟写完题解之后就一直在颓颓颓，就把题解搬到这里吧。</p>
<h3 id="签到题">签到题</h3>
<p>考虑最优解的形态，一定是一个字符依次非严格递减且最长的序列，用单调栈维护即可，也可以存一个后缀最大值暴力跳。复杂度
<span class="math inline">\(O(n)\)</span>。</p>
<h3 id="送分题">送分题</h3>
<p>题目来源 <a href="https://www.luogu.com.cn/problem/P6196">[EER1]代价</a>。</p>
<p>通过观察样例，我们不难得到一个较优解，它的值为：</p>
<p><span class="math display">\[
\sum_{i=1}^{n-1}a_i\times a_{i-1}+\min_{i=1}^na_i
\]</span></p>
<p>我们记最小值的位置为 <span class="math inline">\(p\)</span>，则这个解的一种构造方式为先删除 <span class="math inline">\(1\)</span> 到 <span class="math inline">\(p-1\)</span> 的数，在删除 <span class="math inline">\(n\)</span> 到 <span class="math inline">\(p\)</span> 的数。我们注意到 <span class="math inline">\(a_i\times a_{i-1}\)</span>
无论以什么方式删除，至少都会产生一次的贡献，因此这样构造已经比大多数情况优了。考虑少数情况何时取到，注意到满足</p>
<p><span class="math display">\[
a_{i-1}\times a_i+a_i\times a_{i+1}&gt;a_{i-1}\times a_i \times a_{i+1}
\]</span></p>
<p>时这种构造就不够优秀了，此时 <span class="math inline">\(a_{i-1}\le
1\)</span> 或 <span class="math inline">\(a_{i+1}\le 1\)</span>
因此我们以 <span class="math inline">\(1\)</span>
为分界点，重复上述构造即可，复杂度 <span class="math inline">\(O(n)\)</span>。</p>
<h3 id="白给题">白给题</h3>
<p>依旧是考虑最优解的形态，不难发现最优解一定是从 <span class="math inline">\(X\)</span>先走一段 <span class="math inline">\(X\)</span> 到 <span class="math inline">\(Y\)</span> 的最短路，再走 <span class="math inline">\(0\)</span> 边，通过 <span class="math inline">\(X\)</span> 到 <span class="math inline">\(Y\)</span> 的最短路走到 <span class="math inline">\(Y\)</span>。若出现中间交错显然不优，所以我们建立
<span class="math inline">\(S-T\)</span> 的最短路图，在上面
<code>dp</code> 即可。</p>
<h3 id="简单题">简单题</h3>
<p>题目来源 <a href="https://www.luogu.com.cn/problem/P5616">[MtOI2019]恶魔之树</a>。</p>
<p>一个很粗糙的想法就是先离散化，记 <span class="math inline">\(x\)</span> 出现次数为 <span class="math inline">\(c_x\)</span> 则若它被选中有 <span class="math inline">\(2^{c_x}-1\)</span>
的贡献，然后状压质因数的次数。从这个想法出发，如果我们只关注 <span class="math inline">\(\le\sqrt{300}\)</span> 的 <span class="math inline">\(7\)</span> 个质数，对他们的指数进行状压，剩下用
<span class="math inline">\(0-1\)</span> 背包的形式添加贡献就可做到
<span class="math inline">\(O(300\times9\times6\times4\times3\times3\times3\times3)\)</span>
的复杂度。</p>
<p>具体的就是设 <span class="math inline">\(f(i)\)</span> 表示最后子集
<span class="math inline">\(\le\sqrt{300}\)</span> 的质数构成的数为
<span class="math inline">\(\prod p_k^{i_k}\)</span>
的带权方案数，这里的带权是指它会带上那些 <span class="math inline">\(&gt;\sqrt{300}\)</span> 质数的权值。我们对于 <span class="math inline">\(&gt;\sqrt{300}\)</span>
的质数一批一批的考虑，记当前考虑的数为 <span class="math inline">\(p\)</span>，那么我们把所有 <span class="math inline">\(p|x\)</span> 的 <span class="math inline">\(x\)</span>，先带上 <span class="math inline">\(2^{c_x}-1\)</span> 的贡献，加入到这个 <span class="math inline">\(\max\)</span> 卷积的背包中，最后统一乘上 <span class="math inline">\(p\)</span>
即可。注意实现过程中的不要出现自己更新自己的情况。</p>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
  </entry>
  <entry>
    <title>20200225模拟赛</title>
    <url>/2020/02/25/20200225%E6%A8%A1%E6%8B%9F%E8%B5%9B/</url>
    <content><![CDATA[<h2 id="div">div</h2>
<p>首先我们有一个十分简单的式子</p>
<p><span class="math display">\[
\operatorname{E}(n)=\frac{1}{\sigma_0(n)}\sum_{d|n}E(d)+1
\]</span></p>
<p>其中 <span class="math inline">\(\sigma_0\)</span> 为约数个数</p>
<p>化简之后得 <a id="more"></a> <span class="math display">\[
\operatorname{E}(n)=\frac{1}{\sigma_0(n)-1}\Big(\sum_{d|n,d\ne
n}E(d)+\sigma_0(n)\Big)
\]</span></p>
<p>复杂度为 <span class="math inline">\(\operatorname{O}(n)\)</span>
显然过不了，但是这个式子其实告诉我们转移只与唯一分解质因子的指数集有关，而每次转移正好是一次高维前缀和</p>
<p>我们不需要表示出每一个数的指数集，我们只需要关注那些随质因子单调递增，指数非严格单调递增的数就好了，而这些数在
<span class="math inline">\(1\times10^{18}\)</span> 中只有 <span class="math inline">\(172513\)</span> 个，而与之有关的质因子也只有前
<span class="math inline">\(18\)</span> 个，这些是可以通过
<code>DFS</code> 预处理出来的</p>
<p>我们将这些数按照转移顺序排序记第 <span class="math inline">\(i\)</span> 个数 <span class="math inline">\(n\)</span> 的期望为 <span class="math inline">\(f_i\)</span>，那么我们考虑高维前缀和 <span class="math inline">\(s_{j,i}\)</span> 表示第 <span class="math inline">\(i\)</span> 个数满足前 <span class="math inline">\(0\)</span> 到 <span class="math inline">\(j-1\)</span> 个指数的大小与 <span class="math inline">\(n\)</span> 相同，而剩下的指数小于等于其对应 <span class="math inline">\(n\)</span> 的指数，根据这个我们列出方程</p>
<p><span class="math display">\[
s_{j,i}=s_{j+1,i}+s_{j,[\frac{n}{p_k}]}
\]</span></p>
<p>这个式子前一部分的意思是 <span class="math inline">\(j\)</span>
这一位不做改变，而后面的式子就是将 <span class="math inline">\(j\)</span> 这一位的指数减 <span class="math inline">\(1\)</span>，其中 <span class="math inline">\(k\)</span> 是满足 <span class="math inline">\(c_j=c_k\)</span> 最大的 <span class="math inline">\(k\)</span>，这是由于我们需要满足指数非严格单调递减的条件，否则就搜不到，<span class="math inline">\(n\)</span> 除以 <span class="math inline">\(p_j\)</span> 和 <span class="math inline">\(p_k\)</span> 在指数集的意义上是等价的</p>
<p>由于我们先有的 <span class="math inline">\(s_{j,i}\)</span>
那么这时候 <span class="math inline">\(s_{0,i}\)</span> 的意义就是 <span class="math inline">\(n\)</span> 所有约数的期望和，直接转移可得 <span class="math inline">\(f_i\)</span> 的值，最后将 <span class="math inline">\(f_i\)</span> 的值更新所有的 <span class="math inline">\(s_{j,i}\)</span> 即可</p>
<p>最后查询的话我们只有求出指数集，从大到小排序后即可找到其对应的等价的数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> i64;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">int</span> f = <span class="number">1</span>, <span class="keyword">int</span> x = <span class="number">0</span>, <span class="keyword">char</span> ch = <span class="string">&#x27; &#x27;</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">isdigit</span>(ch = getchar())) <span class="keyword">if</span>(ch == <span class="string">&#x27;-&#x27;</span>) f = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch)) x = x*<span class="number">10</span>+ch-<span class="string">&#x27;0&#x27;</span>, ch = getchar();</span><br><span class="line">    <span class="keyword">return</span> f*x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> P = <span class="number">1e9</span>+<span class="number">7</span>, N = <span class="number">172513</span>+<span class="number">5</span>, M = <span class="number">19</span>, p[] = &#123; <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">13</span>, <span class="number">17</span>, <span class="number">19</span>, <span class="number">23</span>, <span class="number">29</span>, <span class="number">31</span>, <span class="number">37</span>, <span class="number">41</span>, <span class="number">43</span>, <span class="number">47</span>, <span class="number">53</span>, <span class="number">59</span>, <span class="number">61</span>, <span class="number">67</span>, <span class="number">71</span>, <span class="number">73</span>&#125;; <span class="keyword">const</span> i64 B = <span class="number">1e9</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">num26</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    i64 a, b;</span><br><span class="line">    num26(i64 a = <span class="number">0</span>, i64 b = <span class="number">0</span>):a(a), b(b) &#123;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">char</span> s[<span class="number">30</span>]; <span class="keyword">if</span>(!~<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s)) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> n = <span class="built_in">strlen</span>(s); reverse(s, s+n), a = <span class="number">0</span>, b = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = min(<span class="number">8</span>, n<span class="number">-1</span>); ~i; --i) a = a*<span class="number">10</span>+s[i]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = min(<span class="number">23</span>, n<span class="number">-1</span>); i &gt; <span class="number">8</span>; --i) b = b*<span class="number">10</span>+s[i]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (num26 a, num26 b) &#123; <span class="keyword">return</span> a.b^b.b?a.b&lt;b.b:a.a&lt;b.a; &#125;</span><br><span class="line">    num26 <span class="keyword">friend</span> <span class="keyword">operator</span> + (num26 a, num26 b) &#123; <span class="keyword">return</span> num26((a.a+b.a)%B, a.b+b.b+(a.a+b.a)/B); &#125;</span><br><span class="line">    num26 <span class="keyword">friend</span> <span class="keyword">operator</span> * (num26 a, <span class="keyword">int</span> b) &#123; <span class="keyword">return</span> num26(a.a*b%B, a.b*b+a.a*b/B); &#125;</span><br><span class="line">    num26 <span class="keyword">friend</span> <span class="keyword">operator</span> / (num26 a, <span class="keyword">int</span> b) &#123; <span class="keyword">return</span> num26(((a.a%b)+(a.b%b)*B)/b, <span class="number">0</span>)+num26(a.a/b, a.b/b); &#125;</span><br><span class="line">    <span class="keyword">int</span> <span class="keyword">friend</span> <span class="keyword">operator</span> % (num26 a, <span class="keyword">int</span> b) &#123; <span class="keyword">return</span> (a.a%b+a.b%b*B%b)%b; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">const</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">char</span> c)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(b) <span class="built_in">printf</span>(<span class="string">&quot;%lld%09lld&quot;</span>, b, a); <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>, a);</span><br><span class="line">        <span class="built_in">putchar</span>(c); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">const</span> num26 <span class="title">oo</span><span class="params">(<span class="number">0</span>, (i64)<span class="number">1e15</span>)</span></span>;</span><br><span class="line"><span class="keyword">int</span> T, m, c[M], tot, s[M][N], f[N]; num26 n, w[N]; <span class="built_in">pair</span>&lt;num26, <span class="keyword">int</span>&gt; h[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">H</span><span class="params">(num26 n)</span> </span>&#123; <span class="keyword">return</span> h[lower_bound(h+<span class="number">1</span>, h+<span class="number">1</span>+tot, <span class="built_in">make_pair</span>(n, <span class="number">0</span>))-h].second; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(num26 n, <span class="keyword">int</span> i, <span class="keyword">int</span> pre)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ++tot, h[tot] = <span class="built_in">make_pair</span>(n, tot), w[tot] = n; <span class="keyword">if</span>(oo &lt; n*p[i]) <span class="keyword">return</span>; n = n*p[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= pre; ++j, n = n*p[i])</span><br><span class="line">    &#123; dfs(n, i+<span class="number">1</span>, j); <span class="keyword">if</span>(oo &lt; n*p[i]) <span class="keyword">return</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">i64 <span class="title">inv</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123; <span class="keyword">return</span> i == <span class="number">1</span>?<span class="number">1</span>:P-(P/i)*inv(P%i)%P; &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    freopen(<span class="string">&quot;div.in&quot;</span>, <span class="string">&quot;r&quot;</span>, <span class="built_in">stdin</span>), freopen(<span class="string">&quot;div.out&quot;</span>, <span class="string">&quot;w&quot;</span>, <span class="built_in">stdout</span>), dfs(num26(<span class="number">1</span>, <span class="number">0</span>), <span class="number">0</span>, <span class="number">90</span>), sort(h+<span class="number">1</span>, h+<span class="number">1</span>+tot);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= tot; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        num26 n = w[i], m = w[i]; <span class="keyword">int</span> sig = <span class="number">1</span>; </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">18</span>; ++j) </span><br><span class="line">        &#123; <span class="keyword">while</span>(m%p[j] == <span class="number">0</span>) m = m/p[j], ++c[j]; sig *= c[j]+<span class="number">1</span>; &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">17</span>, k; ~j; --j)</span><br><span class="line">        &#123;   </span><br><span class="line">            <span class="keyword">for</span>(k = j; k&lt;<span class="number">17</span>&amp;&amp;c[k+<span class="number">1</span>] == c[j]; ++k);</span><br><span class="line">            <span class="keyword">if</span>(c[k]) s[j][i] = (s[j+<span class="number">1</span>][i]+s[j][H(n/p[k])])%P;</span><br><span class="line">        &#125;</span><br><span class="line">        f[i] = (s[<span class="number">0</span>][i]+sig)*inv(sig<span class="number">-1</span>)%P;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">18</span>; ++j) s[j][i] = (s[j][i]+f[i])%P, c[j] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(~n.read())</span><br><span class="line">    &#123;</span><br><span class="line">        m = read();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>, p; i &lt; m; ++i)</span><br><span class="line">        &#123; p = read(); <span class="keyword">while</span>(n%p == <span class="number">0</span>) n = n/p, ++c[i]; &#125;</span><br><span class="line">        sort(c, c+m), reverse(c, c+m);  </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) <span class="keyword">for</span>( ; c[i]; n = n*p[i], --c[i]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, f[H(n)]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title>CF1054H Epic Convolution</title>
    <url>/2020/02/24/CF1054H-Epic-Convolution/</url>
    <content><![CDATA[<p>最近突然想做多项式了，就找了些题，这道题用的 <code>2D-FFT</code>
的科技我还不会</p>
<p>首先和式的 <span class="math inline">\(i\)</span> 和 <span class="math inline">\(j\)</span>
除了出现在下标上，就是出现在指数上，并且 <span class="math inline">\(490019\)</span> 是一个质数 <span class="math inline">\(\varphi(490019)=490018=2\times491\times499\)</span>
我们就可以想到按照 <span class="math inline">\(i^2j^3\)</span>
模这些数的值的余数来计算，即答案为 <a id="more"></a> <span class="math display">\[
\sum_x\sum_y\sum_zc^{[x,y,z]}\sum_{i=0}^{n-1}\sum_{j=0}^{n-1}A_iB_j[i^2j^2\operatorname{mod}491=x][i^2j^2\operatorname{mod}499=y][i^2j^2\operatorname{mod}2=z]
\]</span></p>
<p>其中 <span class="math inline">\([x,y,z]\)</span>
为中国剩余定理的合并</p>
<p>并且我们知道通过离散对数可以很容易把乘变成加，其中 <span class="math inline">\(2\)</span> 的原根为 <span class="math inline">\(1\)</span>，<span class="math inline">\(491\)</span> 的原根为 <span class="math inline">\(2\)</span>，<span class="math inline">\(499\)</span> 的原根为 <span class="math inline">\(7\)</span>，<span class="math inline">\(2\)</span>
其实也可以不搞原根，直接暴力，那么考虑我们最后需要求出的二元函数 <span class="math inline">\(f_i(x,y)\)</span>， <span class="math inline">\(g_i(x,y)\)</span>，<span class="math inline">\(h_i(x,y)\)</span> 实际上表示为</p>
<p><span class="math display">\[
[x^ny^m]f_t=\sum_{i^2\operatorname{mod}2=t,\operatorname{ind}_2^{491}i^2=n,\operatorname{ind}_7^{499}i^2=m}A_i
\]</span></p>
<p><span class="math display">\[
[x^ny^m]g_t=\sum_{i^2\operatorname{mod}2=t,\operatorname{ind}_2^{491}i^3=n,\operatorname{ind}_7^{499}i^3=m}B_i
\]</span></p>
<p><span class="math display">\[
[x^ny^m]h_t=\sum_{a\And b=t}[x^ny^m]{(f_a\times g_b)}
\]</span></p>
<p>而后面的 <span class="math inline">\(f_a\)</span> 与 <span class="math inline">\(g_b\)</span> 为二维卷积，需要用
<code>2D-FFT</code> 优化</p>
<p>其中，<code>2D-FFT</code> 的公式通过如下给出，首先是
<code>DFT</code></p>
<p><span class="math display">\[
y_{i,j}=\sum_{k=0}^{n-1}\sum_{l=0}^{m-1}a_{k,l}\omega_n^{ik}\omega_n^{jl}
\]</span></p>
<p>而加入我们定列 <code>DFT</code> 为</p>
<p><span class="math display">\[
z_{i,l}=\sum_{k=0}^{n-1}a_{k,l}\omega_n^{ik}
\]</span></p>
<p>很显然</p>
<p><span class="math display">\[
y_{i,j}=\sum_{l=0}^{m-1}\omega_n^{jl}z_{i,l}
\]</span></p>
<p>综上，<code>2D-DFT</code> 即为先做列 <code>DFT</code> 在做行
<code>DFT</code>，颠倒也可以，那么 <code>IDFT</code> 同理</p>
<p>最后需要考虑有一些不存在离散对数的情况，那么这些为 <span class="math inline">\(491\)</span> 或 <span class="math inline">\(499\)</span> 的倍数，需要单独抽出来考虑，我们认为
<span class="math inline">\(n,m\)</span> 同阶的话复杂度有 <span class="math inline">\(\operatorname{O}(p\log p+\frac{n^2}{\sqrt
p})\)</span> 需要轻微卡常</p>
]]></content>
      <categories>
        <category>题解</category>
        <category>模板</category>
      </categories>
      <tags>
        <tag>多项式</tag>
        <tag>FFT</tag>
      </tags>
  </entry>
  <entry>
    <title>[CTSC2010]性能优化</title>
    <url>/2020/02/23/CTSC2010-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<p><del>深知自己快退役了，所以这段时间打算把 <code>FFT</code>
原理的那一部分搞明白</del></p>
<p>首先，我们需要知道平常我们做的 <code>FFT</code>
实际上是循环卷积，循环卷积的长度相当于单位根的下指标，而平时这个值都是大于最后次数的，所以和普通卷积并无差别，具体来说我们要求的是</p>
<p><span class="math display">\[
c_k=\sum_{i=0}^{n-1}\sum_{j=0}^{n-1}a_ib_j[(i+j)\operatorname{mod}n=k]
\]</span></p>
<p>由单位根反演可得 <a id="more"></a> <span class="math display">\[
\begin{aligned}
c_k&amp;=\sum_{i=0}^{n-1}\sum_{j=0}^{n-1}a_ib_j\big(\frac{1}{k}\sum_{d=0}^{n-1}\omega_n^{(i+j-k)d}\big)\\\\&amp;=\frac{1}{k}\sum_{d=0}^{n-1}\omega_n^{-kd}\big(\sum_{i=0}^{n-1}a_i\omega_n^{id}\big)\big(\sum_{j=0}^{n-1}b_j\omega_n^{jd}\big)
\end{aligned}
\]</span></p>
<p>我们发现前一部分是 <code>IDFT</code> 而后一部分是
<code>DFT</code>，合起来就是 <code>FFT</code> 了</p>
<p>但这就要求我们可以实现任意长度 <code>FFT</code>，然而对于
<code>FFT</code> 实际求解中最关键的一步却要求需要为 <span class="math inline">\(2\)</span> 的整数次幂，具体过程如下</p>
<p>考虑当前多项式 <span class="math inline">\(A(x)\)</span>
我们不妨设</p>
<p><span class="math display">\[
A^{[0]}(x)=\sum_{i\operatorname{mod}2=0}a_ix^{\frac{i}{2}}
\]</span></p>
<p>以及</p>
<p><span class="math display">\[
A^{[1]}(x)=\sum_{i\operatorname{mod}2=1}a_ix^{\frac{i-1}{2}}
\]</span></p>
<p>那么显然</p>
<p><span class="math display">\[
A(\omega_n^i)=A^{[0]}(w_n^{2i})+w_n^iA^{[1]}(\omega_n^{2i})
\]</span></p>
<p>由折半引理得，对于前一半</p>
<p><span class="math display">\[
A(\omega_n^i)=A^{[0]}(w_{\frac{n}{2}}^i)+w_n^iA^{[1]}(w_{\frac{n}{2}}^i)
\]</span></p>
<p>对于后一半而言</p>
<p><span class="math display">\[
A(\omega_n^i)=A^{[0]}(w_{\frac{n}{2}}^i)-w_n^iA^{[1]}(w_{\frac{n}{2}}^i)
\]</span></p>
<p>所以达到问题规模减小的目的</p>
<p>但对于一般的 <span class="math inline">\(n\)</span>
而言我们需要找到它的因子 <span class="math inline">\(m\)</span>
类比上方做如下变换，设</p>
<p><span class="math display">\[
A^{[j]}(x)=\sum_{i\operatorname{mod}m=j}a_ix^{\frac{i-j}{m}}
\]</span></p>
<p>而最终的</p>
<p><span class="math display">\[
\begin{aligned}
A(w_n^i)&amp;=\sum_{j=0}^{m-1}\omega_n^{ij}A^{[j]}(\omega_n^{im})\\\\&amp;=\sum_{j=0}^{m-1}\omega_n^{ij}A^{[j]}(\omega_{\frac{n}{m}}^i)
\end{aligned}
\]</span></p>
<p>这道题由于保证 <span class="math inline">\(n\)</span>
可以表示为若干不超过 <span class="math inline">\(10\)</span>
的正整数乘积，所以复杂度得到保证，更一般的我们可以使用
<code>Bluestein's Algorithm</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> i64;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">int</span> f = <span class="number">1</span>, <span class="keyword">int</span> x = <span class="number">0</span>, <span class="keyword">char</span> ch = <span class="string">&#x27; &#x27;</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">isdigit</span>(ch = getchar())) <span class="keyword">if</span>(ch == <span class="string">&#x27;-&#x27;</span>) f = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch)) x = x*<span class="number">10</span>+ch-<span class="string">&#x27;0&#x27;</span>, ch = getchar();</span><br><span class="line">    <span class="keyword">return</span> f*x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">5e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> n, C, m, P, gn, lim, d[N]; i64 g[N];</span><br><span class="line"><span class="function">i64 <span class="title">qpow</span><span class="params">(i64 a, <span class="keyword">int</span> b)</span> </span>&#123; i64 ret = <span class="number">1</span>; <span class="keyword">for</span>( ; b; b &gt;&gt;= <span class="number">1</span>, a = a*a%P) <span class="keyword">if</span>(b&amp;<span class="number">1</span>) ret = ret*a%P; <span class="keyword">return</span> ret; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">prepare</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; p; </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>, n = P<span class="number">-1</span>; i &lt;= <span class="number">7</span>; ++i)</span><br><span class="line">        <span class="keyword">if</span>(n%i == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            p.push_back(i);</span><br><span class="line">            <span class="keyword">while</span>(n%i == <span class="number">0</span>) n /= i, d[++m] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">for</span>(gn = <span class="number">1</span>; ; ++gn)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>( ; i &lt; p.size()&amp;&amp;qpow(gn, (P<span class="number">-1</span>)/p[i]) != <span class="number">1</span>; ++i);</span><br><span class="line">        <span class="keyword">if</span>(i == p.size()) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    g[<span class="number">0</span>] = <span class="number">1</span>; <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) g[i] = g[i<span class="number">-1</span>]*gn%P;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Poly</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; A;</span><br><span class="line">    <span class="keyword">int</span>&amp; <span class="keyword">operator</span> [] (<span class="keyword">const</span> <span class="keyword">int</span> i) &#123; <span class="keyword">return</span> A[i]; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">ti</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> A.size()<span class="number">-1</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> ti)</span> </span>&#123; A.resize(ti+<span class="number">1</span>); &#125;</span><br><span class="line">&#125;A, B;</span><br><span class="line"><span class="keyword">void</span> _FFT(Poly &amp;A, <span class="keyword">int</span> _)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(!A.ti()) <span class="keyword">return</span>; <span class="keyword">int</span> n = A.ti()+<span class="number">1</span>, m = d[_];</span><br><span class="line">    <span class="built_in">vector</span>&lt;Poly&gt; B; B.resize(m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) B[i].<span class="built_in">set</span>(n/m<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n<span class="number">-1</span>; ++i) B[i%m][(i-(i%m))/m] = A[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) _FFT(B[i], _+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>, q = lim/n; i &lt;= n<span class="number">-1</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        A[i] = <span class="number">0</span>; </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>, p = <span class="number">0</span>; j &lt; m; ++j, p = (p+i)%n)</span><br><span class="line">            A[i] = (A[i]+g[p*q]*B[j][i%(n/m)]%P)%P;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FFT</span><span class="params">(Poly &amp;A, <span class="keyword">int</span> t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!t) _FFT(A, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        reverse(++A.A.begin(), A.A.end()), _FFT(A, <span class="number">1</span>); i64 v = qpow(n, P<span class="number">-2</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lim; ++i) A[i] = A[i]*v%P;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n = read(), C = read(), A.<span class="built_in">set</span>(n<span class="number">-1</span>), B.<span class="built_in">set</span>(n<span class="number">-1</span>), lim = n, P = n+<span class="number">1</span>, prepare();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) A[i] = read();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) B[i] = read();</span><br><span class="line">    FFT(A, <span class="number">0</span>), FFT(B, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) A[i] = A[i]*qpow(B[i], C)%P;</span><br><span class="line">    FFT(A, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, A[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>多项式</tag>
        <tag>FFT</tag>
      </tags>
  </entry>
  <entry>
    <title>[HNOI2019]白兔之舞</title>
    <url>/2020/02/22/HNOI2019-%E7%99%BD%E5%85%94%E4%B9%8B%E8%88%9E/</url>
    <content><![CDATA[<p>很显然，设答案序列为 <span class="math inline">\(a\)</span> 则有</p>
<p><span class="math display">\[
a_t=\sum_{i=0}^L\binom{L}{i}w^i_{x,y}[i\operatorname{mod}k=t]
\]</span></p>
<p>由单位根反演</p>
<p><span class="math display">\[
[n|k]=\frac{1}{n}\sum_{i=0}^{n-1}\omega_n^{ki}
\]</span> <a id="more"></a> 带入答案式子就有</p>
<p><span class="math display">\[
a_t=\sum_{i=0}^L\binom{L}{i}w_{x,y}^i\frac{1}{k}\sum_{j=0}^{k-1}\omega_k^{(i-t)j}
\]</span></p>
<p>我们交换求和顺序</p>
<p><span class="math display">\[
a_t=\frac{1}{k}\sum_{j=0}^{k-1}\omega_k^{-tj}\sum_{i=0}^L\binom{L}{i}w_{x,y}^i\omega_k^{ij}
\]</span></p>
<p>后面的部分用二项式定理得</p>
<p><span class="math display">\[
a_t=\frac{1}{k}\sum_{j=0}^{k-1}\omega_k^{-tj}(\omega_k^jw+e)^L_{x,y}
\]</span></p>
<p>我们考虑多项式</p>
<p><span class="math display">\[
f(x)=\frac{1}{k}\sum_{j=0}^{k-1}x^j(\omega_k^jw+e)^L_{x,y}
\]</span></p>
<p>那么有</p>
<p><span class="math display">\[
a_t=f(\omega_k^{-t})
\]</span></p>
<p>单位根的求值可以用 <code>FFT</code> 快速求出，但前提是在项数为 <span class="math inline">\(2\)</span>
的整数次幂的情况下，如果我们要做任意长度的 <code>DFT</code> 那么就需要用
<code>Bluestein's Algorithm</code> 具体细节如下</p>
<p>考虑 <code>DFT</code> 的形式</p>
<p><span class="math display">\[
y_j=\sum_{i=0}^{n-1}a_i(\omega_n^j)^i
\]</span></p>
<p>根据 <span class="math inline">\(ij=\binom{i+j}{2}-\binom{i}{2}-\binom{j}{2}\)</span>
可以得到</p>
<p><span class="math display">\[
y_j=\omega_n^{-\binom{j}{2}}\sum_{i=0}^{n-1}a_i\omega_n^{-\binom{i}{2}}\omega_n^{\binom{i+j}{2}}
\]</span></p>
<p>如果设</p>
<p><span class="math display">\[
f=\sum_{i=0}^{n-1}a_i\omega_n^{-\binom{i}{2}}x^i
\]</span></p>
<p><span class="math display">\[
g=\sum_{i=0}^{2n-2}\omega_n^{\binom{2n-2-i}{2}}x^i
\]</span></p>
<p>则</p>
<p><span class="math display">\[
y_j=\omega_n^{-\binom{j}{2}}[x^{2n-2-j}]{(f\times g)}
\]</span></p>
<p>而后者就是一个普通的卷积</p>
<p>接着，我们考虑 <code>IDFT</code></p>
<p><span class="math display">\[
c_j=\frac{1}{n}\sum_{i=0}^{n-1}a_i\omega_n^{-ij}
\]</span></p>
<p>其实与上面同理，只不过是符号变了罢了</p>
<p>若我们考虑模 <span class="math inline">\(p\)</span> 意义下的原根
<span class="math inline">\(g\)</span>，用 <span class="math inline">\(g^{\frac{p-1}{k}}\)</span> 来代替 <span class="math inline">\(\omega_k\)</span> 的话，就用拆系数
<code>FTT</code> 即可</p>
<p>计算一下总复杂度为 <span class="math inline">\(\operatorname{O}(\Delta+kn^3\log L+k\log
k)\)</span> 最前面是求原根的复杂度</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> i64;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> f64;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">int</span> f = <span class="number">1</span>, <span class="keyword">int</span> x = <span class="number">0</span>, <span class="keyword">char</span> ch = <span class="string">&#x27; &#x27;</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">isdigit</span>(ch = getchar())) <span class="keyword">if</span>(ch == <span class="string">&#x27;-&#x27;</span>) f = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch)) x = x*<span class="number">10</span>+ch-<span class="string">&#x27;0&#x27;</span>, ch = getchar();</span><br><span class="line">    <span class="keyword">return</span> f*x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">3</span>, K = <span class="number">1</span>&lt;&lt;<span class="number">18</span>|<span class="number">5</span>; <span class="keyword">const</span> f64 PI = <span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="keyword">int</span> n, k, kinv, L, x, y, P, gn, g[K], f[K];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Mat</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    i64 A[N][N];</span><br><span class="line">    Mat() &#123; <span class="built_in">memset</span>(A, <span class="number">0</span>, <span class="keyword">sizeof</span>(A)); &#125;</span><br><span class="line">    i64* <span class="keyword">operator</span> [] (<span class="keyword">const</span> <span class="keyword">int</span> i) &#123; <span class="keyword">return</span> A[i]; &#125;</span><br><span class="line">    <span class="keyword">friend</span> Mat <span class="keyword">operator</span> * (Mat A, Mat B)</span><br><span class="line">    &#123;</span><br><span class="line">        Mat C;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j)</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; n; ++k)</span><br><span class="line">                    C[i][j] = (C[i][j]+A[i][k]*B[k][j]%P)%P;</span><br><span class="line">        <span class="keyword">return</span> C;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">friend</span> Mat <span class="keyword">operator</span> * (<span class="keyword">int</span> k, Mat A)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j)</span><br><span class="line">                A[i][j] = k*A[i][j]%P;</span><br><span class="line">        <span class="keyword">return</span> A;       </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">friend</span> Mat <span class="keyword">operator</span> + (Mat A, Mat B)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j)</span><br><span class="line">                A[i][j] = (A[i][j]+B[i][j])%P;</span><br><span class="line">        <span class="keyword">return</span> A;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">()</span> </span>&#123; <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) A[i][i] = <span class="number">1</span>; &#125;</span><br><span class="line">    <span class="keyword">friend</span> Mat <span class="keyword">operator</span> ^ (Mat A, <span class="keyword">int</span> b)</span><br><span class="line">    &#123;</span><br><span class="line">        Mat ret; ret.<span class="built_in">set</span>();</span><br><span class="line">        <span class="keyword">for</span>( ; b; b &gt;&gt;= <span class="number">1</span>, A = A*A) <span class="keyword">if</span>(b&amp;<span class="number">1</span>) ret = ret*A;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;w, e;</span><br><span class="line"><span class="function">i64 <span class="title">qpow</span><span class="params">(i64 a, <span class="keyword">int</span> b)</span> </span>&#123; i64 ret = <span class="number">1</span>; <span class="keyword">for</span>( ; b; b &gt;&gt;= <span class="number">1</span>, a = a*a%P) <span class="keyword">if</span>(b&amp;<span class="number">1</span>) ret = ret*a%P; <span class="keyword">return</span> ret; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">groot</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; p; <span class="keyword">int</span> n = P<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>, t = <span class="built_in">sqrt</span>(n); i &lt;= n; ++i)</span><br><span class="line">        <span class="keyword">if</span>(n%i == <span class="number">0</span>) &#123; p.push_back(i); <span class="keyword">while</span>(n%i == <span class="number">0</span>) n /= i; &#125;</span><br><span class="line">    <span class="keyword">if</span>(n != <span class="number">1</span>) p.push_back(n);</span><br><span class="line">    <span class="keyword">for</span>(gn = <span class="number">1</span>; ; ++gn)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>; <span class="keyword">for</span>( ; i &lt; p.size()&amp;&amp;qpow(gn, (P<span class="number">-1</span>)/p[i]) != <span class="number">1</span>; ++i);</span><br><span class="line">        <span class="keyword">if</span>(i == p.size()) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    gn = qpow(gn, (P<span class="number">-1</span>)/k), g[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; k; ++i) g[i] = <span class="number">1l</span>l*g[i<span class="number">-1</span>]*gn%P;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> Bluestein</span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">C</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    f64 a, b;</span><br><span class="line">    C(f64 a = <span class="number">0</span>, f64 b = <span class="number">0</span>):a(a), b(b) &#123;&#125;;</span><br><span class="line">    <span class="keyword">friend</span> C <span class="keyword">operator</span> + (C a, C b) &#123; <span class="keyword">return</span> C(a.a+b.a, a.b+b.b); &#125;</span><br><span class="line">    <span class="keyword">friend</span> C <span class="keyword">operator</span> - (C a, C b) &#123; <span class="keyword">return</span> C(a.a-b.a, a.b-b.b); &#125;</span><br><span class="line">    <span class="keyword">friend</span> C <span class="keyword">operator</span> * (C a, C b) &#123; <span class="keyword">return</span> C(a.a*b.a-a.b*b.b, a.a*b.b+a.b*b.a); &#125;</span><br><span class="line">    C <span class="keyword">operator</span> ~ () &#123; <span class="keyword">return</span> C(a, -b); &#125;</span><br><span class="line">&#125;w[K], S[K], T[K];</span><br><span class="line"><span class="keyword">int</span> lim, rev[K], C2[K];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">prepare</span><span class="params">(<span class="keyword">int</span> ti)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(lim = <span class="number">1</span>; lim &lt;= ti; lim &lt;&lt;= <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; lim; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        w[i] = C(<span class="built_in">cos</span>(<span class="number">2</span>*PI*i/lim), <span class="built_in">sin</span>(<span class="number">2</span>*PI*i/lim)), rev[i] = j;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = lim&gt;&gt;<span class="number">1</span>; (j ^= k) &lt; k; k &gt;&gt;= <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Poly</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; A; <span class="built_in">vector</span>&lt;C&gt; B;</span><br><span class="line">    <span class="keyword">int</span>&amp; <span class="keyword">operator</span> [] (<span class="keyword">const</span> <span class="keyword">int</span> i) &#123; <span class="keyword">return</span> A[i]; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> ti)</span> </span>&#123; A.resize(ti+<span class="number">1</span>); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">ti</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> A.size()<span class="number">-1</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> B.clear(); &#125; </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123; </span><br><span class="line">        <span class="keyword">int</span> n = ti(); B.resize(n+<span class="number">1</span>); </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; ++i) B[i] = C(A[i]&gt;&gt;<span class="number">15</span>, A[i]&amp;<span class="number">32767</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">FFT</span><span class="params">(<span class="keyword">int</span> t)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!t)</span><br><span class="line">        &#123;</span><br><span class="line">            B.resize(lim); <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lim; ++i) <span class="keyword">if</span>(i &lt; rev[i]) swap(B[i], B[rev[i]]);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> mid = <span class="number">1</span>; mid &lt; lim; mid &lt;&lt;= <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>, len = mid&lt;&lt;<span class="number">1</span>; j &lt; lim; j += len)</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>, p = <span class="number">0</span>, q = lim/len; k &lt; mid; ++k, p += q)</span><br><span class="line">                    &#123;</span><br><span class="line">                        C x = B[j+k], y = w[p]*B[j+k+mid];</span><br><span class="line">                        B[j+k] = x+y, B[j+k+mid] = x-y;</span><br><span class="line">                    &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            reverse(++B.begin(), B.end()), FFT(<span class="number">0</span>); <span class="function">C <span class="title">v</span><span class="params">(<span class="number">1.0</span>/lim, <span class="number">0</span>)</span></span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lim; ++i) B[i] = B[i]*v;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">friend</span> Poly <span class="keyword">operator</span> * (Poly A, Poly B)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> n = A.ti(), m = B.ti(); prepare(n+m), A.init(), B.init();</span><br><span class="line">        A.FFT(<span class="number">0</span>), B.FFT(<span class="number">0</span>); C p, q, a, b, c, d;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lim; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            p = A.B[i], q = ~A.B[i?lim-i:<span class="number">0</span>], a = (p+q)*C(<span class="number">0.5</span>, <span class="number">0</span>), b = (p-q)*C(<span class="number">0</span>, <span class="number">-0.5</span>);</span><br><span class="line">            p = B.B[i], q = ~B.B[i?lim-i:<span class="number">0</span>], c = (p+q)*C(<span class="number">0.5</span>, <span class="number">0</span>), d = (p-q)*C(<span class="number">0</span>, <span class="number">-0.5</span>);</span><br><span class="line">            S[i] = a*c+b*d*C(<span class="number">0</span>, <span class="number">1</span>), T[i] = a*d+b*c;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lim; ++i) A.B[i] = S[i], B.B[i] = T[i];</span><br><span class="line">        A.FFT(<span class="number">1</span>), B.FFT(<span class="number">1</span>), A.<span class="built_in">set</span>(n+m);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n+m; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            i64 a = A.B[i].a+<span class="number">0.5</span>, b = B.B[i].a+<span class="number">0.5</span>, c = A.B[i].b+<span class="number">0.5</span>;</span><br><span class="line">            A[i] = (a%P*(<span class="number">1</span>&lt;&lt;<span class="number">30</span>)+b%P*(<span class="number">1</span>&lt;&lt;<span class="number">15</span>)+c)%P, A[i] = (A[i]+P)%P;</span><br><span class="line">        &#125;</span><br><span class="line">        A.clear(), B.clear(); <span class="keyword">return</span> A;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> *a, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Poly F, G; F.<span class="built_in">set</span>(n<span class="number">-1</span>), G.<span class="built_in">set</span>((n<span class="number">-1</span>)&lt;&lt;<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; (n<span class="number">-1</span>)&lt;&lt;<span class="number">1</span>; ++i) C2[i+<span class="number">1</span>] = (C2[i]+i)%n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) F[i] = <span class="number">1l</span>l*a[i]*g[C2[i]?n-C2[i]:<span class="number">0</span>]%P;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= (n<span class="number">-1</span>)&lt;&lt;<span class="number">1</span>; ++i) G[i] = g[C2[(n<span class="number">-1</span>)*<span class="number">2</span>-i]];</span><br><span class="line">    F = F*G; <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) a[i] = <span class="number">1l</span>l*g[C2[i]?n-C2[i]:<span class="number">0</span>]*F[(n<span class="number">-1</span>)*<span class="number">2</span>-i]%P;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n = read(), k = read(), L = read(), x = read()<span class="number">-1</span>, y = read()<span class="number">-1</span>, P = read();</span><br><span class="line">    kinv = qpow(k, P<span class="number">-2</span>), e.<span class="built_in">set</span>(), groot();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) w[i][j] = read();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; ++i) f[i] = kinv*((g[i]*w+e)^L)[x][y]%P;   </span><br><span class="line">    Bluestein::solve(f, k);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; ++i) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, f[i?k-i:<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>模板</category>
      </categories>
      <tags>
        <tag>多项式</tag>
        <tag>FFT</tag>
      </tags>
  </entry>
  <entry>
    <title>确实学不会的类欧几里得算法</title>
    <url>/2020/02/21/%E7%A1%AE%E5%AE%9E%E5%AD%A6%E4%B8%8D%E4%BC%9A%E7%9A%84%E7%B1%BB%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p><del>所谓类欧几里得就是复杂度与欧几里得算法类似，但其他完全不一样的算法</del></p>
<p>开始之前，先做一个简单的约定，其中 <span class="math inline">\(0^0=1\)</span></p>
<p><span class="math display">\[
\operatorname{S_m}(n)=\sum_{i=0}^ni^m
\]</span></p>
<h2 id="p5170-模板类欧几里得算法"><a href="https://www.luogu.com.cn/problem/P5170">P5170
【模板】类欧几里得算法</a></h2>
<p>设题目中所要求的为</p>
<p><span class="math display">\[
\begin{aligned}
&amp;\operatorname{f}(a,b,c,n)=\sum_{i=0}^n\lfloor\frac{ai+b}{c}\rfloor\\\\
&amp;\operatorname{g}(a,b,c,n)=\sum_{i=0}^n\lfloor\frac{ai+b}{c}\rfloor^2\\\\
&amp;\operatorname{h}(a,b,c,n)=\sum_{i=0}^ni\lfloor\frac{ai+b}{c}\rfloor    
\end{aligned}
\]</span> 我们先从 <span class="math inline">\(\operatorname{f}\)</span>
入手 <a id="more"></a> 首先，有一个很明显的恒等式</p>
<p><span class="math display">\[
\begin{aligned}
\lfloor\frac{Ax}{y}\rfloor&amp;=\lfloor\frac{A(y\lfloor\frac{x}{y}\rfloor+x\operatorname{mod}y)}{y}\rfloor\\\\&amp;=\lfloor\frac{A(x\operatorname{mod}y)}{y}\rfloor+A\lfloor\frac{x}{y}\rfloor    
\end{aligned}
\]</span></p>
<p>所以就有</p>
<p><span class="math display">\[
\begin{aligned}
\operatorname{f}(a,b,c,n)&amp;=\operatorname{S_1}(n)\lfloor\frac{a}{c}\rfloor+\operatorname{S_0}(n)\lfloor\frac{b}{c}\rfloor+\sum_{i=0}^n\lfloor\frac{(a\operatorname{mod}c)i+(b\operatorname{mod}c)}{c}\rfloor\\\\&amp;=\operatorname{S_1}(n)\lfloor\frac{a}{c}\rfloor+\operatorname{S_0}(n)\lfloor\frac{b}{c}\rfloor+\operatorname{f}(a\operatorname{mod}c,b\operatorname{mod}c,c)
\end{aligned}
\]</span></p>
<p>根据这个我们就可以把 <span class="math inline">\(a\ge c\)</span> 和
<span class="math inline">\(b\ge c\)</span> 转化为 <span class="math inline">\(a&lt;c\)</span> 和 <span class="math inline">\(b&lt;c\)</span></p>
<p>那么考虑 <span class="math inline">\(a&lt;c\land b &lt; c\)</span>
的情形，设 <span class="math inline">\(m=\lfloor\frac{an+b}{c}\rfloor\)</span></p>
<p>我们有</p>
<p><span class="math display">\[
\begin{aligned}
\operatorname{f}(a,b,c,n)&amp;=\sum_{i=0}^n\sum_{j=1}^m[j\le\lfloor\frac{ai+b}{c}\rfloor]\\\\&amp;=\sum_{j=0}^{m-1}\sum_{i=0}^n[jc+c\le
ai+b]   
\end{aligned}
\]</span></p>
<p>之后我们需要明确</p>
<p><span class="math display">\[
\lfloor\frac{a}{b}\rfloor\le\frac{a}{b}\le\lceil\frac{a}{b}\rceil=\lfloor\frac{a-1}{b}\rfloor+1
\]</span></p>
<p>当且仅当 <span class="math inline">\(b|a\)</span> 时等号取到</p>
<p>所以</p>
<p><span class="math display">\[
\begin{aligned}
\operatorname{f}(a,b,c,n)&amp;=\sum_{j=0}^{m-1}\sum_{i=0}^n[\lceil\frac{jc+c-b}{a}\rceil\le
i]\\\\&amp;=\sum_{j=0}^{m-1}\sum_{i=0}^n[\lfloor\frac{jc+c-b-1}{a}\rfloor&lt;
i]
\end{aligned}
\]</span></p>
<p>由于 <span class="math inline">\(\frac{(m-1)c+c-b-1}{a}&lt;n\)</span>
所以式子可以变为</p>
<p><span class="math display">\[
\begin{aligned}
\operatorname{f}(a,b,c,n)&amp;=nm-\sum_{j=0}^{m-1}\lfloor\frac{jc+c-b-1}{a}\rfloor\\\\&amp;=nm-\operatorname{f}(c,c-b-1,a,m-1)
\end{aligned}
\]</span></p>
<p>这就是一个类似于更相减损的方法了，那么很显然有边界</p>
<p>当 <span class="math inline">\(a=0\lor n=0\)</span> 时， <span class="math inline">\(\operatorname{f}(a,b,c,n)=\operatorname{S}_0(n)\lfloor\frac{b}{c}\rfloor\)</span></p>
<p>之后我们再看 <span class="math inline">\(\operatorname{g}\)</span>，我们类比 <span class="math inline">\(\operatorname{f}\)</span> 的过程</p>
<p>首先 <span class="math inline">\(a\ge c\lor b\ge c\)</span> 时，</p>
<p><span class="math display">\[
\begin{aligned}
\operatorname{g}(a,b,c,n)=&amp;\sum_{i=0}^n(\lfloor\frac{(a\operatorname{mod}c)i+(b\operatorname{mod}c)}{c}\rfloor+i\lfloor\frac{a}{c}\rfloor+\lfloor\frac{b}{c}\rfloor)^2\\\\=&amp;\operatorname{S}_2(n)\lfloor\frac{a}{c}\rfloor^2+2\operatorname{S}_1(n)\lfloor\frac{a}{c}\rfloor\lfloor\frac{b}{c}\rfloor+\operatorname{S}_0(n)\lfloor\frac{b}{c}\rfloor^2+\operatorname{g}(a\operatorname{mod}c,b\operatorname{mod}c,c)\\\\&amp;+2\lfloor\frac{a}{c}\rfloor\operatorname{h}(a\operatorname{mod}c,b\operatorname{mod}c,c)+2\lfloor\frac{b}{c}\rfloor\operatorname{f}(a\operatorname{mod}c,b\operatorname{mod}c,c)
\end{aligned}
\]</span></p>
<p>接着我们讨论 <span class="math inline">\(a&lt; c\land b&lt;
c\)</span> 不妨设 <span class="math inline">\(m=\lfloor\frac{an+b}{c}\rfloor\)</span></p>
<p><span class="math display">\[
\begin{aligned}
\operatorname{g}(a,b,c,n)&amp;=\sum_{i=0}^n(\sum_{j=1}^m[j\le\lfloor\frac{ai+b}{c}\rfloor])^2\\\\&amp;=\sum_{i=0}^n\sum_{j=1}^m\sum_{k=1}^m[j\le\lfloor\frac{ai+b}{c}\rfloor][k\le\lfloor\frac{ai+b}{c}\rfloor]\\\\&amp;=\sum_{i=0}^n\sum_{j=0}^{m-1}\sum_{k=0}^{m-1}[\lfloor\frac{jc+c-b-1}{a}\rfloor&lt;
i][\lfloor\frac{kc+c-b-1}{a}\rfloor&lt;
i]\\\\&amp;=nm^2-\sum_{j=0}^{m-1}\sum_{k=0}^{m-1}\max(\lfloor\frac{jc+c-b-1}{a}\rfloor,\lfloor\frac{kc+c-b-1}{a}\rfloor)
\end{aligned}
\]</span></p>
<p>根据对称性不难得到</p>
<p><span class="math display">\[
\begin{aligned}
\operatorname{g}(a,b,c,n)&amp;=nm^2-(2\sum_{j=0}^{m-1}(j+1)\lfloor\frac{jc+c-b-1}{a}\rfloor-\sum_{j=0}^{m-1}\lfloor\frac{jc+c-b-1}{a}\rfloor)\\\\&amp;=nm^2-2\operatorname{h}(c,c-b-1,a,m-1)-\operatorname{f}(c,c-b-1,a,m-1)
\end{aligned}
\]</span></p>
<p>考虑边界条件 <span class="math inline">\(a=0\lor n=0\)</span> 则有
<span class="math inline">\(\operatorname{g}(a,b,c,n)=\operatorname{S}_0(n)\lfloor\frac{b}{c}\rfloor^2\)</span></p>
<p>最后计算 <span class="math inline">\(\operatorname{h}\)</span>
同样类比我们可以得到</p>
<p>首先 <span class="math inline">\(a\ge c\lor b\ge c\)</span> 时</p>
<p><span class="math display">\[
\begin{aligned}
\operatorname{h}(a,b,c,n)&amp;=\sum_{i=0}^ni(\lfloor\frac{(a\operatorname{mod}c)i+(b\operatorname{mod}c)}{c}\rfloor+i\lfloor\frac{a}{c}\rfloor+\lfloor\frac{b}{c}\rfloor)\\\\&amp;=\operatorname{S}_2(n)\lfloor\frac{a}{c}\rfloor+\operatorname{S}_1(n)\lfloor\frac{b}{c}\rfloor+\operatorname{h}(a\operatorname{mod}c,b\operatorname{mod}b,c)   
\end{aligned}
\]</span></p>
<p>其次 <span class="math inline">\(a&lt;c\land b&lt;c\)</span>
时，同理设 <span class="math inline">\(m=\lfloor\frac{an+b}{c}\rfloor\)</span> <span class="math display">\[
\begin{aligned}
\operatorname{h}(a,b,c,n)&amp;=\sum_{i=0}^ni\sum_{j=1}^m[j\le\lfloor\frac{ai+b}{c}\rfloor]\\\\&amp;=\sum_{j=0}^{m-1}\sum_{i=0}^ni[\lfloor\frac{jc+c-b-1}{a}\rfloor&lt;i]\\\\&amp;=\operatorname{S_1}(n)m-\sum_{j=0}^{m-1}\frac{1}{2}(\lfloor\frac{jc+c-b-1}{a}\rfloor+\lfloor\frac{jc+c-b-1}{a}\rfloor^2)\\\\&amp;=\operatorname{S_1}(n)m-\frac{1}{2}\operatorname{f}(c,c-b-1,a,m-1)-\frac{1}{2}\operatorname{g}(c,c-b-1,a,m-1)
\end{aligned}
\]</span></p>
<p>最后 <span class="math inline">\(a=0\lor n=0\)</span> 时 <span class="math inline">\(\operatorname{h}=\operatorname{S}_1(n)\lfloor\frac{b}{c}\rfloor\)</span></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> int64;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">int</span> f = <span class="number">1</span>, <span class="keyword">int</span> x = <span class="number">0</span>, <span class="keyword">char</span> ch = <span class="string">&#x27; &#x27;</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">isdigit</span>(ch = getchar())) <span class="keyword">if</span>(ch == <span class="string">&#x27;-&#x27;</span>) f = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch)) x = x*<span class="number">10</span>+ch-<span class="string">&#x27;0&#x27;</span>, ch = getchar();</span><br><span class="line">    <span class="keyword">return</span> f*x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> P = <span class="number">998244353</span>, I2 = P-(P/<span class="number">2</span>), I6 = <span class="number">166374059</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Euclid</span> &#123;</span> <span class="keyword">int</span> f, g, h; &#125;;</span><br><span class="line"><span class="function">Euclid <span class="title">solve</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c, int64 n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    int64 p = a/c%P, q = b/c%P, p2 = p*p%P, q2 = q*q%P, m = n%P; Euclid E, F;</span><br><span class="line">    <span class="keyword">int</span> s0 = m+<span class="number">1</span>, s1 = (m+<span class="number">1</span>)*m%P*I2%P, s2 = (m+<span class="number">1</span>)*I6%P*(<span class="number">2</span>*m+<span class="number">1</span>)%P*m%P;</span><br><span class="line">    <span class="keyword">if</span>(a == <span class="number">0</span>||n == <span class="number">0</span>) E.f = s0*q%P, E.g = s0*q2%P, E.h = s1*q%P;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(a &gt;= c||b &gt;= c)</span><br><span class="line">    &#123;</span><br><span class="line">        F = solve(a%c, b%c, c, n);</span><br><span class="line">        E.f = (s1*p+s0*q+F.f)%P;</span><br><span class="line">        E.g = ((s2*p2+<span class="number">2</span>*s1*p%P*q%P+s0*q2)%P+F.g+<span class="number">2</span>*p*F.h%P+<span class="number">2</span>*q*F.f%P)%P;</span><br><span class="line">        E.h = (s2*p+s1*q+F.h)%P;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        m = (a*n+b)/c, n %= P, F = solve(c, c-b<span class="number">-1</span>, a, m<span class="number">-1</span>);</span><br><span class="line">        E.f = (n*m+P-F.f)%P, </span><br><span class="line">        E.g = (n*m%P*m%P-F.f%P<span class="number">-2</span>*F.h%P+P*<span class="number">2</span>)%P,</span><br><span class="line">        E.h = (s1*m%P<span class="number">-1l</span>l*I2*(F.f+F.g)%P+P)%P;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> E;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> t;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    t = read();</span><br><span class="line">    <span class="keyword">while</span>(t--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> n = read(), a = read(), b = read(), c = read(); Euclid E = solve(a, b, c, n);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d %d %d\n&quot;</span>, E.f, E.g, E.h);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>模板</category>
      </categories>
      <tags>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title>20200218模拟赛</title>
    <url>/2020/02/18/20200218%E6%A8%A1%E6%8B%9F%E8%B5%9B/</url>
    <content><![CDATA[<h2 id="jump">Jump</h2>
<h3 id="题目描述">题目描述</h3>
<p>求 <span class="math inline">\(n\)</span> 个点 <span class="math inline">\(m\)</span>
条边的无向图，求可将每个边定向的方案满足最后的图是 <code>DAG</code>
的方案数 <a id="more"></a> ### 题解</p>
<p>设 <span class="math inline">\(f_S\)</span> 为点集为 <span class="math inline">\(S\)</span> 的方案数，枚举入度为 <span class="math inline">\(0\)</span> 的点，可得到</p>
<p><span class="math display">\[
f_S=\sum_{T\subseteq S\land T\ne\emptyset}(-1)^{|T|+1}w_Tf_{S-T}
\]</span></p>
<p>其中 <span class="math inline">\(w_T\)</span> 为点集 <span class="math inline">\(T\)</span>
内不存在相互之间的边是否为真，因为入度为零即 <span class="math inline">\(T\rightarrow S-T\)</span> 的边都被定向方案数为
<span class="math inline">\(1\)</span>，由于入度为零那么相互之间必然不能有边</p>
<p>但是我们考虑到对于一个入度为 <span class="math inline">\(0\)</span>
的集合 <span class="math inline">\(I\)</span>
而言，它的每个子集实际上都把它算了一遍，所以我们要算上容斥系数 <span class="math inline">\((-1)^{|I|+1}\)</span> 具体来说，我们考虑</p>
<p><span class="math display">\[
\sum_{J\subseteq I}a_J=[I\ne\emptyset]
\]</span></p>
<p>用子集反演得到</p>
<p><span class="math display">\[
a_I=\sum_{J\subseteq I}(-1)^{|I-J|}[J\ne\emptyset]
\]</span></p>
<p>化简得</p>
<p><span class="math display">\[
a_I=\sum_{i=1}^{|I|}\binom{|I|}{i}(-1)^{|I|-i}
\]</span></p>
<p>即当 <span class="math inline">\(I\)</span> 不为空时</p>
<p><span class="math display">\[
a_I=(-1)^{|I|+1}
\]</span></p>
<p>然后就是标准的子集卷积，<code>FWT</code> 可以在 <span class="math inline">\(\operatorname{O}(n^22^n)\)</span>
的解决，注意取模的常数即可</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> int64;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">int</span> f = <span class="number">1</span>, <span class="keyword">int</span> x = <span class="number">0</span>, <span class="keyword">char</span> ch = <span class="string">&#x27; &#x27;</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">isdigit</span>(ch = getchar())) <span class="keyword">if</span>(ch == <span class="string">&#x27;-&#x27;</span>) f = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch)) x = x*<span class="number">10</span>+ch-<span class="string">&#x27;0&#x27;</span>, ch = getchar();</span><br><span class="line">    <span class="keyword">return</span> f*x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e1</span>+<span class="number">5</span>, S = <span class="number">1</span>&lt;&lt;<span class="number">20</span>|<span class="number">5</span>, P = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, e[N], c[S], f[N][S], g[N][S];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> &amp;x, <span class="keyword">int</span> y)</span> </span>&#123; x = x+y&lt;P?x+y:x+y-P; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FWT</span><span class="params">(<span class="keyword">int</span> *A, <span class="keyword">int</span> n, <span class="keyword">int</span> t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> mid = <span class="number">1</span>; mid &lt; n; mid &lt;&lt;= <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>, len = mid&lt;&lt;<span class="number">1</span>; j &lt; n; j += len)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; mid; ++k)</span><br><span class="line">                <span class="keyword">if</span>(!t) add(A[j+k+mid], A[j+k]);</span><br><span class="line">                <span class="keyword">else</span> add(A[j+k+mid], P-A[j+k]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">W</span><span class="params">(<span class="keyword">int</span> s)</span> </span>&#123; <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) <span class="keyword">if</span>((s&gt;&gt;i&amp;<span class="number">1</span>)&amp;&amp;c[e[i]&amp;s]) <span class="keyword">return</span> <span class="number">0</span>; <span class="keyword">return</span> (c[s]&amp;<span class="number">1</span>)?<span class="number">1</span>:P<span class="number">-1</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    freopen(<span class="string">&quot;jump.in&quot;</span>, <span class="string">&quot;r&quot;</span>, <span class="built_in">stdin</span>), freopen(<span class="string">&quot;jump.out&quot;</span>, <span class="string">&quot;w&quot;</span>, <span class="built_in">stdout</span>);</span><br><span class="line">    n = read(), m = read();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> x = read()<span class="number">-1</span>, y = read()<span class="number">-1</span>;</span><br><span class="line">        e[x] |= <span class="number">1</span>&lt;&lt;y, e[y] |= <span class="number">1</span>&lt;&lt;x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> s = <span class="number">1</span>; s &lt; <span class="number">1</span>&lt;&lt;n; ++s) c[s] = c[s&gt;&gt;<span class="number">1</span>]+(s&amp;<span class="number">1</span>), g[c[s]][s] = W(s);</span><br><span class="line">    f[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>, FWT(f[<span class="number">0</span>], <span class="number">1</span>&lt;&lt;n, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) FWT(g[i], <span class="number">1</span>&lt;&lt;n, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; ++j)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> s = <span class="number">0</span>; s &lt; <span class="number">1</span>&lt;&lt;n; ++s)</span><br><span class="line">                add(f[i][s], <span class="number">1l</span>l*f[j][s]*g[i-j][s]%P);</span><br><span class="line">    FWT(f[n], <span class="number">1</span>&lt;&lt;n, <span class="number">1</span>), <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, f[n][(<span class="number">1</span>&lt;&lt;n)<span class="number">-1</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>组合计数</tag>
        <tag>贪心</tag>
        <tag>容斥</tag>
      </tags>
  </entry>
  <entry>
    <title>[20200215模拟赛] 学习</title>
    <url>/2020/02/16/20200215%E6%A8%A1%E6%8B%9F%E8%B5%9B-%E5%A5%BD%E5%A5%BD/</url>
    <content><![CDATA[<p>一半看到这种代价为 <span class="math inline">\(k\)</span>
次方的形式，且需要转移复杂度的题，都是用第二类斯特林数解决的</p>
<p>第二类斯特林数我们记作 <span class="math inline">\(\begin{Bmatrix} n
\\\\ m \end{Bmatrix}\)</span> 表示将 <span class="math inline">\(n\)</span> 个相互作区分的元素放入 <span class="math inline">\(m\)</span>
个不做区分的集合里，每个集合元素非空的方案数，我们很容易就能有多项式得到一个恒等式</p>
<p>我们不妨计 <span class="math inline">\(\begin{Bmatrix} n \\\\ m
\end{Bmatrix}\times m!\)</span> 的 <code>egf</code> 为 <span class="math inline">\(f\)</span>，即集合做区分的母函数，考虑另一个
<code>egf</code> 为 <span class="math inline">\(g_n\)</span> 满足</p>
<p><span class="math display">\[
g_n=\sum_{i}i^n\frac{x^i}{i!}
\]</span> <a id="more"></a> 很显然 <span class="math inline">\([x^m]g_n\)</span>
的意义就是我们要求做区分的集合可以为空的方案数的生成函数，那么显然有</p>
<p><span class="math display">\[
e^xf=g_n
\]</span></p>
<p>我们就可以得到</p>
<p><span class="math display">\[
m^n=\sum_{i=0}^{\min(n,m)}\binom{m}{i}\begin{Bmatrix} n \\\\ i
\end{Bmatrix}\times i!
\]</span></p>
<p>所以代入这道题要求的式子</p>
<p><span class="math display">\[
\sum_{\sum_{i=1}^mx_i=n}\prod_{i=1}^mx_i^{k_i}
\]</span></p>
<p>化简得到</p>
<p><span class="math display">\[
\sum_{\sum_{i=1}^mx_i=n}\prod_{i=1}^m\sum_{j=0}^{\min(x_i,k_i)}\binom{x_i}{j}\begin{Bmatrix}
k_i \\\\ j \end{Bmatrix}\times j!
\]</span></p>
<p>注意到 <span class="math inline">\(\sum_{i=1}^mk_i\le1\times10^5\)</span>，所以我们考虑求这样的多项式</p>
<p><span class="math display">\[
\sum_{\sum_{i=1}^mx_i=n}\prod_{i=1}^m\sum_{j=0}^{\min(x_i,k_i)}\binom{x_i}{j}\begin{Bmatrix}
k_i \\\\ j \end{Bmatrix}\times j!\ x^j
\]</span></p>
<p>那么我们就可以将最内侧的和式移到外面</p>
<p><span class="math display">\[
\sum_j\sum_{\sum_{i=1}^mc_i=j}\sum_{\sum_{i=1}^mx_i=n}\prod_{i=1}^m\binom{x_i}{c_i}\prod_{i=1}^m\begin{Bmatrix}
k_i \\\\ c_i \end{Bmatrix}\times c_i!\ x^j
\]</span></p>
<p>我们注意到中间的</p>
<p><span class="math display">\[
\sum_{\sum_{i=1}^mx_i=n}\prod_{i=1}^m\binom{x_i}{c_i}
\]</span></p>
<p>实际上是有组合意义的，与隔板法非常类似，我们想象有个长度为 <span class="math inline">\(n+m-1\)</span> 的序列，我们从中选出 <span class="math inline">\(m-1+\sum_{i=1}^mc_i\)</span>
个元素，对于每一种选择方案我们这样构造，先是 <span class="math inline">\(c_1\)</span> 个元素，再算上 <span class="math inline">\(1\)</span>
个隔板依次类推，所以答案的多项式又可以简化为</p>
<p><span class="math display">\[
\sum_j\sum_{\sum_{i=1}^mc_i=j}\binom{n+m-1}{m-1+j}\prod_{i=1}^m\begin{Bmatrix}
k_i \\\\ c_i \end{Bmatrix}\times c_i!\ x^j
\]</span></p>
<p>而实际上我们只需要多项式</p>
<p><span class="math display">\[
\prod_{i=1}^m\sum_{j=0}^{k_i}\begin{Bmatrix} k_i \\\\ j
\end{Bmatrix}\times j!\ x^j
\]</span></p>
<p>再算上相应的系数即可</p>
<p>那么用最开始斯特林数的生成函数的等式</p>
<p>那么为</p>
<p><span class="math display">\[
\prod_{i=1}^m\sum_{j=0}^{k_i}j!\times[x^j]{(}e^{-x}\times g_{k_i}{)}\
x^j
\]</span></p>
<p>实际上后面的 <span class="math inline">\(e^x\)</span> 和 <span class="math inline">\(g_{k_i}\)</span> 只需要求到 <span class="math inline">\(x^{k_i}\)</span> 即可，那么整个式子可以用分治
<code>FFT</code> 优化，用一个类似于线段树的结构求出</p>
<p><span class="math display">\[
\prod_{i=l}^r\sum_{j=0}^{k_i}j!\times[x^j]{(}e^{-x}\times g_{k_i}{)}\
x^j
\]</span></p>
<p>每一层总的项数和为 <span class="math inline">\(S=\sum_{i=1}^mk_i\)</span> 所以复杂度为 <span class="math inline">\(\operatorname{O}(S\log^2S)\)</span></p>
<p>其他类似题目可参照 <a href="https://www.lydsy.com/JudgeOnline/problem.php?id=5093">[BZOJ 5093]
图的价值</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> int64;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">int</span> f = <span class="number">1</span>, <span class="keyword">int</span> x = <span class="number">0</span>, <span class="keyword">char</span> ch = <span class="string">&#x27; &#x27;</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">isdigit</span>(ch = getchar())) <span class="keyword">if</span>(ch == <span class="string">&#x27;-&#x27;</span>) f = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch)) x = x*<span class="number">10</span>+ch-<span class="string">&#x27;0&#x27;</span>, ch = getchar();</span><br><span class="line">    <span class="keyword">return</span> f*x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">8e5</span>+<span class="number">5</span>, M = <span class="number">1e7</span>+<span class="number">5</span>+<span class="number">1e5</span>, P = <span class="number">998244353</span>;</span><br><span class="line">int64 w[<span class="number">2</span>][N], fac[M], ifac[M]; <span class="keyword">int</span> lim, rev[N];</span><br><span class="line"><span class="function">int64 <span class="title">qpow</span><span class="params">(int64 a, <span class="keyword">int</span> b)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    int64 ret = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>( ; b; b &gt;&gt;= <span class="number">1</span>, a = a*a%P) <span class="keyword">if</span>(b&amp;<span class="number">1</span>) ret = ret*a%P;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">prepare</span><span class="params">(<span class="keyword">int</span> ti)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(lim = <span class="number">1</span>; lim &lt;= ti; lim &lt;&lt;= <span class="number">1</span>);</span><br><span class="line">    int64 g = qpow(<span class="number">3</span>, (P<span class="number">-1</span>)/lim);</span><br><span class="line">    w[<span class="number">0</span>][<span class="number">0</span>] = w[<span class="number">1</span>][<span class="number">0</span>] = w[<span class="number">0</span>][lim] = w[<span class="number">1</span>][lim] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>, j = lim&gt;&gt;<span class="number">1</span>; i &lt; lim; ++i) </span><br><span class="line">    &#123;</span><br><span class="line">        w[<span class="number">0</span>][i] = w[<span class="number">1</span>][lim-i] = w[<span class="number">0</span>][i<span class="number">-1</span>]*g%P, rev[i] = j;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = lim&gt;&gt;<span class="number">1</span>; (j ^= k) &lt; k; k &gt;&gt;= <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Poly</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; A;</span><br><span class="line">    <span class="keyword">int</span>&amp; <span class="keyword">operator</span> [] (<span class="keyword">const</span> <span class="keyword">int</span> i) &#123; <span class="keyword">return</span> A[i]; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> ti)</span> </span>&#123; A.resize(ti+<span class="number">1</span>); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">ti</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> A.size()<span class="number">-1</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">NTT</span><span class="params">(<span class="keyword">int</span> t)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!t) A.resize(lim);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lim; ++i) <span class="keyword">if</span>(rev[i] &gt; i) swap(A[rev[i]], A[i]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> mid = <span class="number">1</span>; mid &lt; lim; mid &lt;&lt;= <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> len = mid&lt;&lt;<span class="number">1</span>, j = <span class="number">0</span>; j &lt; lim; j += len)</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>, p = <span class="number">0</span>, q = lim/len; k &lt; mid; ++k, p += q)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">int</span> x = A[j+k], y = A[j+k+mid]*w[t][p]%P;</span><br><span class="line">                    A[j+k] = (x+y)%P, A[j+k+mid] = (x-y+P)%P;</span><br><span class="line">                &#125;  </span><br><span class="line">        <span class="keyword">if</span>(!t) <span class="keyword">return</span>; int64 v = qpow(lim, P<span class="number">-2</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lim; ++i) A[i] = A[i]*v%P;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">friend</span> Poly <span class="keyword">operator</span> * (Poly A, Poly B)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> n = A.ti(), m = B.ti(); prepare(n+m), A.NTT(<span class="number">0</span>), B.NTT(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lim; ++i) A[i] = <span class="number">1l</span>l*A[i]*B[i]%P; </span><br><span class="line">        <span class="keyword">return</span> A.NTT(<span class="number">1</span>), A.<span class="built_in">set</span>(n+m), A;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;F;</span><br><span class="line"><span class="keyword">int</span> n, m, s, a[N], ans;</span><br><span class="line"><span class="function">int64 <span class="title">C</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123; <span class="keyword">return</span> <span class="number">0</span> &lt;= m&amp;&amp;m &lt;= n?fac[n]*ifac[m]%P*ifac[n-m]%P:<span class="number">0</span>; &#125;</span><br><span class="line"><span class="function">Poly <span class="title">solve</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l == r) </span><br><span class="line">    &#123;</span><br><span class="line">        Poly A, B; A.<span class="built_in">set</span>(a[l]), B.<span class="built_in">set</span>(a[l]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= a[l]; ++i) A[i] = i&amp;<span class="number">1</span>?P-ifac[i]:ifac[i], B[i] = qpow(i, a[l])*ifac[i]%P;</span><br><span class="line">        A = A*B, A.<span class="built_in">set</span>(a[l]); <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= a[l]; ++i) A[i] = A[i]*fac[i]%P; <span class="keyword">return</span> A;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (l+r)&gt;&gt;<span class="number">1</span>; <span class="keyword">return</span> solve(l, mid)*solve(mid+<span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    freopen(<span class="string">&quot;b.in&quot;</span>, <span class="string">&quot;r&quot;</span>, <span class="built_in">stdin</span>), freopen(<span class="string">&quot;b.out&quot;</span>, <span class="string">&quot;w&quot;</span>, <span class="built_in">stdout</span>);</span><br><span class="line">    m = read(), n = read(), fac[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) a[i] = read(), s += a[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n+m<span class="number">-1</span>; ++i) fac[i] = fac[i<span class="number">-1</span>]*i%P;</span><br><span class="line">    ifac[n+m<span class="number">-1</span>] = qpow(fac[n+m<span class="number">-1</span>], P<span class="number">-2</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = n+m<span class="number">-1</span>; i; --i) ifac[i<span class="number">-1</span>] = ifac[i]*i%P;</span><br><span class="line">    F = solve(<span class="number">1</span>, m); <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= s; ++i) ans = (ans+C(n+m<span class="number">-1</span>, m<span class="number">-1</span>+i)*F[i]%P)%P;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>组合计数</tag>
        <tag>生成函数</tag>
      </tags>
  </entry>
  <entry>
    <title>[LGR-068]传染病研究</title>
    <url>/2020/02/07/LGR-068-%E4%BC%A0%E6%9F%93%E7%97%85%E7%A0%94%E7%A9%B6/</url>
    <content><![CDATA[<p>这道题做法很常规，考场上rush失败了QwQ</p>
<p>我们设 <span class="math inline">\(d_{n,k}=\sum[d|n^k]\)</span>
那么显然对于 <span class="math inline">\(n\)</span> 唯一分解后，<span class="math inline">\(d_{n,k}=\prod_{i=1}^n(kc_i+1)\)</span>，<span class="math inline">\(c_i\)</span> 质因数的质数 <a id="more"></a>
那么我们最后要求的答案必定为 <span class="math inline">\(k\)</span>
的多项式，且多项式的次数不超过 <span class="math inline">\(8\)</span>，因为 <span class="math inline">\(2\times3\times5\times7\times11\times13\times17\times19\times23&gt;1\times10^7\)</span></p>
<p>所以我们取 <span class="math inline">\(k\in[0,8]\)</span>
的值，其余值用拉格朗日插值插出来即可，对于前者，我们可以记录 <span class="math inline">\(d_{n,k}\)</span>
的值和最小质因数的指数用线筛来维护，对于后者，可以 <span class="math inline">\(O(64logP)\)</span> 也可以 <span class="math inline">\(O(8)\)</span></p>
<p>常数很大</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> int64;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">int</span> f = <span class="number">1</span>, <span class="keyword">int</span> x = <span class="number">0</span>, <span class="keyword">char</span> ch = <span class="string">&#x27; &#x27;</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">isdigit</span>(ch = getchar())) <span class="keyword">if</span>(ch == <span class="string">&#x27;-&#x27;</span>) f = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch)) x = x*<span class="number">10</span>+ch-<span class="string">&#x27;0&#x27;</span>, ch = getchar();</span><br><span class="line">    <span class="keyword">return</span> f*x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e7</span>+<span class="number">5</span>, P = <span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">int</span> t, n, k, py[N][<span class="number">9</span>], d[N], vis[N], p[N], num[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tot = <span class="number">0</span>; py[<span class="number">1</span>][k] = d[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!vis[i]) p[++tot] = i, d[i]= k+<span class="number">1</span>, num[i] = k;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= tot&amp;&amp;i*p[j] &lt;= n; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            vis[i*p[j]] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(i%p[j] == <span class="number">0</span>) d[i*p[j]] = d[i]/(num[i]+<span class="number">1</span>)*(num[i]+k+<span class="number">1</span>), num[i*p[j]] = num[i]+k, j = tot;</span><br><span class="line">            <span class="keyword">else</span> d[i*p[j]] = d[i]*d[p[j]], num[i*p[j]] = k;</span><br><span class="line">        &#125;</span><br><span class="line">        py[i][k] = (py[i<span class="number">-1</span>][k]+d[i])%P, vis[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">int64 <span class="title">inv</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123; <span class="keyword">return</span> i == <span class="number">1</span>?<span class="number">1</span>:P-(P/i)*inv(P%i)%P; &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lagrange</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> *y, <span class="keyword">int</span> xi)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; ++i) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> s1 = <span class="number">1</span>, s2 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= n; ++j)</span><br><span class="line">            <span class="keyword">if</span> (i != j) </span><br><span class="line">            &#123;</span><br><span class="line">                s1 = <span class="number">1l</span>l*s1*(xi-j)%P;</span><br><span class="line">                s2 = <span class="number">1l</span>l*s2*(i-j)%P;</span><br><span class="line">            &#125;</span><br><span class="line">        ans = (<span class="number">1l</span>l*ans+<span class="number">1l</span>l*y[i]*s1%P*inv(s2)%P)%P;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (ans+P)%P;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n = <span class="number">1e7</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) py[i][<span class="number">0</span>] = i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">8</span>; ++i) solve(n, i);</span><br><span class="line">    t = read();</span><br><span class="line">    <span class="keyword">while</span>(t--)</span><br><span class="line">    &#123;</span><br><span class="line">        n = read(), k = read();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, lagrange(<span class="number">8</span>, py[n], k));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>数论</tag>
        <tag>多项式</tag>
      </tags>
  </entry>
  <entry>
    <title>[CF1091E]New Year and the Acquaintance Estimation题解</title>
    <url>/2020/01/31/CF1091E-New-Year-and-the-Acquaintance-Estimation%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<p>简单无向图的可视化，根据 <code>Erdős–Gallai</code> 定理将度数序列
<span class="math inline">\(d\)</span> 排序可得，若满足</p>
<p><span class="math display">\[
\forall k\in[1,n],\sum_{i=1}^kd_k\le
k\times(k-1)+\sum_{i=k+1}^n\min(k,d_i)
\]</span> <a id="more"></a> 且</p>
<p><span class="math display">\[
\sum_{i=1}^nd_i\equiv0\ mod\ 2
\]</span></p>
<p>则序列可图，感性理解就是我们不断满足构成部分完全图的上界</p>
<p>稍加分析我们也可以发现，最后的答案是一个连续的序列简单证明就是若
<span class="math inline">\(d_n=i\)</span> 和 <span class="math inline">\(d_n=j\)</span>
都是可图的，那么我们可以删去两边增加一条边的方法递推得到中间的合法值</p>
<p>所以这道题再套上一个二分即可</p>
<p>二分是二分一个区间的左右端点，因此我们需要分清什么时候偏大，什么时候偏小</p>
<p>若 <span class="math inline">\(i\)</span> 时不满足条件，当 <span class="math inline">\(mid\ge d_i\)</span> 时，<span class="math inline">\(mid\)</span> 偏大，否则偏小</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> int64;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">int</span> f = <span class="number">1</span>, <span class="keyword">int</span> x = <span class="number">0</span>, <span class="keyword">char</span> ch = <span class="string">&#x27; &#x27;</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">isdigit</span>(ch = getchar())) <span class="keyword">if</span>(ch == <span class="string">&#x27;-&#x27;</span>) f = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch)) x = x*<span class="number">10</span>+ch-<span class="string">&#x27;0&#x27;</span>, ch = getchar();</span><br><span class="line">    <span class="keyword">return</span> f*x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">5e5</span>+<span class="number">5</span>; </span><br><span class="line"><span class="keyword">int</span> n, p, ansl, ansr, b[N], tax[N], a[N], l, r; int64 s[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">valid</span><span class="params">(<span class="keyword">int</span> mid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) tax[i] = <span class="number">0</span>; ++tax[mid]; </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) ++tax[b[i]];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = n<span class="number">-1</span>, j = <span class="number">0</span>; ~i; --i) </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= tax[i]; ++k)</span><br><span class="line">            a[++j] = i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) s[i] = s[i<span class="number">-1</span>]+a[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>, j = n+<span class="number">1</span>; i &lt; n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(j = max(i+<span class="number">1</span>, j); j &gt; i+<span class="number">1</span>&amp;&amp;a[j<span class="number">-1</span>] &lt;= i; --j);</span><br><span class="line">        <span class="keyword">if</span>(s[i] &gt; (j<span class="number">-1l</span>l-i)*i+s[n]-s[j<span class="number">-1</span>]+i*(i<span class="number">-1l</span>l)) <span class="keyword">return</span> a[i]&lt;=mid?<span class="number">-1</span>:<span class="number">1</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n = read()+<span class="number">1</span>; <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) b[i] = read(), p ^= b[i]&amp;<span class="number">1</span>;</span><br><span class="line">    l = <span class="number">0</span>, r = (n<span class="number">-1</span>-p)&gt;&gt;<span class="number">1</span>, ansr = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(l &lt;= r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(valid(mid&lt;&lt;<span class="number">1</span>|p) == <span class="number">-1</span>) r = mid<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">else</span> l = mid+<span class="number">1</span>, ansr = mid;</span><br><span class="line">    &#125;</span><br><span class="line">    l = <span class="number">0</span>, r = (n<span class="number">-1</span>-p)&gt;&gt;<span class="number">1</span>, ansl = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(l &lt;= r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(valid(mid&lt;&lt;<span class="number">1</span>|p) == <span class="number">1</span>) l = mid+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> r = mid<span class="number">-1</span>, ansl = mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(ansl &gt; ansr||ansl == <span class="number">-1</span>||ansr == <span class="number">-1</span>) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>), <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = ansl; i &lt;= ansr; ++i) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, i&lt;&lt;<span class="number">1</span>|p); <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title>[[CSGRound3]仙人掌]题解</title>
    <url>/2020/01/30/CSGRound3-%E4%BB%99%E4%BA%BA%E6%8E%8C-%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<p>这道题考完之后一直也没题解，蒟蒻就自己找了些资料，一知半解地写了这道题，主要参考
<a href="https://neerc.ifmo.ru/archive/2019/nerc-2019-tutorial.pdf">NERC2019
C.Cactus Revenge</a> 和 <a href="http://www.secmem.org/blog/2019/12/15/cactus-realization/">Cactus
graph realization of degree
sequence</a>，接下来的事情也主要复读这两个资料的</p>
<p>我们在之后的讨论中设度数序列为 <span class="math inline">\(d\)</span>，图的点集大小为 <span class="math inline">\(n\)</span>，边集大小为 <span class="math inline">\(m\)</span>，首先有个很明显的性质即 <a id="more"></a>
<span class="math display">\[
\sum_{i=1}^nd_i=2m
\]</span></p>
<p>首先考虑树的情况，树的情况很好猜，一个度数序能构成树的充要条件即</p>
<p><span class="math display">\[
\sum_{i=1}^nd_i=2(n-1)\land \forall i,d_i\ge1
\]</span></p>
<p>考虑归纳证明，首先 <span class="math inline">\(n=2\)</span> 是 <span class="math inline">\(d_1=d_2=1\)</span>
两者互相连边即可，结论显然成立</p>
<p>对于 <span class="math inline">\(n&gt;2\)</span>，若 <span class="math inline">\(\forall i,d_i\ge2\)</span>，则 <span class="math inline">\(\sum_{i=1}^nd_i\ge2n\)</span> 所以一定有 j，满足
<span class="math inline">\(d_j=1\)</span>，我们将 <span class="math inline">\(j\)</span> 与剩下任意一个 <span class="math inline">\(k,d_k\ge2\)</span> 连边，将 <span class="math inline">\(d_j\)</span> 和 <span class="math inline">\(d_k\)</span> 减 <span class="math inline">\(1\)</span>，将 <span class="math inline">\(j\)</span> 删去，得到新的度数序 <span class="math inline">\(d&#39;\)</span>，那么由于 <span class="math inline">\(d&#39;\)</span> 是可以构成树的，所以 <span class="math inline">\(d\)</span> 也可以</p>
<p>接着我们考虑边仙人掌的情况</p>
<p>我们任取图的一个生成树，每条非树边都仅代表一个环，所以环数 <span class="math inline">\(c\)</span> 显然满足 <span class="math display">\[
    c=m-(n-1)\in[0,\lfloor\frac{n-1}{2}\rfloor]
\]</span></p>
<p>若度数都为偶数，分两种情况，都为 <span class="math inline">\(2\)</span>
时，我们只需要构成一个大环即可，否则我们其中一定存在相异的 <span class="math inline">\(u\)</span> 和 <span class="math inline">\(v\)</span> 满足 <span class="math inline">\(d_u=d_v=2\)</span>（可以用树的反证法说明)，我们令
<span class="math inline">\(u\)</span> 和 <span class="math inline">\(v\)</span> 与另一个 <span class="math inline">\(w,d_w\ge4\)</span> 构成一个三元环，与树同理构造出
<span class="math inline">\(d&#39;\)</span>，这是 <span class="math inline">\(d&#39;\)</span> 满足 <span class="math inline">\(c-1\le\lfloor\frac{n-3}{2}\rfloor\)</span>，于是可以归纳证明</p>
<p>若度数不全为偶数，则显然奇数个数为偶数并且我们需要找到更强的约束条件，考虑割边的个数为
<span class="math inline">\(b\)</span>，奇数个数为 <span class="math inline">\(o\)</span>，叶子个数为 <span class="math inline">\(l\)</span>，对于 <span class="math inline">\(b\)</span>，满足 <span class="math inline">\(b\ge\max(\frac{o}{2},l)\)</span>，所以对 <span class="math inline">\(c\)</span> 有更强的约束为</p>
<p><span class="math display">\[
c\le\lfloor\frac{n-1-\max(\frac{o}{2},l)}{2}\rfloor\le\lfloor\frac{n-1-b}{2}\rfloor
\]</span></p>
<p>首先对于一些平凡的情况，若序列满足上述条件即可构造出仙人掌，对于剩下的分两种情况考虑当
<span class="math inline">\(l\ge1\)</span> 时我们从度数最大的点 <span class="math inline">\(u\)</span> 向叶子 <span class="math inline">\(v\)</span> 连边，构造出 <span class="math inline">\(d&#39;\)</span> 这时 <span class="math inline">\(d&#39;\)</span> 满足 <span class="math inline">\(c\le\lfloor\frac{n-1-\max(\frac{o-1-k}{2},l-1)}{2}\rfloor,k\le1\)</span>
成立，我们从度数最大的点 <span class="math inline">\(u\)</span>
向度数最小的 <span class="math inline">\(v\)</span> 和 <span class="math inline">\(w\)</span> 构成三元环，与上面同理可证成立</p>
<p>所以我们就得到判断度数序列是否可以构成仙人掌的条件</p>
<p>计数就很简单了，我们考虑枚举 <span class="math inline">\(o\)</span>
和 <span class="math inline">\(l\)</span>，用组合数计算出不定方程 <span class="math display">\[
\sum_{i=1}^nd_i=2m
\]</span></p>
<p>其中满足有 <span class="math inline">\(o-l\)</span> 个 <span class="math inline">\(d_i\)</span> 不小于 <span class="math inline">\(3\)</span> 且为奇数，<span class="math inline">\(l\)</span> 个 <span class="math inline">\(d_i\)</span> 为 <span class="math inline">\(1\)</span>，<span class="math inline">\(n-o\)</span> 个 <span class="math inline">\(d_i\)</span> 为不小于 <span class="math inline">\(2\)</span> 且为偶数的解的方案数</p>
<p>这里我不太会用隔板法算，所以用生成函数暴力算很显然我们要求出的就是</p>
<p><span class="math display">\[
[x^{2m-l}]\binom{n}{o}\binom{o}{l}(\frac{1}{1-x^2}-1)^{n-o}(\frac{x}{1-x^2}-x)^{o-l}
\]</span></p>
<p>将后面的多项式展开就不多赘述了</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> int64;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">int</span> f = <span class="number">1</span>, <span class="keyword">int</span> x = <span class="number">0</span>, <span class="keyword">char</span> ch = <span class="string">&#x27; &#x27;</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">isdigit</span>(ch = getchar())) <span class="keyword">if</span>(ch == <span class="string">&#x27;-&#x27;</span>) f = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch)) x = x*<span class="number">10</span>+ch-<span class="string">&#x27;0&#x27;</span>, ch = getchar();</span><br><span class="line">    <span class="keyword">return</span> f*x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">6e3</span>+<span class="number">5</span>, P = <span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">int</span> t, n, m, c; int64 C[N][N], ans;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>, n = <span class="number">6e3</span>; i &lt;= n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        C[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; ++j)</span><br><span class="line">            C[i][j] = (C[i<span class="number">-1</span>][j<span class="number">-1</span>]+C[i<span class="number">-1</span>][j])%P;</span><br><span class="line">    &#125;</span><br><span class="line">    t = read();</span><br><span class="line">    <span class="keyword">while</span>(t--)</span><br><span class="line">    &#123;</span><br><span class="line">        n = read(), m = read(), c = m-(n<span class="number">-1</span>), ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="number">0</span> &lt;= c&amp;&amp;c &lt;= (n<span class="number">-1</span>)/<span class="number">2</span>) </span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> o = <span class="number">0</span>; o &lt;= n; o += <span class="number">2</span>)</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> l = <span class="number">0</span>; l &lt;= o; ++l)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">int</span> b = max(o/<span class="number">2</span>, l), i = (<span class="number">2</span>*m<span class="number">-2</span>*n-o+<span class="number">2</span>*l)/<span class="number">2</span>;</span><br><span class="line">                    <span class="keyword">if</span>(c &lt;= (n<span class="number">-1</span>-b)/<span class="number">2</span>) ans = (ans+C[n][o]*C[o][l]%P*C[n-l+i<span class="number">-1</span>][i]%P)%P;</span><br><span class="line">                &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这道题应该属于图的可视化问题，这类问题常用这样的归纳证明，欲了解更多可以参照<a href="https://en.wikipedia.org/wiki/Graph_realization_problem">Graph
realization problem</a> 或这道题 <a href="https://www.luogu.com.cn/problem/CF1091E">CF1091E</a></p>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>组合计数</tag>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title>一辈子都学不会的图论技巧</title>
    <url>/2019/11/08/%E4%B8%80%E8%BE%88%E5%AD%90%E9%83%BD%E5%AD%A6%E4%B8%8D%E4%BC%9A%E7%9A%84%E5%9B%BE%E8%AE%BA%E6%8A%80%E5%B7%A7/</url>
    <content><![CDATA[<h2 id="树的直径">树的直径</h2>
<p>树的直径具有许多优美的性质，我们将在以下几题探讨</p>
<h3 id="最长性与对称性">最长性与对称性</h3>
<p>树上一个点与其对应最长简单路径的另一端点一定是直径的端点，即直径的最长性，除此之外，直径上会存在中点，具有很好的对称性
<a id="more"></a> #### <a href="https://www.luogu.org/problem/P2491">[SDOI2011]消防</a></p>
<p>我们找出树的直径 <span class="math inline">\(\Gamma\)</span>
则根据题意列出式子</p>
<p><span class="math display">\[
\min\lbrace \max_{p_{u,v}\subseteq\Gamma,d_{u,v}\ge s}\lbrace \max_{i\in
p}\lbrace f_i\rbrace,d_{u,\Gamma},d_{v,\Gamma}\rbrace\rbrace
\]</span></p>
<p>其中 <span class="math inline">\(f_i\)</span>
表示不经过树的直径的最长长度，根据树的直径的最长性 <span class="math display">\[
\max_{i\notin p,i\in\Gamma}\lbrace f_i\rbrace\le\min\lbrace
d_{u,\Gamma},d_{v,\Gamma}\rbrace
\]</span></p>
<p>所以中间部分可以修改上界，那么这道题直接用双指针维护即可</p>
<h4 id="agc005ctree-restoring"><a href="https://www.luogu.org/problem/AT2061">[AGC005C]Tree
Restoring</a></h4>
<p>最大值一定为直径，最小值一定为树的半径，根据直径奇偶性就可以确定最小值个数，再根据非半径路径的对称性判断即可</p>
<h4 id="agc001cshorten-diameter"><a href="https://www.luogu.org/problem/AT1981">[AGC001C]Shorten
Diameter</a></h4>
<p>枚举树的直径的中心，贪心构造即可</p>
<h3 id="直径的合并">直径的合并</h3>
<p>当合并两个联通块是，新的树的直径一定产生于原先两个树的直径的四个端点之中，当未指定合并方式时就可以通过控制连接点来构造我们想要的直径</p>
<h4 id="雅礼集训-2017-day5远行"><a href="https://loj.ac/problem/6038">[雅礼集训 2017 Day5]远行</a></h4>
<p>动态维护树的直径的裸题，用 <code>LCT</code> 维护树上距离即可，不会
<code>LCT</code> 可以考虑启发式合并与倍增</p>
<h4 id="tjoi2017城市"><a href="https://www.luogu.org/problem/P3761">[TJOI2017]城市</a></h4>
<p>枚举断边，再重新连接两个直径的中点即可求出新树中的最小半径</p>
<h3 id="多直径">多直径</h3>
<p>这类问题通常会要求我们求出若干条边不相交或点不相交的链使得和最大</p>
<h4 id="apio2010巡逻"><a href="https://www.luogu.org/problem/P3629">[APIO2010]巡逻</a></h4>
<p>这道题很明显要找出两条不相交的链使得其和最大，由于边权都为 <span class="math inline">\(1\)</span>
所以我们可以先求一边树的直径，再将直径上的边赋值为 <span class="math inline">\(-1\)</span>
再求一遍树的直径就可以处理出合法的贡献</p>
<h4 id="nod树的双直径"><a href="http://www.51nod.com/Challenge/Problem.html#problemId=1812">[51NOD]树的双直径</a></h4>
<p>这道题依旧是两条直径，但边权为整数，所以考虑改进求树的直径的
<code>DP</code>，维护每个点子树内外的最长链，最长直链，次长直链换根
<code>DP</code>
即可，注意让乘积最大，且边权有负数，所以还要维护最小值和次小值</p>
<h4 id="八省联考2018林克卡特树lct"><a href="https://www.luogu.org/problem/P4383">[八省联考2018]林克卡特树lct</a></h4>
<p>思考题，不作要求，要选出 <span class="math inline">\(k\)</span>
条直径，只能考虑直径的形态并用背包维护了，最后能发现凸性，用
<code>WQS</code> 二分即可</p>
<h2 id="树的重心">树的重心</h2>
<p>树的重心有很多好看的特性，我们将在以下几题探讨</p>
<h3 id="折半性与极少性">折半性与极少性</h3>
<p>根据树的重心定义，树的重心是树上所有点在其被出去后使剩下联通块最大值最小的点，很明显这个最大值最小值小于整棵树大小的一半，点分治就是利用这一原理简化复杂度</p>
<p>并且，树的重心很少，最多不超过 <span class="math inline">\(2\)</span>
个，无根树哈希以及无根无编号树的计数问题就利用了这个特性</p>
<h4 id="agc018tree-and-hamilton-path"><a href="https://www.luogu.org/problem/AT2673">[AGC018]Tree and Hamilton
Path</a></h4>
<p>根据贪心问题的套路，我们盲猜一波答案的上界，单独考虑每条边的贡献，我们让每条边利用充分，则贡献为</p>
<p><span class="math display">\[
\min(x,\ y)\times w
\]</span></p>
<p>其中 <span class="math inline">\(x\)</span> 和 <span class="math inline">\(y\)</span>
是断掉这条边后树变成的两个联通块的大小</p>
<p>考虑什么时候答案可以达到上界，我们注意到当树存在双重心时，我们让两个重心连边断开后剩下的两个联通块互相配对即可达到上界，这启发我们找到合适的边或点断开，使剩下联通块配对即可，根据集合配对的结论，配对集合的最大值不超过总大小的一半即可完成配对，所以我们找到重心即可，注意这是路径，所以最后需要减去一条边的贡献</p>
<h4 id="cf1182dcomplete-mirror"><a href="https://www.luogu.org/problem/CF1182D">[CF1182D]Complete
Mirror</a></h4>
<p>可以发现若选择的点度数大于 <span class="math inline">\(2\)</span>
必定是树的重心，否则以这个点为根时，各个子树大小都不平均，要么一定位于重心所在的长链上，画图很好证明，所以重心也暗含对称性</p>
<p>我们也可用同样具有对称性的直径或树哈希解决此问题，细节留给读者思考</p>
<h3 id="带权重心">带权重心</h3>
<p>我们还可以定义重心为满足所有点到它距离和最小的点为树的重心，观察换根
<code>DP</code>
方程的转移，可以很明显发现这个定义与之前定义等价，当存在边权或点权，我们将重心扩展为带权重心</p>
<h4 id="zjoi2015幻想乡战略游戏"><a href="https://www.luogu.org/problem/P3345">[ZJOI2015]幻想乡战略游戏</a></h4>
<p>思考题<del>由于没有找到在联赛范围的题</del>，动态维护带权重心，利用线段树在点分树上二分即可</p>
<h3 id="重心的移动">重心的移动</h3>
<p>当两个联通块合并时，树的重心一定位于原来两个联通块重心的连线上，结合带权重心的定义理解，若可以往外移动，则在未合并前就已经移动了</p>
<h4 id="lg4299-首都"><a href="https://www.luogu.org/problem/P4299">[LG4299] 首都</a></h4>
<p>合并时用 <code>LCT</code> 抽出连线，在 <code>Splay</code>
上二分移动即可</p>
<h2 id="树的遍历序">树的遍历序</h2>
<p>树的遍历序可以转化树上问题为序列上的偏序问题</p>
<h3 id="dfs-序">DFS 序</h3>
<p><code>DFS</code>
序最直接的利用应该就是重链剖分中把树转化为序列问题，和虚树中的利用，其中对应的实质是
<code>DFS</code>
序使子树连续，以及它的子序列所对应的联通块极大的性质</p>
<h4 id="sdoi2015寻宝游戏"><a href="https://www.luogu.org/problem/P3320">[SDOI2015]寻宝游戏</a></h4>
<p>用 <code>set</code> 动态维护 <code>DFS</code>
序子序列，就可以维护极大联通块</p>
<h4 id="cf1225ftree-factory"><a href="https://www.luogu.org/problem/CF1225F">[CF1225F]Tree
Factory</a></h4>
<p>很明显最后要求的就是树的一个 <code>DFS</code> 序，那么
<code>dfn</code> 中的第 <span class="math inline">\(i\)</span>
个点贡献为 <span class="math inline">\(d_{dfn_{i-1}}-d_{fa_{dfn_i}}\)</span>
显然最后走长链即可</p>
<h3 id="bfs-序">BFS 序</h3>
<p><code>BFS</code>
序不经常使用，最基础的一个性质是相邻两个节点要么为兄弟要么为父亲，且位于深度之差小于
<span class="math inline">\(1\)</span>，可以在某些题优化做法</p>
<h4 id="cf893fsubtree-minimum-query"><a href="https://www.luogu.org/problem/CF893F">[CF893F]Subtree Minimum
Query</a></h4>
<p>以 <code>BFS</code> 序为时间做可持久化线段树，维护 <code>DFS</code>
序信息，支持询问区间最值即可</p>
<h2 id="树上统计信息">树上统计信息</h2>
<p>对具有区间可减性的树上信息可以通过前缀和和差分高效维护，也可以通过考虑每条边或点的贡献高效统计</p>
<h3 id="差分">差分</h3>
<p>我们类比序列的差分，可以看出树也可以差分性质，树链<code>(u, v)</code>
的点权加即在 <code>u</code> 和
<code>v</code>添加贡献，<code>fa[lca(u, v)]</code> 和
<code>lca(u, v)</code> 减去贡献</p>
<h4 id="lgp1600天天爱跑步"><a href="https://www.luogu.org/problem/P1600">[LGP1600]天天爱跑步</a></h4>
<p>考虑每个点会被哪些路径产生贡献，显然对于路径 <code>(u, v)</code>
上行部分满足 <span class="math inline">\(d_u=d_i+w_i\)</span> 下行满足
<span class="math inline">\(d_{u,v}-d_v=w_i-d_i\)</span>
会产生贡献，树上差分用桶统计即可</p>
<h3 id="前缀和">前缀和</h3>
<p>类比序列的前缀和，我们也可以维护每个点到根的信息和</p>
<h4 id="agc014unplanned-queries"><a href="https://www.luogu.org/problem/AT2374">[AGC014]Unplanned
Queries</a></h4>
<p>很明显我们只关注奇偶性，对每条链的统计实际上通过反向考虑前缀和等价于链的每个端点到根的奇偶性，在这个意义下树的形态就不重要了，所以随便找一种判断即可</p>
<h3 id="贡献单独考虑">贡献单独考虑</h3>
<h4 id="haoi2015树上染色"><a href="https://www.luogu.org/problem/P3177">[HAOI2015]树上染色</a></h4>
<p>题干中要求统计树上点对两两之间的距离所以很套路的就可以考虑每条边的贡献为两边黑点和白点数量的乘积，直接树上背包就好了</p>
<h4 id="haoi2018苹果树"><a href="https://www.luogu.org/problem/P4492">[HAOI2018]苹果树</a></h4>
<p>同样是是求距离之和，所以我们只需要把大小作为状态转移即可，和这道题类似的计数题还有
<a href="https://www.luogu.org/problem/CF855G">[CF855G]Harry Vs
Voldemort</a> <del>需要大力分类讨论</del> 和 <a href="https://www.luogu.org/problem/P5206">[WC2019]数树</a>
<del>需要大力推式子</del></p>
<h4 id="agc005many-easy-problems"><a href="https://www.luogu.org/problem/AT2064">[AGC005]Many Easy
Problems</a></h4>
<p>求大小之和，很自然地想到每个点会被多少个联通块算到，不妨设联通块大小为
<span class="math inline">\(k\)</span>，删去一个点后剩下地联通块集合为
<span class="math inline">\(S\)</span> 则贡献为</p>
<p><span class="math display">\[
\binom{n}{k}-\sum_{s\in S}\binom{s}{k}
\]</span></p>
<p>直接统计复杂度为 <span class="math inline">\(O(n^2)\)</span>
所以还要搞一下答案生成函数，用 <code>NTT</code> 即可解决</p>
<h2 id="图论建模">图论建模</h2>
<p>一些人类智慧题可以通过建立图论模型解决</p>
<h3 id="欧拉路">欧拉路</h3>
<p>感觉自己就没做出来过欧拉路的题</p>
<h4 id="agc017jigsaw"><a href="https://www.luogu.org/problem/AT2668">[AGC017]Jigsaw</a></h4>
<p>当我们发现以每个积木作为点建图很难搞，考虑把积木当作边，对于每个积木而言左边若
<span class="math inline">\(c=0\)</span> 则当作编号为 <span class="math inline">\(a\)</span> 的点，否则为 <span class="math inline">\(-c\)</span>，右边而言若 <span class="math inline">\(d=0\)</span> 则当作编号为 <span class="math inline">\(-b\)</span> 的点，否则为 <span class="math inline">\(d\)</span>，积木本身作为连接两点的边，现在题目等价于求若干条不边相交的路径覆盖图的问题，且对于每条路径而言必须从编号为正的路径开始，编号为负的路径结束，所以编号为正的路径的出度必须大于等于入度，标号为负的路径入度必须大于出度，且对于每一个联通块而言入度和出度不能相等</p>
<h3 id="二分图">二分图</h3>
<p>这里重点强调的是二分的匹配问题</p>
<h4 id="agc018two-trees"><a href="https://www.luogu.org/problem/AT2675">[AGC018]Two Trees</a></h4>
<p>首先一个很明显的事实是，对于两棵树而言，若两个标号相同的点，他们子节点个数奇偶性必然相同，否则一定无解，接着我们考虑构造方案，首先我们把子节点个数为偶数的点的值赋值为零，其他节点赋值为
<span class="math inline">\(1\)</span> 或 <span class="math inline">\(-1\)</span>，那么每颗子树一定有 <span class="math inline">\(2k+1\)</span>
个奇数点，我们把这些节点自底向上两两配对，不能配的上传到父亲，配对关系可以建图，这样每个点的度数为
<span class="math inline">\(2\)</span> 并且一条是在树 <code>A</code>
产生的边，另一条是在树 <code>B</code>
产生的边，一个点只有两者交替才能回到自己，所以图为二分图，可以产生匹配方案</p>
<h3 id="有向无环图">有向无环图</h3>
<p>一般在字典序问题或排列问题起到作用</p>
<h4 id="agc010rearranging"><a href="https://www.luogu.org/problem/AT2306">[AGC010]Rearranging</a></h4>
<p>互质的数不会交换，先后顺序不变，所以将互质的数之间连边，那么先手操作为给边定向，后手操作为求
<code>DAG</code> 的最大字典序，两遍贪心即可</p>
<h4 id="agc001wide-swap"><a href="https://www.luogu.org/problem/AT1984">[AGC001]Wide Swap</a></h4>
<p>首先题干中的条件有点复杂，我们不妨把排列的下标和值互换，这样最后求出字典序最小与原问题等价，发现这样题干中的交换条件就变为交换差值超过
<span class="math inline">\(k\)</span> 相邻两个数，那么差值不超过 <span class="math inline">\(k\)</span> 的一定不会交换，和上一题一样又转变为
<code>DAG</code> 字典序最小拓扑序问题，但这是 <span class="math inline">\(O(n^2)\)</span>
的建边，所以考虑优化，最终发现只需要向里当前点最近的连边即可</p>
<h2 id="最小生成树">最小生成树</h2>
<p>最小生成树我自己也不太会啊 QAQ</p>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title>[LGR-060D1] 小猪佩奇学数学</title>
    <url>/2019/10/13/LGR-060D1-%E5%B0%8F%E7%8C%AA%E4%BD%A9%E5%A5%87%E5%AD%A6%E6%95%B0%E5%AD%A6/</url>
    <content><![CDATA[<p><del>考试时多项式推错惨遭爆零</del></p>
<p>首先，这道题很明显式子是一个二项卷积，考虑 <code>EGF</code></p>
<p>不妨设</p>
<p><span class="math display">\[
f=\sum_np^n\lfloor\frac{n}{k}\rfloor\frac{x^n}{n!}
\]</span> <a id="more"></a> 则答案为</p>
<p><span class="math display">\[
[x^n]e^x\times f
\]</span></p>
<p>现在考虑 <span class="math inline">\(f\)</span> 如何求出</p>
<p>由于 <code>EGF</code> 的移位和指标下放很好实现，所以考虑多项式</p>
<p><span class="math display">\[
\hat{f}_n=\sum_i[n|i]\frac{x^i}{i!}
\]</span></p>
<p>显然 <span class="math inline">\(\hat{f}_2\)</span>
很好求出，即为</p>
<p><span class="math display">\[
\hat{f}_2=\frac{e^x+e^{-x}}{2}
\]</span></p>
<p>这也启发我们 <span class="math inline">\(\hat{f}_n\)</span>
可以用若干个形如 <span class="math inline">\(e^{kx}\)</span> 组合出</p>
<p>于是我们想到了单位根，即</p>
<p><span class="math display">\[
w_n^{in}=1
\]</span></p>
<p>对于 <span class="math inline">\(w_n^i\)</span> 而言，有</p>
<p><span class="math display">\[
\frac{1}{n}\sum_{k=0}^{n-1}w_n^{ik}=[i=0]
\]</span></p>
<p>那么可以得出</p>
<p><span class="math display">\[
\hat{f_n}=\frac{1}{n}\sum_{i=0}^{n-1}e^{w_n^ix}
\]</span></p>
<p>同时根据 <code>EGF</code> 的性质</p>
<p><span class="math display">\[
\frac{\partial\hat{f}_n}{\partial x^k}=\sum_i[n|(i+k)]\frac{x^i}{i!}
\]</span></p>
<p>乘上 <span class="math inline">\(\frac{x}{n}\)</span> 就有</p>
<p><span class="math display">\[
\frac{x}{n}\times\frac{\partial\hat{f}_n}{\partial
x^k}=\sum_i[n|(i+k-1)]\frac{i}{n}\frac{x^i}{i!}
\]</span></p>
<p>结合之前就有</p>
<p><span class="math display">\[
\frac{x}{n}\times\frac{\partial\hat{f}_n}{\partial
x^k}+\frac{k-1}{n}\times\frac{\partial\hat{f}_n}{\partial
x^{k-1}}=\sum_i[n|(i+k-1)]\lceil\frac{i}{n}\rceil\frac{x^i}{i!}
\]</span></p>
<p>所以当 <span class="math inline">\(k\ge2\)</span> 时</p>
<p><span class="math display">\[
\frac{x}{n}\times\frac{\partial\hat{f}_n}{\partial
x^k}+\frac{k-1}{n}\times\frac{\partial\hat{f}_n}{\partial
x^{k-1}}-\frac{\partial\hat{f}_n}{\partial
x^{k-1}}=\sum_i[n|(i+k-1)]\lfloor\frac{i}{n}\rfloor\frac{x^i}{i!}
\]</span></p>
<p>综上讨论</p>
<p><span class="math display">\[
f=\sum_{k=1}^n\frac{x}{n}\times\frac{\partial\hat{f_n}}{\partial
x^k}+\sum_{k=1}^n\frac{k-1}{n}\times\frac{\partial\hat{f_n}}{\partial
x^{k-1}}-\sum_{k=2}^n\frac{\partial\hat{f_n}}{\partial x^{k-1}}
\]</span></p>
<p>而对于 <span class="math inline">\(\frac{\partial\hat{f_n}}{\partial
x^k}\)</span> 有</p>
<p><span class="math display">\[
\frac{\partial\hat{f_n}}{\partial
x^k}=\frac{1}{n}\sum_{i=0}^{n-1}w_n^{ik}e^{w_n^ix}
\]</span></p>
<p>根据交换求和式的技巧我们可以把式子简化为只有一个和式而无嵌套情况，以中间的和式为例</p>
<p><span class="math display">\[
\sum_{k=1}^n\frac{k-1}{n}\times\frac{\partial\hat{f_n}}{\partial
x^{k-1}}=\frac{1}{n^2}\sum_{i=0}^{n-1}\sum_{k=1}^n(k-1)\times
w_n^{i(k-1)}e^{w_n^ix}
\]</span></p>
<p>根据</p>
<p><span class="math display">\[
\sum_{i=1}^nix^{i-1}=\frac{nx^{n+1}-nx^n-x^n+1}{(x-1)^2}
\]</span></p>
<p>上面的式子可以化简为</p>
<p><span class="math display">\[
\sum_{i=1}^{n-1}\frac{1}{n\times(w_n^i-1)}e^{w_n^ix}+\frac{n-1}{2\times
n}e^x
\]</span></p>
<p>其他同理</p>
<p>最后的问题只有单位根怎么求了，由于 <span class="math inline">\(998244353\)</span> 为 <code>NTT</code> 质数，所以
<span class="math inline">\(2^k\)</span> 的单位根就可以表示为 <span class="math inline">\(3^{\frac{P-1}{2^k}}\)</span></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bitset&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> int64;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">int</span> f = <span class="number">1</span>, <span class="keyword">int</span> x = <span class="number">0</span>, <span class="keyword">char</span> ch = <span class="string">&#x27; &#x27;</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">isdigit</span>(ch = getchar())) <span class="keyword">if</span>(ch == <span class="string">&#x27;-&#x27;</span>) f = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch)) x = x*<span class="number">10</span>+ch-<span class="string">&#x27;0&#x27;</span>, ch = getchar();</span><br><span class="line">    <span class="keyword">return</span> f*x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> P = <span class="number">998244353</span>;</span><br><span class="line"><span class="function">int64 <span class="title">qpow</span><span class="params">(int64 a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    int64 ret = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>( ; b; b &gt;&gt;= <span class="number">1</span>, a = a*a%P) <span class="keyword">if</span>(b&amp;<span class="number">1</span>) ret = a*ret%P;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line">int64 n, inv, inv2, p;</span><br><span class="line"><span class="keyword">int</span> ans, k;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n = read(), p = read(), k = read();</span><br><span class="line">    inv = qpow(k, P<span class="number">-2</span>);</span><br><span class="line">    ans = n*p%P*qpow(p+<span class="number">1</span>, n<span class="number">-1</span>)%P*inv%P;</span><br><span class="line">    ans = (ans+(k<span class="number">-1</span>)*qpow(<span class="number">2</span>*k, P<span class="number">-2</span>)%P*qpow(p+<span class="number">1</span>, n)%P)%P;</span><br><span class="line">    ans = (ans+P-qpow(p+<span class="number">1</span>, n))%P;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>, wn = qpow(<span class="number">3</span>, (P<span class="number">-1</span>)/k), w = wn; i &lt; k; ++i, w = <span class="number">1l</span>l*w*wn%P)</span><br><span class="line">        ans = (ans+qpow(w<span class="number">-1</span>, P<span class="number">-2</span>)*inv%P*qpow(w*p%P+<span class="number">1</span>, n)%P)%P;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>, w = <span class="number">1</span>, wn = qpow(<span class="number">3</span>, (P<span class="number">-1</span>)/k); i &lt; k; ++i, w = <span class="number">1l</span>l*w*wn%P)  </span><br><span class="line">        ans = (ans+inv*qpow(w*p%P+<span class="number">1</span>, n)%P)%P;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>生成函数</tag>
      </tags>
  </entry>
  <entry>
    <title>[WC2019] 数树</title>
    <url>/2019/10/09/WC2019-%E6%95%B0%E6%A0%91/</url>
    <content><![CDATA[<p><del>时隔 <span class="math inline">\(9\)</span>
个月，终于肝出这题了</del></p>
<p>设恰好有 <span class="math inline">\(i\)</span> 条边不重复的方案数为
<span class="math inline">\(f_i\)</span></p>
<p><span class="math display">\[
f_i = \sum_{|E|=i}\sum_{E&#39;\subseteq
E}(-1)^{i-|E&#39;|}n^{|E&#39;|-1}\prod_{S=C(E&#39;)}s
\]</span> <a id="more"></a> 交换求和次序得</p>
<p><span class="math display">\[
f_i =
\sum_{E&#39;}(-1)^{i-|E&#39;|}n^{|E&#39;|-1}\prod_{S=C(E&#39;)}s\sum_{|E|=i,E&#39;\subseteq
E}
\]</span></p>
<p>化简得</p>
<p><span class="math display">\[
f_i =
\sum_{E&#39;}(-1)^{i-|E&#39;|}n^{|E&#39;|-1}\prod_{S=C(E&#39;)}s\binom{n-1-|E&#39;|}{i-|E&#39;|}
\]</span></p>
<p>记</p>
<p><span class="math display">\[
\mathcal{F_i}=\sum_{|E|=i}\prod_{S=C(E)}s
\]</span></p>
<p>则有</p>
<p><span class="math display">\[
f_i = \sum_{j=0}^i(-1)^{i-j}n^{j-1}\binom{n-1-j}{i-j}\mathcal{F_j}
\]</span></p>
<p>答案为</p>
<p><span class="math display">\[
\sum_{i=0}^{n-1}\sum_{j=0}^i(-1)^{i-j}n^{j-1}\binom{n-1-j}{i-j}\mathcal{F_j}y^i
\]</span></p>
<p>交换求和次序得</p>
<p><span class="math display">\[
\sum_{j=0}^{n-1}n^{j-1}\mathcal{F_j}\sum_{i=j}^{n-1}(-1)^{i-j}\binom{n-1-j}{i-j}y^{i+1}
\]</span></p>
<p>化简为</p>
<p><span class="math display">\[
\sum_{j=0}^{n-1}n^{j-1}\mathcal{F_j}\sum_{i=0}^{n-1-j}y^{i+j+1}(-1)^{i}\binom{n-1-j}{i}
\]</span></p>
<p>用二项式定理化简得</p>
<p><span class="math display">\[
\sum_{j=0}^{n-1}n^{j-1}y^{j+1}(1-y)^{n-1-j}\mathcal{F_j}
\]</span></p>
<p>代入得</p>
<p><span class="math display">\[
\sum_{j=0}^{n-1}n^{j-1}y^{j+1}(1-y)^{n-1-j}\sum_{|E|=j}\prod_{S=C(E)}s
\]</span></p>
<p>那么有</p>
<p><span class="math display">\[
\frac{(1-y)^n}{n^2}\sum_{j=0}^{n-1}n^{j+1}(\frac{y}{1-y})^{j+1}\sum_{|E|=j}\prod_{S=C(E)}s
\]</span></p>
<p>进一步得</p>
<p><span class="math display">\[
\frac{(1-y)^{n}}{n^2}\sum_{E}\prod_{S=C(E)}\frac{ny}{1-y}s
\]</span></p>
<p>后面部分可以使用背包完成，时间复杂度为 <span class="math inline">\(O(n^2)\)</span></p>
<p>设 <span class="math inline">\(f_n\)</span>
为该联通块根节点所在联通块大小为 <span class="math inline">\(n\)</span>
的方案数，<span class="math inline">\(k=\frac{1-y}{ny}\)</span>
则在合并两个联通块时有</p>
<p><span class="math display">\[
h_n=k\sum_{i=0}^nf_ig_{n-i}(\frac{1}{i}+\frac{1}{n-i})+f_n\sum_{i=0}^Ng_i
\]</span></p>
<p>注意到我们最后只需关注 <span class="math inline">\(\sum_{i=0}^Nf_i\)</span>
并结合母函数的技巧启发我们考虑幂级数</p>
<p><span class="math display">\[
f(x)=\sum_{i=0}^Nf_ix^i
\]</span></p>
<p>最后答案即为 <span class="math inline">\(f(1)\)</span></p>
<p>那么套在 <code>DP</code> 上就有</p>
<p><span class="math display">\[
\sum_{n=0}^Nh_nx^n=k\sum_{n=0}^N\sum_{i=0}^nf_ig_{n-i}(\frac{1}{i}+\frac{1}{n-i})x^n+\sum_{n=0}^Nf_n\sum_{i=0}^Ng_ix^n
\]</span></p>
<p>化简为</p>
<p><span class="math display">\[
h(x)=k((\sum_{i=0}^n\frac{f_n}{n}x^n)g(x)+(\sum_{i=0}^n\frac{g_n}{n}x^n)f(x))+g(1)f(x)
\]</span></p>
<p>考虑函数</p>
<p><span class="math display">\[
\hat{f}(x)=\sum_{i=0}^n\frac{f_i}{i}x^i
\]</span></p>
<p>则有</p>
<p><span class="math display">\[
h(x)=k(\hat{f}(x)g(x)+\hat{g}(x)f(x))+f(x)g(1)
\]</span></p>
<p>令 <span class="math inline">\(x=1\)</span> 得到</p>
<p><span class="math display">\[
h(1)=k(\hat{f}(1)g(1)+\hat{g}(1)f(1))+f(1)g(1)
\]</span></p>
<p>考虑 <span class="math inline">\(\hat{f}(x)\)</span> 的求法</p>
<p><span class="math display">\[
\sum_{n=0}^N\frac{h_n}{n}x^n=k\sum_{n=0}^N\frac{1}{n}\sum_{i=0}^nf_ig_{n-i}(\frac{1}{i}+\frac{1}{n-i})x^n+\sum_{n=0}^N\frac{f_n}{n}\sum_{i=0}^Ng_ix^n
\]</span></p>
<p>化简为</p>
<p><span class="math display">\[
\hat{h}(x)=k\hat{f}(x)\hat{g}(x)+\hat{f}(x)g(1)
\]</span></p>
<p>同样</p>
<p><span class="math display">\[
\hat{h}(1)=k\hat{f}(1)\hat{g}(1)+\hat{f}(1)g(1)
\]</span></p>
<p>这样我们就得到了 <span class="math inline">\(O(n)\)</span> 的
<code>DP</code></p>
<p>考虑 <code>op3</code> 的做法，答案为</p>
<p><span class="math display">\[
\sum_{T}\frac{(1-y)^{n}}{n^2}\sum_{E\subseteq
T}\prod_{S=C(E)}\frac{ny}{1-y}s
\]</span></p>
<p>用 <code>prufer</code> 序列枚举联通块得</p>
<p><span class="math display">\[
\frac{(1-y)^{n}}{n^4}\sum_{\sum_{i=1}^ms_i=n}\frac{1}{m!}\frac{n!}{\prod_{i=1}^ms_i!}\prod_{i=1}^ms_i^{s_i-2}\prod_{i=1}^m\frac{n^2y}{1-y}{s_i}^2
\]</span></p>
<p>考后面部分的 <code>EGF</code> 得，并设 <span class="math inline">\(w=\frac{n^2y}{1-y}\)</span></p>
<p><span class="math display">\[
[x^n]f=\sum_{\sum_{i=1}^ms_i=n}\frac{1}{m!}\prod_{i=1}^m\frac{ws_i^{s_i}}{s_i!}
\]</span></p>
<p>这启发我们考虑函数 <span class="math inline">\(g=\sum_{i}w\frac{i^i}{i!}x^i\)</span></p>
<p>带入有</p>
<p><span class="math display">\[
f=\sum_m\frac{g^m}{m!}
\]</span></p>
<p>用等比数列求和化简得</p>
<p><span class="math display">\[
f=e^g
\]</span></p>
<p>最终答案即为</p>
<p><span class="math display">\[
\frac{n!(1-y)^{n}}{n^4}[x^n]f
\]</span></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> int64;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">int</span> f = <span class="number">1</span>, <span class="keyword">int</span> x = <span class="number">0</span>, <span class="keyword">char</span> ch = <span class="string">&#x27; &#x27;</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">isdigit</span>(ch = getchar())) <span class="keyword">if</span>(ch == <span class="string">&#x27;-&#x27;</span>) f = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch)) x = x*<span class="number">10</span>+ch-<span class="string">&#x27;0&#x27;</span>, ch = getchar();</span><br><span class="line">    <span class="keyword">return</span> f*x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">8e5</span>+<span class="number">5</span>, P = <span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">int</span> n, y, op, ans;</span><br><span class="line"><span class="function">int64 <span class="title">qpow</span><span class="params">(int64 a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    int64 ret = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>( ; b; b &gt;&gt;= <span class="number">1</span>, a = a*a%P) <span class="keyword">if</span>(b&amp;<span class="number">1</span>) ret = a*ret%P;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> solve0</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;, <span class="keyword">int</span>&gt; rec;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sol</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> x = read(), y = read(); </span><br><span class="line">        <span class="keyword">if</span>(x &gt; y) swap(x, y); ++rec[<span class="built_in">make_pair</span>(x, y)];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> x = read(), y = read(); </span><br><span class="line">        <span class="keyword">if</span>(x &gt; y) swap(x, y); ans += rec[<span class="built_in">make_pair</span>(x, y)];</span><br><span class="line">    &#125;</span><br><span class="line">    ans = qpow(y, n-ans);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> solve1</span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> next, to;</span><br><span class="line">    Edge(<span class="keyword">int</span> next = <span class="number">0</span>, <span class="keyword">int</span> to = <span class="number">0</span>):next(next), to(to) &#123;&#125;;</span><br><span class="line">&#125;edge[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> head[N], tot;</span><br><span class="line"><span class="keyword">void</span> _add(<span class="keyword">int</span> x, <span class="keyword">int</span> y) &#123; edge[++tot] = Edge(head[x], y), head[x] = tot; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123; _add(x, y), _add(y, x); &#125;</span><br><span class="line"><span class="keyword">int</span> f[N], g[N], inv[N], w, invw;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    f[x] = g[x] = w;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = head[x]; i; i = edge[i].next)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> y = edge[i].to; <span class="keyword">if</span>(y == fa) <span class="keyword">continue</span>;</span><br><span class="line">        dfs(y, x);</span><br><span class="line">        f[x] = ((<span class="number">1l</span>l*g[x]*f[y]%P+<span class="number">1l</span>l*f[x]*g[y]%P)%P*invw%P+<span class="number">1l</span>l*f[x]*f[y]%P)%P;</span><br><span class="line">        g[x] = (<span class="number">1l</span>l*g[y]*invw%P+f[y])%P*g[x]%P;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sol</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(y == <span class="number">1</span>) <span class="keyword">return</span> ans = qpow(n, n<span class="number">-2</span>)%P, <span class="keyword">void</span>(<span class="number">0</span>); </span><br><span class="line">    <span class="keyword">else</span>  inv[<span class="number">1</span>] = <span class="number">1</span>, w = <span class="number">1l</span>l*n*y%P*qpow(P+<span class="number">1</span>-y, P<span class="number">-2</span>)%P, invw = qpow(w, P<span class="number">-2</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> x = read(), y = read(); </span><br><span class="line">        add(x, y), inv[i] = P<span class="number">-1l</span>l*(P/i)*inv[P%i]%P;</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    ans = f[<span class="number">1</span>]*qpow(P+<span class="number">1</span>-y, n)%P*inv[n]%P*inv[n]%P;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> solve2</span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Poly</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; _;</span><br><span class="line">    <span class="keyword">inline</span> <span class="keyword">int</span>&amp; <span class="keyword">operator</span> [] (<span class="keyword">int</span> i) &#123; <span class="keyword">return</span> _[i]; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">ti</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> _.size()<span class="number">-1</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> ti)</span> </span>&#123; _.resize(ti+<span class="number">1</span>); &#125;</span><br><span class="line">&#125;F;</span><br><span class="line">int64 w[<span class="number">2</span>][N], inv[N], ifac[N], fac[N], k;</span><br><span class="line"><span class="keyword">int</span> lim;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">prepare</span><span class="params">(<span class="keyword">int</span> ti)</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    <span class="keyword">for</span>(lim = <span class="number">1</span>; lim &lt;= ti; lim &lt;&lt;= <span class="number">1</span>);</span><br><span class="line">    w[<span class="number">0</span>][<span class="number">0</span>] = w[<span class="number">0</span>][lim] = w[<span class="number">1</span>][<span class="number">0</span>] = w[<span class="number">1</span>][lim] = <span class="number">1</span>;</span><br><span class="line">    int64 g = qpow(<span class="number">3</span>, (P<span class="number">-1</span>)/lim);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; lim; ++i) </span><br><span class="line">        w[<span class="number">1</span>][lim-i] = w[<span class="number">0</span>][i] = w[<span class="number">0</span>][i<span class="number">-1</span>]*g%P;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">NTT</span><span class="params">(Poly &amp;A, <span class="keyword">int</span> t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!t) A.<span class="built_in">set</span>(lim<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; lim; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(i &gt; j) A[i] ^= A[j] ^= A[i] ^= A[j];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = lim&gt;&gt;<span class="number">1</span>; (j ^= k) &lt; k; k &gt;&gt;= <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> mid = <span class="number">1</span>; mid &lt; lim; mid &lt;&lt;= <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> len = mid&lt;&lt;<span class="number">1</span>, j = <span class="number">0</span>; j &lt; lim; j += len) </span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>, p = <span class="number">0</span>, q = lim/len; k &lt; mid; ++k, p += q)</span><br><span class="line">            &#123;</span><br><span class="line">                int64 x = A[j+k], y = w[t][p]*A[j+k+mid]%P;</span><br><span class="line">                A[j+k] = x+y&lt;P?x+y:x+y-P;</span><br><span class="line">                A[j+k+mid] = x-y&lt;<span class="number">0</span>?x-y+P:x-y;</span><br><span class="line">            &#125;</span><br><span class="line">    <span class="keyword">if</span>(!t) <span class="keyword">return</span>; int64 v = inv[lim];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lim; ++i) A[i] = A[i]*v%P;</span><br><span class="line">&#125;</span><br><span class="line">Poly <span class="keyword">operator</span> * (Poly A, Poly B)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> n = A.ti(), m = B.ti(); prepare(n+m);</span><br><span class="line">    NTT(A, <span class="number">0</span>), NTT(B, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lim; ++i) A[i] = <span class="number">1l</span>l*A[i]*B[i]%P;</span><br><span class="line">    NTT(A, <span class="number">1</span>); A.<span class="built_in">set</span>(n+m);</span><br><span class="line">    <span class="keyword">return</span> A;</span><br><span class="line">&#125;</span><br><span class="line">Poly <span class="keyword">operator</span> - (Poly A, Poly B)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> n = A.ti(), m = B.ti(); A.<span class="built_in">set</span>(max(n, m));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= m; ++i) A[i] = A[i]-B[i]&lt;<span class="number">0</span>?A[i]-B[i]+P:A[i]-B[i];</span><br><span class="line">    <span class="keyword">return</span> A;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Poly <span class="title">polyInv</span><span class="params">(Poly A, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Poly B; B.<span class="built_in">set</span>(n<span class="number">-1</span>), A.<span class="built_in">set</span>(n<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">1</span>) <span class="keyword">return</span> B[<span class="number">0</span>] = qpow(A[<span class="number">0</span>], P<span class="number">-2</span>), B;</span><br><span class="line">    B = polyInv(A, (n+<span class="number">1</span>)&gt;&gt;<span class="number">1</span>), prepare(n&lt;&lt;<span class="number">1</span>);</span><br><span class="line">    NTT(B, <span class="number">0</span>), NTT(A, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lim; ++i) B[i] = (<span class="number">2l</span>l<span class="number">-1l</span>l*A[i]*B[i]%P+P)%P*B[i]%P;</span><br><span class="line">    NTT(B, <span class="number">1</span>), B.<span class="built_in">set</span>(n<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">return</span> B;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Poly <span class="title">polyDer</span><span class="params">(Poly A, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n<span class="number">-1</span>; ++i) A[i] = <span class="number">1l</span>l*(i+<span class="number">1</span>)*A[i+<span class="number">1</span>]%P; A[n<span class="number">-1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> A;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Poly <span class="title">polyInte</span><span class="params">(Poly A, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = n<span class="number">-1</span>; i; --i) A[i] = inv[i]*A[i<span class="number">-1</span>]%P; A[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> A;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Poly <span class="title">polyLn</span><span class="params">(Poly A, <span class="keyword">int</span> n)</span> </span>&#123; <span class="keyword">return</span> polyInte(polyDer(A, n)*polyInv(A, n), n); &#125;</span><br><span class="line"><span class="function">Poly <span class="title">polyExp</span><span class="params">(Poly A, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Poly B; B.<span class="built_in">set</span>(n<span class="number">-1</span>), A.<span class="built_in">set</span>(n<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">1</span>) <span class="keyword">return</span> B[<span class="number">0</span>] = <span class="number">1</span>, B;</span><br><span class="line">    B = polyExp(A, (n+<span class="number">1</span>)&gt;&gt;<span class="number">1</span>), B.<span class="built_in">set</span>(n<span class="number">-1</span>), ++A[<span class="number">0</span>];</span><br><span class="line">    B = B*(A-polyLn(B, n)); B.<span class="built_in">set</span>(n<span class="number">-1</span>); </span><br><span class="line">    <span class="keyword">return</span> B;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sol</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(y == <span class="number">1</span>) <span class="keyword">return</span> ans = qpow(<span class="number">1l</span>l*n*n%P, n<span class="number">-2</span>), <span class="keyword">void</span>(<span class="number">0</span>);</span><br><span class="line">    fac[<span class="number">0</span>] = fac[<span class="number">1</span>] = ifac[<span class="number">0</span>] = ifac[<span class="number">1</span>] = inv[<span class="number">1</span>] = <span class="number">1</span>, k = y*qpow(P+<span class="number">1</span>-y, P<span class="number">-2</span>)%P*n%P*n%P, F.<span class="built_in">set</span>(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n&lt;&lt;<span class="number">3</span>; ++i) inv[i] = P-(P/i)*inv[P%i]%P, fac[i] = fac[i<span class="number">-1</span>]*i%P, ifac[i] = ifac[i<span class="number">-1</span>]*inv[i]%P;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) F[i] = k*qpow(i, i)%P*ifac[i]%P;</span><br><span class="line">    F = polyExp(F, n+<span class="number">1</span>), ans = F[n]*qpow(P+<span class="number">1</span>-y, n)%P*qpow(inv[n], <span class="number">4</span>)%P*fac[n]%P;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n = read(), y = read(), op = read();</span><br><span class="line">    <span class="keyword">if</span>(op == <span class="number">0</span>) solve0::sol();</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(op == <span class="number">1</span>) solve1::sol(); </span><br><span class="line">    <span class="keyword">else</span> solve2::sol();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>组合计数</tag>
        <tag>容斥</tag>
      </tags>
  </entry>
  <entry>
    <title>50809102 NOIP模拟题</title>
    <url>/2019/08/05/50809102-NOIP%E6%A8%A1%E6%8B%9F%E9%A2%98/</url>
    <content><![CDATA[<h2 id="a">a</h2>
<blockquote>
<p>给定程序，求程序地期望运行结果</p>
</blockquote>
<p>考虑一个长度为 <span class="math inline">\(n\)</span>
地排列，其逆序对数地期望为 <span class="math inline">\(\frac{\binom{n}{2}}{2}\)</span>，由此，不妨设
<span class="math inline">\(f_n\)</span> 为长度为 <span class="math inline">\(n\)</span> 的排列期望运行结果，则有</p>
<p><span class="math display">\[
f_n\ =\ \frac{n(n-1)}{4}+\frac{1}{2^n}\sum_{i=0}^n\binom{n}{i}f_i
\]</span> <a id="more"></a> 这时候可以移项得到一个 <span class="math inline">\(O(n^2)\)</span> 的 <span class="math inline">\(DP\)</span> 方程，但是我们考虑求出 <span class="math inline">\(f_n\)</span> 的通项，将组合数拆开有</p>
<p><span class="math display">\[
\frac{f_n}{n!}\ =\
\frac{n(n-1)}{4}\times\frac{1}{n!}+\frac{1}{2^n}\sum_{i=0}^n\frac{1}{(n-i)!}\frac{f_i}{i!}
\]</span></p>
<p>不妨设 <span class="math inline">\(&lt;f_0,f_1,f_2...&gt;\)</span> 的
<span class="math inline">\(egf\)</span> 为 <span class="math inline">\(f\)</span>，<span class="math inline">\(&lt;0,0,2,6...&gt;\)</span> 的 <span class="math inline">\(egf\)</span> 为 <span class="math inline">\(g\)</span></p>
<p>则有</p>
<p><span class="math display">\[
f(x)\ =\ \frac{1}{4}g(x)+e^{\frac{x}{2}}f(\frac{x}{2})
\]</span></p>
<p>根据 <span class="math inline">\(EGF\)</span> 性质</p>
<p><span class="math display">\[
x^me^x\ =\ \sum_n[n\ge m]n^{\underline{m}}\frac{x^n}{n!}
\]</span></p>
<p>可以得到 <span class="math inline">\(g\ =\ x^2e^x\)</span></p>
<p>盲猜一波如果方程成立，那么解一定为 <span class="math inline">\(cx^2e^x\)</span> 的形式，解出 <span class="math inline">\(c=\frac{1}{3}\)</span>，则 <span class="math inline">\(f_n=\frac{n(n-1)}{3}\)</span></p>
<p>那么答案为</p>
<p><span class="math display">\[
\frac{1}{n}\sum_{i=1}^nf_i=\frac{1}{3n}\times[\frac{n(n+1)(2n+1)}{6}-\frac{n(n+1)}{2}]=\frac{n^2-1}{9}
\]</span></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> int64;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> P = <span class="number">998244353</span>;</span><br><span class="line"><span class="function">int64 <span class="title">qpow</span><span class="params">(int64 a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    int64 ret = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>( ; b; b &gt;&gt;= <span class="number">1</span>, a = a*a%P) <span class="keyword">if</span>(b&amp;<span class="number">1</span>) ret = ret*a%P;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    freopen(<span class="string">&quot;a.in&quot;</span>, <span class="string">&quot;r&quot;</span>, <span class="built_in">stdin</span>);</span><br><span class="line">    freopen(<span class="string">&quot;a.out&quot;</span>, <span class="string">&quot;w&quot;</span>, <span class="built_in">stdout</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n); <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, (n*n<span class="number">-1</span>)*qpow(<span class="number">9</span>, P<span class="number">-2</span>)%P);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="c">c</h2>
<blockquote>
<p>给定一颗树，已知 <span class="math inline">\(s\)</span> 和 <span class="math inline">\(t\)</span>， 求 <span class="math inline">\(s\)</span> 到 <span class="math inline">\(t\)</span>
按题意要求游走的最坏情况下的最小花费</p>
</blockquote>
<p>首先考虑 <span class="math inline">\(s\)</span> 和 <span class="math inline">\(t\)</span>
直接相连的情况，此时最坏的情况一定出现在以 <span class="math inline">\(t\)</span> 为根，<span class="math inline">\(s\)</span> 的子树内，先分类讨论，如果节点 <span class="math inline">\(x\)</span> 为叶子节点，那么它的代价为从 <span class="math inline">\(s\)</span> 到该节点再到 <span class="math inline">\(t\)</span>
的最小花费，最小花费由两部分组成，首先是保证可以到达该节点，并在该节点停在直到删边后满足
<span class="math inline">\(x\)</span> 到 <span class="math inline">\(t\)</span> 有唯一通路，即 <span class="math inline">\(x\)</span> 到 <span class="math inline">\(t\)</span> 除 <span class="math inline">\(t\)</span> 以外的路径上每个点的子节点数减 <span class="math inline">\(1\)</span>，其次保证从这个节点可以回到 <span class="math inline">\(s\)</span>节点，那么这一部分代价为 <span class="math inline">\(dis(x,\ s)\)</span>，如果 <span class="math inline">\(x\)</span>
为非叶节点，那么在这个节点时，最优解一定为先删掉代价最大子节点对应的边，所以这个节点的代价为子节点中的次大代价，同时如果这个节点无次大值，那么可以额外耗费
<span class="math inline">\(1\)</span> 的花费使它变为叶子</p>
<p>之后考虑 <span class="math inline">\(s\)</span> 和 <span class="math inline">\(t\)</span> 不直接相连的情况，注意这是 <span class="math inline">\(s\)</span> 若一开始就向 <span class="math inline">\(t\)</span>
的方向随机游走可能情况会变得更差，所以我们最后的最小花费应不超过从 <span class="math inline">\(s\)</span> 向 <span class="math inline">\(t\)</span>
方向游走过程中的最坏情况的最优花费，答案具有单调性，考虑二分值为 <span class="math inline">\(mid\)</span>，定义每个节点的代价 <span class="math inline">\(f\)</span> 为由离着个点最近的 <span class="math inline">\(s\)</span> 到 <span class="math inline">\(t\)</span> 的节点出发再走到 <span class="math inline">\(t\)</span> 的最小花费，判断 <span class="math inline">\(mid\)</span> 是否合法则模拟从 <span class="math inline">\(s\)</span> 向 <span class="math inline">\(t\)</span>
方向游走的过程，设当前枚举的路径上的点为 <span class="math inline">\(u\)</span>，其不在路径上的子节点为 <span class="math inline">\(v\)</span>，游走过程中由于需要满足最坏情况不超过
<span class="math inline">\(mid\)</span>，则需要删除一些边，即枚举过程中删除的边为
<span class="math inline">\(del\)</span>，则当 <span class="math inline">\(f_v-[u=s]+del&gt;mid\)</span> 时需要删除 <span class="math inline">\((u,\ v)\)</span> 这条边，前面的减 <span class="math inline">\([u=s]\)</span> 时由于这个点就是由 <span class="math inline">\(s\)</span> 向上游走来的，而在 <span class="math inline">\(f_v\)</span>
中计算了删边的贡献，所以要减去，最后设当前枚举的 <span class="math inline">\(u\)</span> 时 <span class="math inline">\(s\)</span> 到 <span class="math inline">\(t\)</span> 的第 <span class="math inline">\(i\)</span> 个点，则它有 <span class="math inline">\(i\)</span> 次删除额外边的机会，依此来判断 <span class="math inline">\(mid\)</span> 是否合法</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">int</span> f = <span class="number">1</span>, <span class="keyword">int</span> x = <span class="number">0</span>, <span class="keyword">char</span> ch = <span class="string">&#x27; &#x27;</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">isdigit</span>(ch = getchar())) <span class="keyword">if</span>(ch == <span class="string">&#x27;-&#x27;</span>) f = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch)) x = x*<span class="number">10</span>+ch-<span class="string">&#x27;0&#x27;</span>, ch = getchar();</span><br><span class="line">    <span class="keyword">return</span> f*x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span>+<span class="number">5</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> next, to, w;</span><br><span class="line">    Edge(<span class="keyword">int</span> next = <span class="number">0</span>, <span class="keyword">int</span> to = <span class="number">0</span>):next(next), to(to) &#123;&#125;;</span><br><span class="line">&#125;edge[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> tot, head[N];</span><br><span class="line"><span class="keyword">void</span> _add(<span class="keyword">int</span> x, <span class="keyword">int</span> y) &#123; edge[++tot] = Edge(head[x], y), head[x] = tot; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123; _add(x, y), _add(y, x); &#125;</span><br><span class="line"><span class="keyword">int</span> n, m, s, t, in[N], d[N], f[N], g[N], fa[N], c[N], ans;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = head[x]; i; i = edge[i].next)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> y = edge[i].to; <span class="keyword">if</span>(y == fa[x]) <span class="keyword">continue</span>;</span><br><span class="line">        fa[y] = x, d[y] = d[x]+<span class="number">1</span>, dfs(y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> topf, <span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(in[x]) topf = x; <span class="keyword">int</span> m = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = head[x]; i; i = edge[i].next) m += edge[i].to != fa[x];</span><br><span class="line">    c += m?m<span class="number">-1</span>:<span class="number">0</span>, m = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = head[x], y; i; i = edge[i].next) <span class="keyword">if</span>((y = edge[i].to) != fa[x]) solve(y, topf, c);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = head[x], y; i; i = edge[i].next) <span class="keyword">if</span>((y = edge[i].to) != fa[x]) g[++m] = f[y];</span><br><span class="line">    sort(g+<span class="number">1</span>, g+<span class="number">1</span>+m), m &lt;= <span class="number">1</span>?f[x] = m+d[x]-d[topf]+c:f[x] = g[m<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; val[N];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">valid</span><span class="params">(<span class="keyword">int</span> mid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>, del = <span class="number">0</span>; i &lt;= m; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;w = val[i];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; w.size(); ++k) del += w[k]-(i != <span class="number">1</span>)+del &gt; mid;</span><br><span class="line">        <span class="keyword">if</span>(del &gt; i) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	freopen(<span class="string">&quot;c.in&quot;</span>,<span class="string">&quot;r&quot;</span>,<span class="built_in">stdin</span>);</span><br><span class="line">	freopen(<span class="string">&quot;c.out&quot;</span>,<span class="string">&quot;w&quot;</span>,<span class="built_in">stdout</span>);</span><br><span class="line">    n = read(), t = read(), s = read();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>, x, y; i &lt; n; ++i) x = read(), y = read(), add(x, y);</span><br><span class="line">    dfs(t); </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> x = s; x != t; x = fa[x]) in[x] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = head[t]; i; i = edge[i].next) solve(edge[i].to, t, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> x = s; x != t; x = fa[x])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;w = val[++m];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = head[x], y; i; i = edge[i].next)</span><br><span class="line">            <span class="keyword">if</span>(!in[y = edge[i].to]) w.push_back(f[y]);</span><br><span class="line">        sort(w.begin(), w.end());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> l = f[s], r = n&lt;&lt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(l &lt;= r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(valid(mid)) ans = mid, r = mid<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">else</span> l = mid+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, f[s]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>思维</tag>
        <tag>生成函数</tag>
        <tag>贪心</tag>
        <tag>概率期望</tag>
      </tags>
  </entry>
  <entry>
    <title>10809102 AGC006</title>
    <url>/2019/08/02/10809102-AGC006/</url>
    <content><![CDATA[<h2 id="median-pyramid-easy"><a href="https://www.luogu.org/problem/AT2163">Median Pyramid Easy</a></h2>
<blockquote>
<p>给定一个数字三角形，最底下一层的值为一个长度为 <span class="math inline">\(2n-1\)</span>
排列，其余方格中填写的整数是方格正下方,左下方和右下方方格中所写整数的中位数，给定
<span class="math inline">\(n\)</span> 和 <span class="math inline">\(x\)</span> 求最终构造出三角形顶端为 <span class="math inline">\(x\)</span> 的方案</p>
</blockquote>
<p>一开始想的是每一层的值比下一层的值少了下一层的最大值和最小值以及满足比周围
<span class="math inline">\(4\)</span>
个方格的树都小或都大的数，所以我们需要要计算好中位数偏移量，将左侧每
<span class="math inline">\(3\)</span>
个数将需要删除的数移进去即可，得到的结论是 <span class="math inline">\(|n-x|\le\lfloor\frac{n}{3}\rfloor\)</span> 时
<span class="math inline">\(x\)</span>
可以构造出来，这个构造意外的骗了很多分 <a id="more"></a> 然而，正确的结论是
<span class="math inline">\(x\)</span> 可以为 <span class="math inline">\(1\)</span> 或 <span class="math inline">\(2n-1\)</span>
的任何数，我们可以发现当最倒数第二层出现两个相邻的相同数字时，这两个数字会一直向上沿伸，最后的答案为里对称轴最近的满足上述条件的数字</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> n, x, q, ans;</span><br><span class="line"><span class="keyword">int</span> p[N], vis[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;x);</span><br><span class="line">    <span class="keyword">if</span>(x == <span class="number">1</span>||x == <span class="number">2</span>*n<span class="number">-1</span>) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;No&quot;</span>), <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Yes&quot;</span>); </span><br><span class="line">    p[n] = x, p[n<span class="number">-1</span>] = x == <span class="number">2</span>?x+<span class="number">1</span>:x<span class="number">-1</span>, p[n+<span class="number">1</span>] = x == <span class="number">2</span>?x<span class="number">-1</span>:x+<span class="number">1</span>, p[n+<span class="number">2</span>] = x == <span class="number">2</span>?x+<span class="number">2</span>:x<span class="number">-2</span>;</span><br><span class="line">    vis[x] = vis[x+<span class="number">1</span>] = vis[x<span class="number">-1</span>] = vis[x == <span class="number">2</span>?x+<span class="number">2</span>:x<span class="number">-2</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>, j = <span class="number">1</span>; i &lt;= <span class="number">2</span>*n<span class="number">-1</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(p[i]) <span class="keyword">continue</span>; <span class="keyword">while</span>(vis[j]) ++j;</span><br><span class="line">        p[i] = j, vis[j] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">2</span>*n<span class="number">-1</span>; ++i) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, p[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="rabbit-exercise"><a href="https://www.luogu.org/problem/AT2164">Rabbit Exercise</a></h2>
<blockquote>
<p>有 <span class="math inline">\(n\)</span> 只兔子站在数轴上，第 <span class="math inline">\(i\)</span> 只兔子的初始位置为 <span class="math inline">\(a_i\)</span>，现在这些兔子会按照下面的规则做若干次移动，每一次<span class="math inline">\(m\)</span> 次跳跃组成，在第 <span class="math inline">\(j\)</span>次跳跃的时候，第 <span class="math inline">\(c_j\)</span> 只兔子会等概率随机选择第 <span class="math inline">\(c_j-1\)</span> 和 <span class="math inline">\(c_j+1\)</span> 只兔子中的一只跳到对称点，求 <span class="math inline">\(k\)</span>
次动作之后，每一只兔子最终位置坐标的期望值</p>
</blockquote>
<p>首先暴力的 <span class="math inline">\(DP\)</span> 方程很好写，<span class="math inline">\(f&#39;_{c_i}=\frac{2f_{c_i-1}+2f_{c_i+1}-2f_{c_i}}{2}=f_{c_i-1}+f_{c_i+1}-f_{c_i}\)</span></p>
<p>然而，复杂度为 <span class="math inline">\(O(mk)\)</span>，遇到转移问题发现难以转移就想一想差分，考虑
<span class="math inline">\(d_i\ =\ f_i-f_{i-1}\)</span></p>
<p>那么差分后的转移就变为</p>
<p><span class="math display">\[
d&#39;_{c_i}=f&#39;_{c_i}-f_{c_i-1}=f_{c_i+1}-f_{c_i}=d_{c_i+1}
\]</span></p>
<p><span class="math display">\[
d&#39;_{c_i+1}=f_{c_i+1}-f&#39;_{c_i}=f_{c_i}-f_{c_i-1}=d_{c_i}
\]</span></p>
<p>发现正好是两者交换了位置，那么我们只有扫一遍操作序列，求出循环节，就可以快速求了</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> int64;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> int64 <span class="title">read</span><span class="params">(<span class="keyword">int</span> f = <span class="number">1</span>, int64 x = <span class="number">0</span>, <span class="keyword">char</span> ch = <span class="string">&#x27; &#x27;</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">isdigit</span>(ch = getchar())) <span class="keyword">if</span>(ch == <span class="string">&#x27;-&#x27;</span>) f = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch)) x = x*<span class="number">10</span>+ch-<span class="string">&#x27;0&#x27;</span>, ch = getchar();</span><br><span class="line">    <span class="keyword">return</span> f*x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, a[N], f[N], s[N], top, vis[N];</span><br><span class="line">int64 ans[N], k;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n = read();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) a[i] = read();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = n; i; --i) a[i] -= a[i<span class="number">-1</span>], f[i] = i;</span><br><span class="line">    m = read(), k = read();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>, p; i &lt;= m; ++i) p = read(), swap(f[p], f[p+<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i, top = <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">if</span>(!vis[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i; !vis[j]; j = f[j]) vis[j] = <span class="number">1</span>, s[++top] = j;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= top; ++j) ans[s[j]] = a[s[(j+k<span class="number">-1</span>)%top+<span class="number">1</span>]];</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans[i] += ans[i<span class="number">-1</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="median-pyramid-hard"><a href="https://www.luogu.org/problem/AT2165">Median Pyramid Hard</a></h2>
<blockquote>
<p>给定一个数字三角形，最底下一层的值为一个长度为 <span class="math inline">\(2n-1\)</span>
排列，其余方格中填写的整数是方格正下方,左下方和右下方方格中所写整数的中位数，给定
<span class="math inline">\(n\)</span> 和
最底下一层的排列，求第一层的值</p>
</blockquote>
<p>直接求很难求，考虑像猜数字一样二分，每次得到顶端的数与二分值得大小，按照
<span class="math inline">\(B\)</span>
题的结论，里对称轴最近的长度至少为 <span class="math inline">\(2\)</span>
的连续段就是顶端的答案，特判不存在这样连续段的情况即可</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">int</span> f = <span class="number">1</span>, <span class="keyword">int</span> x = <span class="number">0</span>, <span class="keyword">char</span> ch = <span class="string">&#x27; &#x27;</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">isdigit</span>(ch = getchar())) <span class="keyword">if</span>(ch == <span class="string">&#x27;-&#x27;</span>) f = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch)) x = x*<span class="number">10</span>+ch-<span class="string">&#x27;0&#x27;</span>, ch = getchar();</span><br><span class="line">    <span class="keyword">return</span> f*x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> n, p[N], ans = <span class="number">2</span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">valid</span><span class="params">(<span class="keyword">int</span> mid)</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n<span class="number">-1</span>; ++i)</span><br><span class="line">        <span class="keyword">if</span>(max(p[n-i], p[n-i<span class="number">-1</span>]) &lt;= mid||max(p[n+i], p[n+i+<span class="number">1</span>]) &lt;= mid) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(min(p[n-i], p[n-i<span class="number">-1</span>]) &gt; mid||min(p[n+i], p[n+i+<span class="number">1</span>]) &gt; mid) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> p[<span class="number">1</span>] &lt;= mid;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n = read();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>*n<span class="number">-1</span>; i; --i) p[i] = read();</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">2</span>, r = <span class="number">2</span>*n<span class="number">-2</span>;</span><br><span class="line">    <span class="keyword">while</span>(l &lt;= r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(valid(mid)) r = mid<span class="number">-1</span>, ans = mid;</span><br><span class="line">        <span class="keyword">else</span> l = mid+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="rotate-3x3"><a href="https://www.luogu.org/problem/AT2166">Rotate 3x3</a></h2>
<blockquote>
<p>我们有一个 <span class="math inline">\(3\)</span> 行 <span class="math inline">\(N\)</span> 列的初始矩阵，<span class="math inline">\((i,\ j)\)</span> 位置的数为 <span class="math inline">\(i+3j-3\)</span>，我们有一个这样的操作：选择一个
<span class="math inline">\(3\times3\)</span> 的子矩阵，将这个子矩阵旋转
<span class="math inline">\(180^\circ\)</span>，给定 <span class="math inline">\(3\)</span> 行 <span class="math inline">\(N\)</span>
列的矩阵，矩阵内的数值互不相同，问能否通过若干次上述操作将初始矩阵变为给定的矩阵</p>
</blockquote>
<p>先特判掉一定无解的情况</p>
<p>我们注意到每次以 <span class="math inline">\((i,\ 2)\)</span>
为中心旋转实际上是将 <span class="math inline">\(i-1\)</span> 列和 <span class="math inline">\(i+1\)</span> 列交换，并且 <span class="math inline">\(i\)</span>
及相邻两列的上下颠倒，也就是说每次旋转操作除交换之外将区间 <span class="math inline">\([i-1,\ i+1]\)</span>
的奇偶性改变，奇数时要上下颠倒，偶数时则不用，初始奇偶性序列为给定矩阵的上下颠倒状态，所以问题就转换为对于给定矩阵经过一系列操作后满足第
<span class="math inline">\(2\)</span>
层的数值顺序递增，且每个位置奇偶性是否满足要求</p>
<p>考虑我们已经使位置合法了，而现在奇偶性并不满足要求，则当 <span class="math inline">\(n\ge 4\)</span>
时有如下变化可以在不改边位置的情况下该边奇偶性，我们可以</p>
<p><span class="math display">\[
abcd\to CBAd\to CDab\to Adcb\to ABCD
\]</span></p>
<p>可以发现每次我们可以改变相邻 <span class="math inline">\(4\)</span>
个状态的奇偶性，而我们还有变化</p>
<p><span class="math display">\[
abcdef\to abcFED\to afCBED\to abcFED\to abcdef
\]</span></p>
<p>此外，上述两者结合，我们只需要把一对需要该边奇列或偶列该边它们的奇偶性，所以答案就变成最终状态的奇数和偶上下颠倒的列个数的奇偶性，若都为偶数则合法，否则不合法</p>
<p>对于最终状态而言，我们只需要求出任意一个方案即可，因为对于一系列操作序列来看，都可以由上述两个操作通过类似于线性组合得到，而每次都是成对变化，不会影响奇偶性</p>
<p>对于求出任意一种可以满足顺序正确的交换方案来说，每次交换会使奇偶性相反数列的列个数奇偶性改变</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">int</span> f = <span class="number">1</span>, <span class="keyword">int</span> x = <span class="number">0</span>, <span class="keyword">char</span> ch = <span class="string">&#x27; &#x27;</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">isdigit</span>(ch = getchar())) <span class="keyword">if</span>(ch == <span class="string">&#x27;-&#x27;</span>) f = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch)) x = x*<span class="number">10</span>+ch-<span class="string">&#x27;0&#x27;</span>, ch = getchar();</span><br><span class="line">    <span class="keyword">return</span> f*x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> n, w[<span class="number">3</span>][N], f[N], h[<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n = read();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j) </span><br><span class="line">            w[i][j] = read();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a = w[<span class="number">0</span>][i], b = w[<span class="number">1</span>][i], c = w[<span class="number">2</span>][i];</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">abs</span>(a-b) &gt; <span class="number">1</span>||<span class="built_in">abs</span>(b-c) &gt; <span class="number">1</span>||b%<span class="number">3</span> != <span class="number">2</span>||(b%<span class="number">6</span>&amp;i&amp;<span class="number">1</span>)) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;No&quot;</span>), <span class="number">0</span>;</span><br><span class="line">        f[i] = b/<span class="number">3</span>+<span class="number">1</span>, h[i&amp;<span class="number">1</span>] ^= a &gt; c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="keyword">while</span>(f[i] != i) h[i&amp;<span class="number">1</span>^<span class="number">1</span>] ^= <span class="number">1</span>, swap(f[i], f[f[i]]);</span><br><span class="line">    <span class="built_in">puts</span>(h[<span class="number">0</span>]||h[<span class="number">1</span>]?<span class="string">&quot;No&quot;</span>:<span class="string">&quot;Yes&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="blackout"><a href="https://www.luogu.org/problem/AT2167">Blackout</a></h2>
<blockquote>
<p>给定 <span class="math inline">\(n\times n\)</span>
的网格，给定坐标序列，这些坐标序列的颜色为黑色，其余为白色，若存在 <span class="math inline">\((x,\ y)\)</span> 和 <span class="math inline">\((y,\ z)\)</span> 则会出现一个 <span class="math inline">\((z,\ x)\)</span> 的黑点，求最终黑点数</p>
</blockquote>
<p>很容易把题意转化为图论问题，一般图问题如果不知道怎么做就染色，我们把图染成
<span class="math inline">\(3\)</span>
种颜色，若染色成功我们会发现不同颜色之间会有边相连，若染色不成功则会成为完全图，若每种颜色不全存在，则为各部分图的边数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> int64;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">int</span> f = <span class="number">1</span>, <span class="keyword">int</span> x = <span class="number">0</span>, <span class="keyword">char</span> ch = <span class="string">&#x27; &#x27;</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">isdigit</span>(ch = getchar())) <span class="keyword">if</span>(ch == <span class="string">&#x27;-&#x27;</span>) f = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch)) x = x*<span class="number">10</span>+ch-<span class="string">&#x27;0&#x27;</span>, ch = getchar();</span><br><span class="line">    <span class="keyword">return</span> f*x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> next, to, w;</span><br><span class="line">    Edge(<span class="keyword">int</span> next = <span class="number">0</span>, <span class="keyword">int</span> to = <span class="number">0</span>, <span class="keyword">int</span> w = <span class="number">0</span>):next(next), to(to), w(w) &#123;&#125;;</span><br><span class="line">&#125;edge[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> tot, head[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> z)</span> </span>&#123; edge[++tot] = Edge(head[x], y, z); head[x] = tot; &#125;</span><br><span class="line"><span class="keyword">int</span> n, m, c[N];</span><br><span class="line">int64 ans, f[<span class="number">3</span>], s;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">color</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> col)</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    <span class="keyword">if</span>(c[x]) <span class="keyword">return</span> c[x] == col+<span class="number">1</span>;   </span><br><span class="line">    c[x] = col+<span class="number">1</span>, ++f[col];</span><br><span class="line">    <span class="keyword">bool</span> ret = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = head[x]; i; i = edge[i].next)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> y = edge[i].to, z = edge[i].w; s += z == <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(!color(y, col+z &gt;= <span class="number">3</span>?col+z<span class="number">-3</span>:col+z)) ret = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n = read(), m = read();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> x = read(), y = read();</span><br><span class="line">        add(x, y, <span class="number">1</span>), add(y, x, <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> x = <span class="number">1</span>; x &lt;= n; ++x)</span><br><span class="line">        <span class="keyword">if</span>(!c[x])</span><br><span class="line">        &#123;</span><br><span class="line">            s = f[<span class="number">0</span>] = f[<span class="number">1</span>] = f[<span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(!color(x, <span class="number">1</span>)) s = f[<span class="number">0</span>]+f[<span class="number">1</span>]+f[<span class="number">2</span>], ans += s*s;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(f[<span class="number">0</span>]&amp;&amp;f[<span class="number">1</span>]&amp;&amp;f[<span class="number">2</span>]) ans += f[<span class="number">0</span>]*f[<span class="number">1</span>]+f[<span class="number">1</span>]*f[<span class="number">2</span>]+f[<span class="number">0</span>]*f[<span class="number">2</span>];</span><br><span class="line">            <span class="keyword">else</span> ans += s;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>构造</tag>
        <tag>差分</tag>
        <tag>思维</tag>
      </tags>
  </entry>
  <entry>
    <title>20809102 NOIP模拟题</title>
    <url>/2019/08/02/20809102-NOIP%E6%A8%A1%E6%8B%9F%E9%A2%98/</url>
    <content><![CDATA[<h2 id="card">card</h2>
<blockquote>
<p>给定 <span class="math inline">\(n\)</span> 张值为 <span class="math inline">\(i\)</span> 的卡牌，每次随机选择一个整数 <span class="math inline">\(m\)</span>，将每 <span class="math inline">\(m\)</span> 张合成 <span class="math inline">\(1\)</span> 张卡牌值加 <span class="math inline">\(1\)</span>，剩下的卡牌丢掉，直到最后只剩下一张牌，求值的期望</p>
</blockquote>
<p>题意有些不清楚，首先 <span class="math inline">\(m\)</span>
张牌合并的意思是将 <span class="math inline">\(n\)</span>
张牌依次排列，依次把相邻的 <span class="math inline">\(m\)</span>
张牌只合并 <span class="math inline">\(1\)</span> 次，新的牌的值就是原来
<span class="math inline">\(m\)</span> 张牌的值的任意一张加 <span class="math inline">\(1\)</span> 剩下的丢掉，注意可以自己和自己合并</p>
<p>明确了意思就不难做出来了，显然任何局面下的每张牌面的牌面都一样，所以设
<span class="math inline">\(E(n)\)</span> 为有 <span class="math inline">\(n\)</span> 张牌时，每张牌值得期望，则有</p>
<p><span class="math display">\[
E(n)\ =\ \frac{\sum_{i=1}^n[E(\lfloor\frac{n}{i}\rfloor)+1]}{n}
\]</span> <a id="more"></a> 化简得</p>
<p><span class="math display">\[
E(n)\ =\ \frac{n+\sum_{i=2}^nE(\lfloor\frac{n}{i}\rfloor)}{n-1}
\]</span></p>
<p>除法分块即可</p>
<p>记忆化搜索时用数组记录状态会快一点</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> int64;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">int</span> f = <span class="number">1</span>, <span class="keyword">int</span> x = <span class="number">0</span>, <span class="keyword">char</span> ch = <span class="string">&#x27; &#x27;</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">isdigit</span>(ch = getchar())) <span class="keyword">if</span>(ch == <span class="string">&#x27;-&#x27;</span>) f = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch)) x = x*<span class="number">10</span>+ch-<span class="string">&#x27;0&#x27;</span>, ch = getchar();</span><br><span class="line">    <span class="keyword">return</span> f*x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> P = <span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">3e7</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> h[N];</span><br><span class="line"><span class="function">int64 <span class="title">qpow</span><span class="params">(int64 a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    int64 ret = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>( ; b; b &gt;&gt;= <span class="number">1</span>, a = a*a%P) <span class="keyword">if</span>(b&amp;<span class="number">1</span>) ret = a*ret%P;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">int64 <span class="title">E</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(n &lt; N&amp;&amp;h[n]) <span class="keyword">return</span> h[n];</span><br><span class="line">    int64 ret = n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> l = <span class="number">2</span>, r; l &lt;= n; l = r+<span class="number">1</span>)</span><br><span class="line">        r = n/(n/l), ret = (ret+E(n/l)*(r-l+<span class="number">1</span>)%P)%P;</span><br><span class="line">    <span class="keyword">if</span>(n &lt; N) <span class="keyword">return</span> h[n] = ret*qpow(n<span class="number">-1</span>, P<span class="number">-2</span>)%P;</span><br><span class="line">    <span class="keyword">return</span> ret*qpow(n<span class="number">-1</span>, P<span class="number">-2</span>)%P;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    freopen(<span class="string">&quot;card.in&quot;</span>, <span class="string">&quot;r&quot;</span>, <span class="built_in">stdin</span>);</span><br><span class="line">    freopen(<span class="string">&quot;card.out&quot;</span>, <span class="string">&quot;w&quot;</span>, <span class="built_in">stdout</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, E(read()));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="gift">gift</h2>
<blockquote>
<p>最初 <span class="math inline">\(Kirin\)</span> 手里拿着一张值为
<span class="math inline">\(0\)</span> 的卡牌，然后他从第 <span class="math inline">\(1\)</span> 张卡牌走到第 <span class="math inline">\(n\)</span>
张卡牌，每次他遇到一张比手里的卡牌等级大的卡牌，他就会交换手中的卡牌与这张卡牌，多次询问
<span class="math inline">\(x\)</span> 次操作后第 <span class="math inline">\(y\)</span> 张卡牌的值</p>
</blockquote>
<p>当第 <span class="math inline">\(k\)</span> 次操作时，位于位置 <span class="math inline">\(i\)</span> 的卡牌若比 <span class="math inline">\([1,\ i]\)</span> 的第 <span class="math inline">\(k\)</span> 大卡牌大的情况下位置 <span class="math inline">\(i\)</span> 的卡牌变为第 <span class="math inline">\(k\)</span>
大的卡牌，并且在之后操作下依次减小，否则，位置 <span class="math inline">\(i\)</span> 的卡牌不变，因此，<span class="math inline">\((x,\ y)\)</span> 的答案为 <span class="math inline">\(min(xthmax_{1\le k\le y}\lbrace a_k\rbrace,\
a_y)\)</span></p>
<p>还有一个疑问是，一开始审错题看成冒泡排序了，但是，如何求第 <span class="math inline">\(k\)</span> 次冒泡排序的第 <span class="math inline">\(i\)</span> 个位置的值</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">int</span> f = <span class="number">1</span>, <span class="keyword">int</span> x = <span class="number">0</span>, <span class="keyword">char</span> ch = <span class="string">&#x27; &#x27;</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">isdigit</span>(ch = getchar())) <span class="keyword">if</span>(ch == <span class="string">&#x27;-&#x27;</span>) f = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch)) x = x*<span class="number">10</span>+ch-<span class="string">&#x27;0&#x27;</span>, ch = getchar();</span><br><span class="line">    <span class="keyword">return</span> f*x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> n, q, a[N], _[N];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &gt; s[N];</span><br><span class="line"><span class="keyword">int</span> val[N&lt;&lt;<span class="number">2</span>], ans[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    ++val[x]; <span class="keyword">if</span>(l == r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = (l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(p &lt;= mid) <span class="keyword">return</span> add(x&lt;&lt;<span class="number">1</span>, l, mid, p);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> add(x&lt;&lt;<span class="number">1</span>|<span class="number">1</span>, mid+<span class="number">1</span>, r, p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l == r) <span class="keyword">return</span> l;</span><br><span class="line">    <span class="keyword">int</span> mid = (l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(val[x&lt;&lt;<span class="number">1</span>|<span class="number">1</span>] &gt;= k) <span class="keyword">return</span> query(x&lt;&lt;<span class="number">1</span>|<span class="number">1</span>, mid+<span class="number">1</span>, r, k);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> query(x&lt;&lt;<span class="number">1</span>, l, mid, k-val[x&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    freopen(<span class="string">&quot;gift.in&quot;</span>, <span class="string">&quot;r&quot;</span>, <span class="built_in">stdin</span>);</span><br><span class="line">    freopen(<span class="string">&quot;gift.out&quot;</span>, <span class="string">&quot;w&quot;</span>, <span class="built_in">stdout</span>);</span><br><span class="line">    n = read(), q = read();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) _[i] = a[i] = read();</span><br><span class="line">    sort(_+<span class="number">1</span>, _+<span class="number">1</span>+n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= q; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> x = read(), y = read();</span><br><span class="line">        s[y].push_back(<span class="built_in">make_pair</span>(x, i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>, p; i &lt;= n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        add(<span class="number">1</span>, <span class="number">1</span>, n, p = lower_bound(_+<span class="number">1</span>, _+<span class="number">1</span>+n, a[i])-_);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; s[i].size(); ++k)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> x = s[i][k].first, d = s[i][k].second;</span><br><span class="line">            ans[d] = min(x &lt;= i?_[query(<span class="number">1</span>, <span class="number">1</span>, n, x)]:<span class="number">0</span>, a[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= q; ++i) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>思维</tag>
        <tag>期望概率</tag>
      </tags>
  </entry>
  <entry>
    <title>10809102 NOIP模拟题</title>
    <url>/2019/08/01/10809102-NOIP%E6%A8%A1%E6%8B%9F%E9%A2%98/</url>
    <content><![CDATA[<h2 id="c-cf1178f-short-colorful-strip"><a href="http://codeforces.com/contest/1178/problem/F1">C (CF1178F Short
Colorful Strip)</a></h2>
<blockquote>
<p>给定全 <span class="math inline">\(0\)</span> 序列，第 <span class="math inline">\(i\)</span> 次操作可以把值相同的区间的值赋值为
<span class="math inline">\(i\)</span>，给定目标排列，求出操作方案数</p>
</blockquote>
<p>有两个很明显的性质，首先，第 <span class="math inline">\(i\)</span>
次操作区间一定包括值为 <span class="math inline">\(i\)</span>
的位置，其次，当一个区间被操作后，这个区间与其他区间相互独立</p>
<p>后者是一个很好的性质，意味着对于每个区间只需要关注最小合法位置，枚举区间划分即可，最后区间相乘即可
<a id="more"></a> 所以，考场上写了一个 <span class="math inline">\(O(n^4)\)</span> 的 <span class="math inline">\(DP\)</span></p>
<p>设 <span class="math inline">\(f_{p,l,r}\)</span> 为区间 <span class="math inline">\([l,\ r]\)</span> 第 <span class="math inline">\(p\)</span> 次操作的操作方案数，<span class="math inline">\(g_{l,r,k}\)</span> 为区间 <span class="math inline">\([l,\ r]\)</span> 的不严格后继，不存在是为 <span class="math inline">\(0\)</span>，<span class="math inline">\(q_i\)</span> 为值为 <span class="math inline">\(i\)</span> 的位置，则有</p>
<p><span class="math display">\[
f_{p,\ l,\ r}\ =\
\sum_{i=l}^{q_p}\sum_{j=q_p}^rf_{g_{l,i-1,p+1},l,i-1}f_{g_{i,j,p+1},i,j}f_{g_{j+1,r,p+1},j+1,r}[min_{i\le
k\le r}\lbrace s_k\rbrace\ge p]
\]</span></p>
<p>边界 <span class="math inline">\(f_{0,l,r}=1\)</span></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> int64;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">int</span> f = <span class="number">1</span>, <span class="keyword">int</span> x = <span class="number">0</span>, <span class="keyword">char</span> ch = <span class="string">&#x27; &#x27;</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">isdigit</span>(ch = getchar())) <span class="keyword">if</span>(ch == <span class="string">&#x27;-&#x27;</span>) f = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch)) x = x*<span class="number">10</span>+ch-<span class="string">&#x27;0&#x27;</span>, ch = getchar();</span><br><span class="line">    <span class="keyword">return</span> f*x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e2</span>+<span class="number">5</span>, P = <span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">int</span> n, s[N], q[N];</span><br><span class="line">int64 f[N][N][N];</span><br><span class="line"><span class="keyword">int</span> g[N][N][N];</span><br><span class="line"><span class="function">int64 <span class="title">dp</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    int64 &amp;ret = f[p][l][r];</span><br><span class="line">    <span class="keyword">if</span>(ret) <span class="keyword">return</span> ret;</span><br><span class="line">    <span class="keyword">if</span>(p == <span class="number">0</span>) ret = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = q[p]; i &gt;= l&amp;&amp;p &lt;= s[i]; --i)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = q[p]; j &lt;= r&amp;&amp;p &lt;= s[j]; ++j)</span><br><span class="line">                ret = (ret+dp(g[l][i<span class="number">-1</span>][p+<span class="number">1</span>], l, i<span class="number">-1</span>)*dp(g[i][j][p+<span class="number">1</span>], i, j)%P*dp(g[j+<span class="number">1</span>][r][p+<span class="number">1</span>], j+<span class="number">1</span>, r)%P)%P;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n = read();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) s[i] = read(), q[s[i]] = i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= n; ++k)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> l = <span class="number">1</span>; l &lt;= n; ++l)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> r = l; r &lt;= n; ++r)</span><br><span class="line">                <span class="keyword">if</span>(s[r] &gt;= k) g[l][r][k] = min(s[r], g[l][r<span class="number">-1</span>][k]?g[l][r<span class="number">-1</span>][k]:n);</span><br><span class="line">                <span class="keyword">else</span> g[l][r][k] = g[l][r<span class="number">-1</span>][k];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, dp(<span class="number">1</span>, <span class="number">1</span>, n));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>期望 <span class="math inline">\(70\)</span> 分</p>
<p>实际上我们可以省略第一维状态，因为不管怎么样，<span class="math inline">\([l,\ r]\)</span>
填的数一定是最小值，这样一个区间就确定了唯一一个对应的次序</p>
<p>设 <span class="math inline">\(f_{l,r}\)</span> 为 <span class="math inline">\([l,\ r]\)</span> 的方案数，<span class="math inline">\(g_{l,r}\)</span> 为 <span class="math inline">\([l,\ r]\)</span> 的最小值，不妨设为 <span class="math inline">\(x\)</span></p>
<p>则有</p>
<p><span class="math display">\[
f_{l,r}\ =\
\sum_{i=l}^{q_p}\sum_{j=q_p}^rf_{l,i-1}f_{i,q_p-1}f_{q_p+1,j}f_{j+1,r}
\]</span></p>
<p>当 <span class="math inline">\(l\ge r\)</span> 的 <span class="math inline">\(f_{l,r}=1\)</span></p>
<p>观察上式，<span class="math inline">\(i\)</span> 和 <span class="math inline">\(j\)</span> 的枚举相互独立，可以优化为 <span class="math inline">\(O(n^3)\)</span></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> int64;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">int</span> f = <span class="number">1</span>, <span class="keyword">int</span> x = <span class="number">0</span>, <span class="keyword">char</span> ch = <span class="string">&#x27; &#x27;</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">isdigit</span>(ch = getchar())) <span class="keyword">if</span>(ch == <span class="string">&#x27;-&#x27;</span>) f = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch)) x = x*<span class="number">10</span>+ch-<span class="string">&#x27;0&#x27;</span>, ch = getchar();</span><br><span class="line">    <span class="keyword">return</span> f*x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">5e2</span>+<span class="number">5</span>, P = <span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, p[N], q[N];</span><br><span class="line">int64 f[N][N];</span><br><span class="line"><span class="keyword">int</span> g[N][N];</span><br><span class="line"><span class="function">int64 <span class="title">dp</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    int64 &amp;ret = f[l][r];</span><br><span class="line">    <span class="keyword">if</span>(ret) <span class="keyword">return</span> ret;</span><br><span class="line">    <span class="keyword">if</span>(l &gt;= r) ret = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> x = g[l][r];</span><br><span class="line">        int64 fl = <span class="number">0</span>, fr = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = l; i &lt;= q[x]; ++i) fl = (fl+dp(l, i<span class="number">-1</span>)*dp(i, q[x]<span class="number">-1</span>)%P)%P;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = q[x]; i &lt;= r; ++i) fr = (fr+dp(q[x]+<span class="number">1</span>, i)*dp(i+<span class="number">1</span>, r)%P)%P;</span><br><span class="line">        ret = fl*fr%P;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n = read(), m = read();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) p[i] = read(), q[p[i]] = i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> l = <span class="number">1</span>; l &lt;= n; ++l)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> r = l; r &lt;= n; ++r)</span><br><span class="line">            g[l][r] = min(p[r], g[l][r<span class="number">-1</span>]?g[l][r<span class="number">-1</span>]:n);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, dp(<span class="number">1</span>, n));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>组合计数</tag>
      </tags>
  </entry>
  <entry>
    <title>肯定学不会的多项式基础操作</title>
    <url>/2019/07/27/%E8%82%AF%E5%AE%9A%E5%AD%A6%E4%B8%8D%E4%BC%9A%E7%9A%84%E5%A4%9A%E9%A1%B9%E5%BC%8F%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<p><del>终于颓废了一天把多项式写的好看了</del></p>
<p>本文主要是一个模板库，对多项式进行了封装</p>
<h2 id="基础约定">基础约定</h2>
<p>在本文中，多项式的相关运算里面，只说次数不说项数，次数表述较灵活，但如果涉及多项式取模，通常以
<span class="math inline">\(ti\)</span> 表示一个多项式的次数，<span class="math inline">\(n\)</span> 表示这个多项式的是在模 <span class="math inline">\(x^n\)</span>
有意义，其中除多项式加减乘转置以外，其他或多或少都有多项式取模存在，其中包括多项式求导和多项式积分
<a id="more"></a>
在本文中，代码里面的多项式为大写，推导过程的多项式通常为小写，参数的多项式以
<code>A</code> 和 <code>B</code> 为主，其他以 <code>F</code> 和
<code>G</code> 为主</p>
<p>在本文中，的多项式离散变换为 <code>NTT</code>，<code>NTT</code>
模数为 <code>998244353</code> 原根为 <code>3</code></p>
<p>在本文中，所有多项式运算需要用到的自然数逆元已被预处理在
<code>inv</code> 数组里</p>
<p>在本文中，对于加减乘模运算以外的其他运算，会先给出数学证明</p>
<p>在本文中，多项式的次数包含零系数</p>
<h2 id="poly-类-与-加减运算">Poly 类 与 加减运算</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Poly</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; _;</span><br><span class="line">    <span class="keyword">inline</span> <span class="keyword">int</span>&amp; <span class="keyword">operator</span> [] (<span class="keyword">int</span> i) &#123; <span class="keyword">return</span> _[i]; &#125; </span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">ti</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> _.size()<span class="number">-1</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> ti)</span> </span>&#123; <span class="keyword">return</span> _.resize(ti+<span class="number">1</span>); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">rev</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> reverse(_.begin(), _.end()); &#125;</span><br><span class="line">&#125;;</span><br><span class="line">Poly <span class="keyword">operator</span> - (Poly A, Poly B)</span><br><span class="line">&#123;</span><br><span class="line">    A.<span class="built_in">set</span>(max(A.ti(), B.ti()));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = B.ti(); ~i; --i) A[i] = A[i]-B[i]&lt;<span class="number">0</span>?A[i]-B[i]+P:A[i]-B[i];</span><br><span class="line">    <span class="keyword">return</span> A;</span><br><span class="line">&#125;</span><br><span class="line">Poly <span class="keyword">operator</span> + (Poly A, Poly B)</span><br><span class="line">&#123;</span><br><span class="line">    A.<span class="built_in">set</span>(max(A.ti(), B.ti()));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = B.ti(); ~i; --i) A[i] = A[i]+B[i]&lt;P?A[i]+B[i]:A[i]+B[i]-P;</span><br><span class="line">    <span class="keyword">return</span> A;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>假设已声明 <code>Poly</code> 类变量 <code>F</code> 和
<code>G</code></p>
<p><code>F[i]</code>：返回 <code>F._[i]</code> 的值，并且支持直接对
<code>F._[i]</code> 的修改，需要注意保证你访问的下标不超过当前
<code>F</code> 的次数</p>
<p><code>F.ti()</code>：返回 <code>F</code> 的次数</p>
<p><code>F.set(ti)</code>：重新设置 <code>F</code> 的次数，若
<code>ti</code> 小于当前次数则多余部分舍弃，大于则不足部分补
<code>0</code></p>
<p><code>F.rev()</code>：将 <code>F</code> 转置，即 <code>F[i]</code>
变为 <code>F[n-i]</code></p>
<p><code>F+G</code>：返回 <code>F</code> 与 <code>G</code>
的和，新的多项式的次数为两者中的较大值</p>
<p><code>F-G</code>：返回 <code>F</code> 与 <code>G</code>
的差，新的多项式的次数为两者中的较大值</p>
<h2 id="多项式离散变化">多项式离散变化</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">int64 w[<span class="number">2</span>][N&lt;&lt;<span class="number">2</span>], inv[N&lt;&lt;<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> lim;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">prepare</span><span class="params">(<span class="keyword">int</span> ti)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(lim = <span class="number">1</span>; lim &lt;= ti; lim &lt;&lt;= <span class="number">1</span>);</span><br><span class="line">    w[<span class="number">0</span>][<span class="number">0</span>] = w[<span class="number">0</span>][lim] = w[<span class="number">1</span>][<span class="number">0</span>] = w[<span class="number">1</span>][lim] = <span class="number">1</span>;</span><br><span class="line">    int64 g = qpow(<span class="number">3</span>, (P<span class="number">-1</span>)/lim);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; lim; ++i)</span><br><span class="line">        w[<span class="number">1</span>][lim-i] = w[<span class="number">0</span>][i] = w[<span class="number">0</span>][i<span class="number">-1</span>]*g%P; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">NTT</span><span class="params">(Poly &amp;A, <span class="keyword">int</span> t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!t) A.<span class="built_in">set</span>(lim<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; lim; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(i &gt; j) A[i] ^= A[j] ^= A[i] ^= A[j];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = lim&gt;&gt;<span class="number">1</span>; (j ^= k) &lt; k; k &gt;&gt;= <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> mid = <span class="number">1</span>; mid &lt; lim; mid &lt;&lt;= <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> len = mid&lt;&lt;<span class="number">1</span>, j = <span class="number">0</span>; j &lt; lim; j += len)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>, p = <span class="number">0</span>, q = lim/len; k &lt; mid; ++k, p += q)</span><br><span class="line">            &#123;</span><br><span class="line">                int64 x = A[j+k], y = A[j+k+mid]*w[t][p]%P;</span><br><span class="line">                A[j+k] = x+y&lt;P?x+y:x+y-P;</span><br><span class="line">                A[j+k+mid] = x-y&lt;<span class="number">0</span>?x-y+P:x-y;</span><br><span class="line">            &#125;</span><br><span class="line">    <span class="keyword">if</span>(!t) <span class="keyword">return</span>; int64 v = inv[lim];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lim; ++i) A[i] = A[i]*v%P;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>prepare(ti)</code>：对即将变换的 <code>ti</code>
次多项式<strong>项数</strong>扩展为后继 <code>2</code> 的整数次幂
<code>lim</code> ，并且对即将使用的单位根进行预处理，其中
<code>w[0][i]</code> 访问到的是 <span class="math inline">\(3^{\frac{P-1}{lim}i}\)</span>，而
<code>w[1][i]</code>
访问到的是其逆元，两者关系可以由欧拉定理得出互为转置</p>
<p>假设已声明 <code>Poly</code> 类变量 <code>F</code></p>
<p><code>NTT(F, t)</code>：当 <code>t</code> 为 <code>0</code> 时，进行
<code>NTT</code>，这时需要一开始将 <code>F</code> 的次数设置为
<code>lim-1</code>；当 <code>t</code> 为 <code>1</code> 时，进行
<code>INTT</code>；此外在交换下标阶段省略 <code>rev</code>
数组，改用异或模拟加法，均摊 <code>O(n)</code>， <code>NTT</code>
的过程中通过累加循环变量 <code>p</code>，代替 <code>lim/len*k</code>
意外优化了很大的常数</p>
<h2 id="多项式乘运算"><a href="https://www.luogu.org/problem/P3803">多项式乘运算</a></h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Poly <span class="keyword">operator</span> * (Poly A, Poly B)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> n = A.ti(), m = B.ti();</span><br><span class="line">    <span class="keyword">if</span>(n &lt;= <span class="number">128</span>||m &lt;= <span class="number">128</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Poly C; C.<span class="built_in">set</span>(n+m);</span><br><span class="line">        <span class="keyword">int</span> *c = &amp;C[<span class="number">0</span>], *a = &amp;A[<span class="number">0</span>], *b = &amp;B[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> *f = c+i; int64 x = a[i];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= m; ++j)</span><br><span class="line">                f[j] = (f[j]+x*b[j]%P)%P;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> C;</span><br><span class="line">    &#125;</span><br><span class="line">    prepare(n+m), NTT(A, <span class="number">0</span>), NTT(B, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lim; ++i) A[i] = <span class="number">1l</span>l*A[i]*B[i]%P;</span><br><span class="line">    NTT(A, <span class="number">1</span>), A.<span class="built_in">set</span>(n+m);</span><br><span class="line">    <span class="keyword">return</span> A;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>假设已声明 <code>Poly</code> 类变量 <code>F</code> 和
<code>G</code></p>
<p><code>F*G</code>：返回 <code>F</code> 与 <code>G</code>
的积，新的多项式的次数为两者次数之和，其中 <code>F</code> 与
<code>G</code> 次数较小是采取朴素做法优化常数</p>
<h2 id="多项式求逆"><a href="https://www.luogu.org/problem/P4238">多项式求逆</a></h2>
<p>给定多项式 <span class="math inline">\(f\)</span> 我们要求出 <span class="math inline">\(g\)</span> 满足 <span class="math display">\[
f\times g\equiv 1\ mod\ x^n
\]</span></p>
<p>考虑倍增，假设我们已求出 <span class="math display">\[
f\times g_{i-1}\equiv 1\ mod\ x^{\lceil\frac{n}{2}\rceil}
\]</span> 现在要求出 <span class="math display">\[
f\times g_i\equiv 1\ mod\ x^n
\]</span> 显然 <span class="math display">\[
f\times g_i\equiv 1\ mod\ x^{\lceil\frac{n}{2}\rceil}
\]</span> 所以 <span class="math display">\[
g_i-g_{i-1}\equiv 0\ mod\ x^{\lceil\frac{n}{2}\rceil}
\]</span> <span class="math display">\[
(g_i-g_{i-1})^2\equiv 0\ mod\ x^n
\]</span> <span class="math display">\[
f(g_i^2-2g_ig_{i-1}+g_{i-1}^2)\equiv 0\ mod\ x^n
\]</span> 得到 <span class="math display">\[
g_i\equiv 2g_{i-1}-fg_{i-1}^2\ mod\ x^n
\]</span> 倍增求解即可</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">Poly <span class="title">polyInv</span><span class="params">(Poly A, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Poly B; A.<span class="built_in">set</span>(n<span class="number">-1</span>), B.<span class="built_in">set</span>(n<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">1</span>) <span class="keyword">return</span> B[<span class="number">0</span>] = qpow(A[<span class="number">0</span>], P<span class="number">-2</span>), B;</span><br><span class="line">    B = polyInv(A, (n+<span class="number">1</span>)&gt;&gt;<span class="number">1</span>), prepare(n&lt;&lt;<span class="number">1</span>);</span><br><span class="line">    NTT(A, <span class="number">0</span>), NTT(B, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lim; ++i) B[i] = (<span class="number">2l</span>l<span class="number">-1l</span>l*B[i]*A[i]%P+P)%P*B[i]%P;</span><br><span class="line">    NTT(B, <span class="number">1</span>), B.<span class="built_in">set</span>(n<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">return</span> B;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>假设已声明 <code>Poly</code> 类变量 <code>F</code></p>
<p><code>polyInv(F, n)</code>：返回 <code>F</code>
在模意义下的逆元，需注意，<strong>每次 <code>A</code>
在运算时同样也需要先取模</strong></p>
<h2 id="多项式带余除法"><a href="https://www.luogu.org/problem/P4512">多项式带余除法</a></h2>
<p>给定 <span class="math inline">\(n\)</span> 次多项式 <span class="math inline">\(f\)</span> 和 <span class="math inline">\(m\)</span> 次多项式 <span class="math inline">\(g\)</span> 求出 <span class="math inline">\(n-m\)</span> 多项式 <span class="math inline">\(q\)</span> 和 <span class="math inline">\(m-1\)</span> 次多项式 <span class="math inline">\(r\)</span>，满足</p>
<p><span class="math display">\[
f\ =\ q\times g+r
\]</span></p>
<p>将式子代换成</p>
<p><span class="math display">\[
x^nf(\frac{1}{x})\ =\ x^{n-m}q(\frac{1}{x})\times
x^{m}g(\frac{1}{x})+x^{n-m+1}x^{m-1}r(\frac{1}{x})
\]</span></p>
<p>考虑 <span class="math inline">\(f\)</span> 的转置多项式 <span class="math inline">\(f_r\)</span> 满足 <span class="math inline">\([x^i]\ f_r\ =\ [x^{n-i}]\ f\)</span>
的另外一种表述为 <span class="math inline">\(f_r\ =\ x^n\
f(\frac{1}{x})\)</span></p>
<p><span class="math display">\[
f_r\ =\ q_r\times g_r+x^{n-m+1}r_r
\]</span></p>
<p>发现在模 <span class="math inline">\(x^{n-m+1}\)</span>
的意义下余项的转置被消去，则有</p>
<p><span class="math display">\[
f_r\ =\ q_r\times g_r\ mod\ x^{n-m+1}
\]</span></p>
<p>所以</p>
<p><span class="math display">\[
q_r\ =\ f_r\times g_r^{-1}\ mod\ x^{n-m+1}
\]</span></p>
<p>求出 <span class="math inline">\(q\)</span> 之后 <span class="math inline">\(r\)</span> 就很容易求出</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Poly <span class="keyword">operator</span> / (Poly A, Poly B)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(A.ti() &lt; B.ti()) <span class="keyword">return</span> A.<span class="built_in">set</span>(<span class="number">0</span>), A;</span><br><span class="line">    <span class="keyword">int</span> n = A.ti(), m = B.ti(); </span><br><span class="line">    A.rev(), B.rev();</span><br><span class="line">    A = A*polyInv(B, n-m+<span class="number">1</span>), A.<span class="built_in">set</span>(n-m), A.rev();</span><br><span class="line">    <span class="keyword">return</span> A;</span><br><span class="line">&#125;</span><br><span class="line">Poly <span class="keyword">operator</span> % (Poly A, Poly B)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(A.ti() &lt; B.ti()) <span class="keyword">return</span> A;</span><br><span class="line">    A = A-(A/B)*B; A.<span class="built_in">set</span>(B.ti()<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">return</span> A;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>F/G</code>：返回 <code>F</code> 与 <code>G</code>
的商，新的多项式的次数为两者中的较大值</p>
<p><code>F-G</code>：返回 <code>F</code> 与 <code>G</code>
的yu，新的多项式的次数为两者中的较大值</p>
<h2 id="多项式求导和积分">多项式求导和积分</h2>
<p>给定多项式 <span class="math inline">\(f\)</span> 我们要求出 <span class="math inline">\(g\)</span> 和 <span class="math inline">\(h\)</span> 满足 <span class="math display">\[
g\equiv f&#39;\ mod\ x^n
\]</span> <span class="math display">\[
h\equiv \int f dx\ mod\ x^n
\]</span></p>
<p>由幂函数求导法则 <span class="math inline">\(x^n\to nx^{n-1}\)</span>
和求导四则运算得</p>
<p><span class="math display">\[
[x^n]\ g\ =\ [x^{n+1}]\ f\times n
\]</span></p>
<p>由微分和积分互为逆运算得到</p>
<p><span class="math display">\[
[x^n]\ h\ =\ [x^{n-1}]\ f\times \frac{1}{n}
\]</span></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">Poly <span class="title">polyDer</span><span class="params">(Poly A, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A.<span class="built_in">set</span>(n<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n<span class="number">-1</span>; ++i) A[i] = <span class="number">1l</span>l*(i+<span class="number">1</span>)*A[i+<span class="number">1</span>]%P; A[n<span class="number">-1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> A;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Poly <span class="title">polyInte</span><span class="params">(Poly A, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A.<span class="built_in">set</span>(n<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = n<span class="number">-1</span>; i; --i) A[i] = inv[i]*A[i<span class="number">-1</span>]%P; A[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> A;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>假设已声明 <code>Poly</code> 类变量 <code>F</code></p>
<p><code>polyDer(F, n)</code>：返回 <code>F</code>
在模意义下的导数，其次数由模数决定，特别地，只需要正常求导时，<code>n</code>
应该为 <code>F.ti()+1</code>，返回的仍是 <code>F.ti()</code>
次多项式</p>
<p><code>polyInte(F, n)</code>：返回 <code>F</code>
在模意义下的积分，其次数由模数决定，特别地，只需要正常积分时，<code>n</code>
应该为 <code>F.ti()+2</code>，返回的是 <code>F.ti()+1</code>
次多项式</p>
<h2 id="多项式对数函数"><a href="https://www.luogu.org/problem/P4238">多项式对数函数</a></h2>
<p>给定多项式 <span class="math inline">\(f\)</span> 我们要求出 <span class="math inline">\(g\)</span> 满足 <span class="math display">\[
g\equiv ln\ f\ mod\ x^n
\]</span></p>
<p>两边同时求导再积回来就好了</p>
<p><span class="math display">\[
g\equiv \int\frac{f&#39;}{f}dx\ mod\ x^n
\]</span></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">Poly <span class="title">polyLn</span><span class="params">(Poly A, <span class="keyword">int</span> n)</span> </span>&#123; <span class="keyword">return</span> polyInte(polyDer(A, n)*polyInv(A, n), n); &#125;</span><br></pre></td></tr></table></figure>
<p>假设已声明 <code>Poly</code> 类变量 <code>F</code></p>
<p><code>polyLn(F, n)</code>：返回 <code>F</code>
在模意义下的自然对数，其次数由模数决定</p>
<h2 id="多项式指数函数-牛顿迭代"><a href="https://www.luogu.org/problem/P4726">多项式指数函数
(牛顿迭代)</a></h2>
<p>给定多项式 <span class="math inline">\(f\)</span> 我们要求出 <span class="math inline">\(g\)</span> 满足 <span class="math display">\[
g\equiv e^f\ mod\ x^n
\]</span></p>
<p>首先，我们把牛顿迭代推广到多项式中，考虑</p>
<p>给定多项式 <span class="math inline">\(f\)</span> 我们要求出 <span class="math inline">\(g\)</span> 满足 <span class="math display">\[
f(g)\equiv 0\ mod\ x^n
\]</span></p>
<p>那么就有</p>
<p><span class="math display">\[
g_i\equiv g_{i-1}-\frac{f(g_{i-1})}{f&#39;(g_{i-1})}\ mod\ x^n
\]</span></p>
<p>倍增迭代即可</p>
<p>另外，注意求导是 <span class="math inline">\(g\)</span> 关于 <span class="math inline">\(f\)</span> 求导，而不是 <span class="math inline">\(x\)</span> 关于 <span class="math inline">\(f\)</span> 求导</p>
<p>在这指数函数中两边取对数移项得</p>
<p><span class="math display">\[
ln\ g - f\equiv 0\ mod\ x^n
\]</span></p>
<p>不妨把左侧看作关于 <span class="math inline">\(g\)</span>
得函数，那么我们实际上就是求出该多项式得零点，带入牛顿迭代式得</p>
<p><span class="math display">\[
g_i\equiv g_{i-1}(1-ln\ g_{i-1}+f)\ mod\ x^n
\]</span></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">Poly <span class="title">polyExp</span><span class="params">(Poly A, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Poly B; B.<span class="built_in">set</span>(n<span class="number">-1</span>), A.<span class="built_in">set</span>(n<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">1</span>) <span class="keyword">return</span> B[<span class="number">0</span>] = <span class="number">1</span>, B;</span><br><span class="line">    B = polyExp(A, (n+<span class="number">1</span>)&gt;&gt;<span class="number">1</span>), B.<span class="built_in">set</span>(n<span class="number">-1</span>), ++A[<span class="number">0</span>];</span><br><span class="line">    B = B*(A-polyLn(B, n)); B.<span class="built_in">set</span>(n<span class="number">-1</span>); </span><br><span class="line">    <span class="keyword">return</span> B;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>假设已声明 <code>Poly</code> 类变量 <code>F</code></p>
<p><code>polyLn(F, n)</code>：返回 <code>F</code> 在模意义下的
<code>Exp</code> ，其次数由模数决定</p>
]]></content>
      <categories>
        <category>模板</category>
      </categories>
      <tags>
        <tag>多项式</tag>
      </tags>
  </entry>
  <entry>
    <title>72709102 AGC005</title>
    <url>/2019/07/27/72709102-AGC005/</url>
    <content><![CDATA[<h2 id="k-perm-counting"><a href="https://www.luogu.org/problem/AT2062">~K Perm Counting</a></h2>
<blockquote>
<p>如果一个排列 <span class="math inline">\(P\)</span>
满足对于所有的i都有 <span class="math inline">\(|p_i-i|\ne
k\)</span>，则称排列P为合法的，求合法排列数</p>
</blockquote>
<p>考虑错排问题就是 <span class="math inline">\(k\ = 0\)</span>
的特殊情况，这道题用同样做法来做，设 <span class="math inline">\(f_i\)</span> 为恰好有 <span class="math inline">\(i\)</span> 个满足 <span class="math inline">\(|p_i-i|\ne k\)</span> 的方案数，<span class="math inline">\(g_i\)</span> 为至少有 <span class="math inline">\(i\)</span> 个满足 <span class="math inline">\(|p_i-i|\ne k\)</span> 的方案数，则有</p>
<p><span class="math display">\[
g_i\ =\ \sum_{i\le j}f_j
\]</span> <a id="more"></a> 根据广义容斥</p>
<p><span class="math display">\[
f_i\ =\ \sum_{i\le j}(-1)^{j-i}g_j
\]</span></p>
<p>考虑如何求出 <span class="math inline">\(g_i\)</span>，我们利用下标和键值的关系不难看出这是一个二分图匹配问题，那么问题就转化为在一个二分图中选出
<span class="math inline">\(i\)</span>
条匹配边的方案数，注意到每个点的度数不超过 <span class="math inline">\(2\)</span>，我们可以把这些链抽出来并在一起，不妨设
<span class="math inline">\(h_{i,j,k}\)</span> 表示前 <span class="math inline">\(i\)</span> 个点选出 <span class="math inline">\(j\)</span> 条匹配边，第 <span class="math inline">\(i\)</span> 个点与前一个点连边状态为 <span class="math inline">\(k\)</span>
时的的方案数，转移很简单，不多赘述，最后答案即为 <span class="math inline">\(g_i\ =\ (h_{2n,i,0}+h_{2n,i,1})(n-i)!\)</span></p>
<p>关于解决二分图匹配问题很具有启发性，说不定下次会碰见一道题满足树的特殊性质的二分图匹配</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">int</span> f = <span class="number">1</span>, <span class="keyword">int</span> x = <span class="number">0</span>, <span class="keyword">char</span> ch = <span class="string">&#x27; &#x27;</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">isdigit</span>(ch = getchar())) <span class="keyword">if</span>(ch == <span class="string">&#x27;-&#x27;</span>) f = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch)) x = x*<span class="number">10</span>+ch-<span class="string">&#x27;0&#x27;</span>, ch = getchar();</span><br><span class="line">    <span class="keyword">return</span> f*x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">4e3</span>+<span class="number">5</span>, P = <span class="number">924844033</span>;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> cut[N], h[N][N][<span class="number">2</span>], g[N], f[N], fac[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n = read(), m = read(); fac[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) fac[i] = <span class="number">1l</span>l*fac[i<span class="number">-1</span>]*i%P;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>, p = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        cut[p] = <span class="number">1</span>; p += (n-i)/m+<span class="number">1</span>;</span><br><span class="line">        cut[p] = <span class="number">1</span>; p += (n-i)/m+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n&lt;&lt;<span class="number">1</span>; ++i) h[i][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n&lt;&lt;<span class="number">1</span>; ++i)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            h[i][j][<span class="number">0</span>] = (h[i<span class="number">-1</span>][j][<span class="number">0</span>]+h[i<span class="number">-1</span>][j][<span class="number">1</span>])%P;</span><br><span class="line">            <span class="keyword">if</span>(!cut[i]) h[i][j][<span class="number">1</span>] = h[i<span class="number">-1</span>][j<span class="number">-1</span>][<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; ++i) g[i] = <span class="number">1l</span>l*(h[n&lt;&lt;<span class="number">1</span>][i][<span class="number">0</span>]+h[n&lt;&lt;<span class="number">1</span>][i][<span class="number">1</span>])*fac[n-i]%P;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>, w = <span class="number">1</span>; i &lt;= n; ++i, w = P-w) f[<span class="number">0</span>] = (f[<span class="number">0</span>]+<span class="number">1l</span>l*w*g[i]%P)%P; </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, f[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="sugigma-the-showdown"><a href="https://www.luogu.org/problem/AT2063">Sugigma: The
Showdown</a></h2>
<blockquote>
<p>给定两棵树和起点，两人分别在两棵树上交替移动，相遇后游戏结束，现在
<span class="math inline">\(A\)</span> 想最大化游戏轮数，<span class="math inline">\(B\)</span> 想最小化游戏轮数，求游戏轮数</p>
</blockquote>
<p>很明显，最终如果游戏不能无限进行则 <span class="math inline">\(A\)</span> 会最终不移动，那么问题关键就是求出
<span class="math inline">\(A\)</span>
能移动到点集，我们发现有个很明显的充分条件是起点到这些点的经过点到 <span class="math inline">\(A\)</span> 的距离小于 <span class="math inline">\(B\)</span>
到这些点的距离，通过搜索判断可达性即可</p>
<p>如果游戏可以无限进行，则 <span class="math inline">\(A\)</span>
一定可以达到一条边 <span class="math inline">\((u,\ v)\)</span> 满足在
<span class="math inline">\(B\)</span> 上 <span class="math inline">\(d_{u,v}&gt;2\)</span>，达到这条边后左右跳即可</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">int</span> f = <span class="number">1</span>, <span class="keyword">int</span> x = <span class="number">0</span>, <span class="keyword">char</span> ch = <span class="string">&#x27; &#x27;</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">isdigit</span>(ch = getchar())) <span class="keyword">if</span>(ch == <span class="string">&#x27;-&#x27;</span>) f = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch)) x = x*<span class="number">10</span>+ch-<span class="string">&#x27;0&#x27;</span>, ch = getchar();</span><br><span class="line">    <span class="keyword">return</span> f*x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> next, to;</span><br><span class="line">    Edge(<span class="keyword">int</span> next = <span class="number">0</span>, <span class="keyword">int</span> to = <span class="number">0</span>):next(next), to(to) &#123;&#125;;</span><br><span class="line">&#125;edge[N&lt;&lt;<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> ha[N], hb[N], tot;</span><br><span class="line"><span class="keyword">void</span> _add(<span class="keyword">int</span> *h, <span class="keyword">int</span> x, <span class="keyword">int</span> y) &#123; edge[++tot] = Edge(h[x], y); h[x] = tot; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> *h, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123; _add(h, x, y); _add(h, y, x); &#125;</span><br><span class="line"><span class="keyword">int</span> fa[N], son[N], size[N], top[N], d[N];</span><br><span class="line"><span class="keyword">int</span> ans, cir;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    size[x] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = hb[x]; i; i = edge[i].next)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> y = edge[i].to; <span class="keyword">if</span>(y == fa[x]) <span class="keyword">continue</span>;</span><br><span class="line">        d[y] = d[x]+<span class="number">1</span>, fa[y] = x, dfs(y), </span><br><span class="line">        size[x] += size[y], son[x] = size[son[x]]&gt;size[y]?son[x]:y; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lca</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(top[x] != top[y])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(d[top[x]] &lt; d[top[y]]) swap(x, y);</span><br><span class="line">        x = fa[top[x]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> d[x]&lt;d[y]?x:y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dis</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123; <span class="keyword">return</span> d[x]+d[y]<span class="number">-2</span>*d[lca(x, y)]; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> topf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    top[x] = topf; <span class="keyword">if</span>(son[x]) dfs(son[x], topf);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = hb[x]; i; i = edge[i].next)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> y = edge[i].to; </span><br><span class="line">        <span class="keyword">if</span>(y != fa[x]&amp;&amp;y != son[x]) dfs(y, y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">escape</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa, <span class="keyword">int</span> dep)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ans = max(ans, d[x]&lt;&lt;<span class="number">1</span>); </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = ha[x]; i; i = edge[i].next)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> y = edge[i].to; </span><br><span class="line">        <span class="keyword">if</span>(dis(x, y) &gt; <span class="number">2</span>) cir = <span class="number">1</span>;    </span><br><span class="line">        <span class="keyword">if</span>(y == fa||dep+<span class="number">1</span> &gt;= d[y]) <span class="keyword">continue</span>;</span><br><span class="line">        escape(y, x, dep+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n, a, b;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n = read(), a = read(), b = read();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> x = read(), y = read();</span><br><span class="line">        add(ha, x, y);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> x = read(), y = read();</span><br><span class="line">        add(hb, x, y);</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(b); dfs(b, b); escape(a, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, cir?<span class="number">-1</span>:ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="many-easy-problems"><a href="https://www.luogu.org/problem/AT2064">Many Easy Problems</a></h2>
<blockquote>
<p>给定一棵无根树，定义 <span class="math inline">\(f(i)\)</span>，对于所有大小为 <span class="math inline">\(i\)</span>
的点集，求出能够包含它的最小连通块大小之和。对于 <span class="math inline">\(i=1 \to n\)</span> 的所有 <span class="math inline">\(i\)</span>，求出 <span class="math inline">\(f(i)\)</span></p>
</blockquote>
<p>想这道题的过程收获挺多的，首先这道题问的点集，按照套路就是思考每个点对于
<span class="math inline">\(f(i)\)</span>
的贡献，但没想出来，所以看到联通块，又想到 <span class="math inline">\(dfs\)</span>
序与联通块的联系，得到一个的做法，简单来说就是枚举每个点对，考虑点对在
<span class="math inline">\(dfs\)</span>
序的子序列的位置用组合数算下贡献就好了，这个思路想到 <span class="math inline">\(O(n^3)\)</span> 就想不下去了</p>
<p>再考虑每个点的贡献，其实很好算，设 <span class="math inline">\(s_i\)</span> 为定根后节点 <span class="math inline">\(i\)</span> 的子树大小，考虑节点 <span class="math inline">\(i\)</span> 会被多少个点集算到，得到</p>
<p><span class="math display">\[
f(k)\ =\ \sum_{i=1}^n\binom{n}{k}-\binom{n-s_i}{k}-\sum_{j\in
son_i}\binom{s_j}{k}
\]</span></p>
<p>化简得到</p>
<p><span class="math display">\[
f(k)\ =\ n\binom{n}{k}-\sum_{i=2}^n\binom{n-s_i}{k}+\binom{s_i}{k}
\]</span></p>
<p>主要问题是求出后面的式子，设它的生成函数为 <span class="math inline">\(h\)</span> 则有</p>
<p><span class="math display">\[
h\ =\ \sum_{k}\sum_{i=2}^n[\binom{n-s_i}{k}+\binom{s_i}{k}]x^k
\]</span></p>
<p>这时候我就被降智了，考虑交换求和序，有</p>
<p><span class="math display">\[
\begin{aligned}
h\ &amp;=\ \sum_{i=2}^n\sum_{k}\binom{n-s_i}{k}x^k+\binom{s_i}{k}x^k\\\\
&amp;=\ \sum_{i=2}^n(1+x)^{s_i}+(1+x)^{n-s_i}
\end{aligned}
\]</span></p>
<p>开一个桶 <span class="math inline">\(c\)</span>
记录一下相同的指数，则</p>
<p><span class="math display">\[
h\ =\ \sum_{i=0}^nc_i(1+x)^i
\]</span></p>
<p>这不就是一个裸的多项式复合函数吗，结果一看多项式复合函数的复杂度，<del>溜了，溜了</del></p>
<p>接着我发现这就是多项式的平移吗，那就求值完平移再插回去就好了呀，学了半天求值和插值，一发交上去只拿了暴力分</p>
<p>稍微优化一下，改用原根求值，最后直接 <span class="math inline">\(INTT\)</span> 即可，还是只拿了暴力分</p>
<p>翻了具体数学提高知识水平，发现下降幂可做，但求下降幂又要多点求值<del>自闭</del></p>
<p>最后重新看这个式子，好像就是一个裸的卷积</p>
<p><span class="math display">\[
\begin{aligned}
h\ &amp;=\ \sum_{k}\sum_{i=0}^nc_i\binom{i}{k}x^k\\\\
&amp;=\ \sum_{k}\frac{1}{k!}\sum_{i=0}^n(c_i\times
i!)(\frac{1}{(i-k)!})x^k
\end{aligned}
\]</span></p>
<p>后面稍微转置一下就是卷积了</p>
<p>同时，我们惊喜地发现多项式线性变换同样是一个简单的卷积</p>
<p>常数巨大的 <span class="math inline">\(AC\)</span> 代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> int64;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">int</span> f = <span class="number">1</span>, <span class="keyword">int</span> x = <span class="number">0</span>, <span class="keyword">char</span> ch = <span class="string">&#x27; &#x27;</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">isdigit</span>(ch = getchar())) <span class="keyword">if</span>(ch == <span class="string">&#x27;-&#x27;</span>) f = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch)) x = x*<span class="number">10</span>+ch-<span class="string">&#x27;0&#x27;</span>, ch = getchar();</span><br><span class="line">    <span class="keyword">return</span> f*x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span>+<span class="number">5</span>, P = <span class="number">924844033</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> next, to;</span><br><span class="line">    Edge(<span class="keyword">int</span> next = <span class="number">0</span>, <span class="keyword">int</span> to = <span class="number">0</span>):next(next), to(to) &#123;&#125;; </span><br><span class="line">&#125;edge[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> tot, head[N];</span><br><span class="line"><span class="keyword">void</span> _add(<span class="keyword">int</span> x, <span class="keyword">int</span> y) &#123; edge[++tot] = Edge(head[x], y); head[x] = tot; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123; _add(x, y), _add(y, x); &#125;</span><br><span class="line"><span class="keyword">int</span> n, s[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    s[x] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = head[x]; i; i = edge[i].next)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> y = edge[i].to; <span class="keyword">if</span>(y == fa) <span class="keyword">continue</span>;</span><br><span class="line">        dfs(y, x); s[x] += s[y];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">int64 <span class="title">qpow</span><span class="params">(int64 a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    int64 ret = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>( ; b; b &gt;&gt;= <span class="number">1</span>, a = a*a%P) <span class="keyword">if</span>(b&amp;<span class="number">1</span>) ret = a*ret%P;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line">int64 fac[N], inv[N&lt;&lt;<span class="number">2</span>], ifac[N];</span><br><span class="line"><span class="function">int64 <span class="title">C</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123; <span class="keyword">return</span> n &lt; m?<span class="number">0</span>:fac[n]*ifac[m]%P*ifac[n-m]%P; &#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Poly</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; _;</span><br><span class="line">    <span class="keyword">inline</span> <span class="keyword">int</span>&amp; <span class="keyword">operator</span> [] (<span class="keyword">int</span> i) &#123; <span class="keyword">return</span> _[i]; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">ti</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> _.size()<span class="number">-1</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> ti)</span> </span>&#123; _.resize(ti+<span class="number">1</span>); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">rev</span><span class="params">()</span> </span>&#123; reverse(_.begin(), _.end()); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">int</span> lim;</span><br><span class="line">int64 w[<span class="number">2</span>][N&lt;&lt;<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">prepare</span><span class="params">(<span class="keyword">int</span> ti)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(lim = <span class="number">1</span>; lim &lt;= ti; lim &lt;&lt;= <span class="number">1</span>);</span><br><span class="line">    w[<span class="number">0</span>][<span class="number">0</span>] = w[<span class="number">1</span>][<span class="number">0</span>] = w[<span class="number">0</span>][lim] = w[<span class="number">1</span>][lim] = <span class="number">1</span>;</span><br><span class="line">    int64 g = qpow(<span class="number">5</span>, (P<span class="number">-1</span>)/lim);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; lim; ++i) w[<span class="number">1</span>][lim-i] = w[<span class="number">0</span>][i] = w[<span class="number">0</span>][i<span class="number">-1</span>]*g%P;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">NTT</span><span class="params">(Poly &amp;A, <span class="keyword">int</span> t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!t) A.<span class="built_in">set</span>(lim<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; lim; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(i &gt; j) A[i] ^= A[j] ^= A[i] ^= A[j];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = lim&gt;&gt;<span class="number">1</span>; (j ^= k) &lt; k; k &gt;&gt;= <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> mid = <span class="number">1</span>; mid &lt; lim; mid &lt;&lt;= <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> len = mid&lt;&lt;<span class="number">1</span>, j = <span class="number">0</span>; j &lt; lim; j += len)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>, p = <span class="number">0</span>, q = lim/len; k &lt; mid; ++k, p += q)</span><br><span class="line">            &#123;</span><br><span class="line">                int64 x = A[j+k], y = w[t][p]*A[j+k+mid]%P;</span><br><span class="line">                A[j+k] = x+y&lt;P?x+y:x+y-P;</span><br><span class="line">                A[j+k+mid] = x-y&lt;<span class="number">0</span>?x-y+P:x-y;</span><br><span class="line">            &#125;</span><br><span class="line">    <span class="keyword">if</span>(!t) <span class="keyword">return</span>; int64 v = inv[lim];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lim; ++i) A[i] = A[i]*v%P;</span><br><span class="line">&#125;</span><br><span class="line">Poly <span class="keyword">operator</span> * (Poly A, Poly B)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> n = A.ti(), m = B.ti(); </span><br><span class="line">    <span class="keyword">if</span>(n &lt;= <span class="number">128</span>||m &lt;= <span class="number">128</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Poly C; C.<span class="built_in">set</span>(n+m);</span><br><span class="line">        <span class="keyword">int</span> *c = &amp;C[<span class="number">0</span>], *a = &amp;A[<span class="number">0</span>], *b = &amp;B[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> *f = c+i; int64 x = a[i];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= m; ++j) f[j] = (f[j]+x*b[j]%P)%P;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> C;</span><br><span class="line">    &#125;</span><br><span class="line">    prepare(n+m), NTT(A, <span class="number">0</span>), NTT(B, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lim; ++i) A[i] = <span class="number">1l</span>l*A[i]*B[i]%P;</span><br><span class="line">    NTT(A, <span class="number">1</span>); A.<span class="built_in">set</span>(n+m);</span><br><span class="line">    <span class="keyword">return</span> A;</span><br><span class="line">&#125;</span><br><span class="line">Poly F, G;</span><br><span class="line"><span class="keyword">int</span> px[N&lt;&lt;<span class="number">1</span>], py[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N&lt;&lt;<span class="number">2</span>; i &lt;&lt;= <span class="number">1</span>) inv[i] = qpow(i, P<span class="number">-2</span>);</span><br><span class="line">    n = read(), fac[<span class="number">0</span>] = fac[<span class="number">1</span>] = ifac[<span class="number">0</span>] = ifac[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> x = read(), y = read();</span><br><span class="line">        add(x, y);</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(<span class="number">1</span>, <span class="number">0</span>); F.<span class="built_in">set</span>(n), G.<span class="built_in">set</span>(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) </span><br><span class="line">    &#123;</span><br><span class="line">        inv[i] = (P-P/i)*inv[P%i]%P, </span><br><span class="line">        fac[i] = i*fac[i<span class="number">-1</span>]%P, </span><br><span class="line">        ifac[i] = inv[i]*ifac[i<span class="number">-1</span>]%P;</span><br><span class="line">        ++F[s[i]], ++F[n-s[i]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; ++i) F[i] = F[i]*fac[i]%P, G[i] = ifac[i]%P;</span><br><span class="line">    F.rev(), F = F*G, F.<span class="built_in">set</span>(n), F.rev();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, (n*C(n, i)%P-F[i]*ifac[i]%P+P)%P);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>构造</tag>
        <tag>思维</tag>
        <tag>动态规划</tag>
        <tag>生成函数</tag>
        <tag>容斥</tag>
        <tag>博弈论</tag>
        <tag>多项式</tag>
      </tags>
  </entry>
  <entry>
    <title>52709102 AGC004</title>
    <url>/2019/07/25/52709102-AGC004/</url>
    <content><![CDATA[<h2 id="colorful-slimes"><a href="https://www.luogu.org/problem/AT2042">Colorful Slimes</a></h2>
<blockquote>
<p>有 <span class="math inline">\(2\)</span> 种操作，花费 <span class="math inline">\(a_i\)</span> 秒，直接获得颜色 <span class="math inline">\(i\)</span> 和花费 <span class="math inline">\(x\)</span> 秒，使得之前获得的颜色 <span class="math inline">\(i\)</span> 全部变为颜色 <span class="math inline">\((i + 1)\ mod\ n\)</span>，求收集到 <span class="math inline">\(0\)</span> 到 <span class="math inline">\(n-1\)</span> 所有颜色的最短时间</p>
</blockquote>
<p>了解题意后，我们发现，每种方案的 <span class="math inline">\(2\)</span>
操作一定取决于作用二操作次数最多的颜色，所以枚举 <span class="math inline">\(2\)</span> 操作，滑动窗口最小值查询即可
<a id="more"></a> <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> int64;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">int</span> f = <span class="number">1</span>, <span class="keyword">int</span> x = <span class="number">0</span>, <span class="keyword">char</span> ch = <span class="string">&#x27; &#x27;</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">isdigit</span>(ch = getchar())) <span class="keyword">if</span>(ch == <span class="string">&#x27;-&#x27;</span>) f = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch)) x = x*<span class="number">10</span>+ch-<span class="string">&#x27;0&#x27;</span>, ch = getchar();</span><br><span class="line">    <span class="keyword">return</span> f*x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">4e3</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> n, x, a[N], q[N], l, r;</span><br><span class="line">int64 ans;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n = read(), x = read(); </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) a[i] = read(), a[i+n] = a[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; n; ++k)</span><br><span class="line">    &#123;</span><br><span class="line">        int64 s = <span class="number">1l</span>l*k*x; l = <span class="number">1</span>, r = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(l &lt;= r&amp;&amp;a[q[r]] &gt;= a[i]) --r;</span><br><span class="line">            q[++r] = i;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = k+<span class="number">1</span>; i &lt;= n+k; ++i) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(l &lt;= r&amp;&amp;i-k &gt; q[l]) ++l;</span><br><span class="line">            <span class="keyword">while</span>(l &lt;= r&amp;&amp;a[q[r]] &gt;= a[i]) --r; </span><br><span class="line">            q[++r] = i; s += a[q[l]];</span><br><span class="line">        &#125;</span><br><span class="line">        ans = k?min(s, ans):s;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="and-grid"><a href="https://www.luogu.org/problem/AT2043">AND
Grid</a></h2>
<blockquote>
<p>给定一个网格图，有些位置已经被涂色，要求构造两个相同大小的网格图，并且在上面涂色，需要保证颜色四联通，满足这两个网格的涂色部分的重合位置恰好是给定的网格图的涂色位置</p>
</blockquote>
<p>这道题保证边界无颜色，所以只需要行按照奇偶染色，最后一边染开始的一列，一边染结束的一列保证联通即可</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">int</span> f = <span class="number">1</span>, <span class="keyword">int</span> x = <span class="number">0</span>, <span class="keyword">char</span> ch = <span class="string">&#x27; &#x27;</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">isdigit</span>(ch = getchar())) <span class="keyword">if</span>(ch == <span class="string">&#x27;-&#x27;</span>) f = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch)) x = x*<span class="number">10</span>+ch-<span class="string">&#x27;0&#x27;</span>, ch = getchar();</span><br><span class="line">    <span class="keyword">return</span> f*x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">5e2</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">char</span> s[N][N], a[N][N], b[N][N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n = read(), m = read();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s[i]+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++j)</span><br><span class="line">            a[i][j] = b[i][j] = s[i][j];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) a[i][<span class="number">1</span>] = b[i][m] = <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">2</span>; j &lt; m; ++j)</span><br><span class="line">            i&amp;<span class="number">1</span>?a[i][j] = <span class="string">&#x27;#&#x27;</span>:b[i][j] = <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, a[i]+<span class="number">1</span>); <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, b[i]+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="teleporter"><a href="https://www.luogu.org/problem/AT2044">Teleporter</a></h2>
<blockquote>
<p>给定一个基环内向树，修改尽可能少的出边，使得每个点到 <span class="math inline">\(1\)</span> 号节点都可以经过 <span class="math inline">\(k\)</span> 条边到达</p>
</blockquote>
<p>显然，我们需要 <span class="math inline">\(1\)</span>
号点自身连自环，之后就变成了 <a href="https://www.luogu.org/problem/P2279">[HNOI2003]消防局的设立</a>
随便做一下就好了</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">int</span> f = <span class="number">1</span>, <span class="keyword">int</span> x = <span class="number">0</span>, <span class="keyword">char</span> ch = <span class="string">&#x27; &#x27;</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">isdigit</span>(ch = getchar())) <span class="keyword">if</span>(ch == <span class="string">&#x27;-&#x27;</span>) f = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch)) x = x*<span class="number">10</span>+ch-<span class="string">&#x27;0&#x27;</span>, ch = getchar();</span><br><span class="line">    <span class="keyword">return</span> f*x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> next, to;</span><br><span class="line">    Edge(<span class="keyword">int</span> next = <span class="number">0</span>, <span class="keyword">int</span> to = <span class="number">0</span>):next(next), to(to) &#123;&#125;;</span><br><span class="line">&#125;edge[N];</span><br><span class="line"><span class="keyword">int</span> tot, head[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123; edge[++tot] = Edge(head[x], y); head[x] = tot; &#125;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> ac[<span class="number">20</span>][N], d[N], cov[N], ans, fa[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    d[x] = d[fa[x]]+<span class="number">1</span>; <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">20</span>; ++i) ac[i][x] = ac[i<span class="number">-1</span>][ac[i<span class="number">-1</span>][x]];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = head[x]; i; i = edge[i].next) dfs(edge[i].to);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cover</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(cov[x]) <span class="keyword">return</span>; cov[x] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = head[x]; i; i = edge[i].next) cover(edge[i].to);   </span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">priority_queue</span>&lt;<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &gt; q;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n = read(), m = read();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> x = <span class="number">1</span>; x &lt;= n; ++x) fa[x] = read();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> x = <span class="number">2</span>; x &lt;= n; ++x) add(ac[<span class="number">0</span>][x] = fa[x], x);</span><br><span class="line">    ans += fa[<span class="number">1</span>] != <span class="number">1</span>; dfs(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> x = <span class="number">1</span>; x &lt;= n; ++x) q.push(<span class="built_in">make_pair</span>(d[x], x));</span><br><span class="line">    <span class="keyword">while</span>(q.size())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> x = q.top().second, p = x; q.pop();</span><br><span class="line">        <span class="keyword">if</span>(cov[x]||d[x]-d[<span class="number">1</span>] &lt;= m) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">19</span>; ~i; --i) </span><br><span class="line">            <span class="keyword">if</span>(d[x]-d[ac[i][p]] &lt; m&amp;&amp;ac[i][p]) p = ac[i][p];</span><br><span class="line">        cover(p); ++ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="salvage-robots"><a href="https://www.luogu.org/problem/AT2045">Salvage Robots</a></h2>
<blockquote>
<p>有一个棋盘，每个格子有机器人，空格和出口三者之一
，每次可以命令所有机器人向上下左右中的某个方向移动一格，如果它超出了棋盘的边界或到了出口的位置就会消失，求机器人到出口的最多数量</p>
</blockquote>
<p>很自然地想到把出口和其可以移动的范围替代移动机器人，然而设计的 <span class="math inline">\(DP\)</span> 具有会算重，之后就看了官方题解</p>
<p>不妨设 <span class="math inline">\(f_{l,r,d,u}\)</span>
表示出口曾经向左走了 <span class="math inline">\(l\)</span> 格，向右走了
<span class="math inline">\(r\)</span> 格，向上走 <span class="math inline">\(d\)</span> 格，向下走了 <span class="math inline">\(u\)</span>
格，这个范围内遇到的机器人的最大数量，如图</p>
<figure>
<img src="/2019/07/25/52709102-AGC004/robot_1.png" alt="状态设计">
<figcaption aria-hidden="true">状态设计</figcaption>
</figure>
<p>图中的黄色区域就是机器人曾经的移动范围，在这个移动范围内的机器人取舍情况已经被计算好了</p>
<p>接着，我们标注一下曾经有过这个移动范围的前提下，它不能走的网格</p>
<figure>
<img src="/2019/07/25/52709102-AGC004/robot_2.png" alt="禁止节点">
<figcaption aria-hidden="true">禁止节点</figcaption>
</figure>
<p>我们发现只要向白色部分转移即可，而对于红黄相间的部分的取舍之前已经取舍过了，只有红色的部分就是走不到的部分</p>
<p>转移如下</p>
<figure>
<img src="/2019/07/25/52709102-AGC004/robot_3.png" alt="转移">
<figcaption aria-hidden="true">转移</figcaption>
</figure>
<p>移动范围扩大，在加上相应颜色区域的机器人数量即可</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">int</span> f = <span class="number">1</span>, <span class="keyword">int</span> x = <span class="number">0</span>, <span class="keyword">char</span> ch = <span class="string">&#x27; &#x27;</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">isdigit</span>(ch = getchar())) <span class="keyword">if</span>(ch == <span class="string">&#x27;-&#x27;</span>) f = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch)) x = x*<span class="number">10</span>+ch-<span class="string">&#x27;0&#x27;</span>, ch = getchar();</span><br><span class="line">    <span class="keyword">return</span> f*x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e2</span>+<span class="number">5</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123; <span class="keyword">return</span> a&gt;b?a:b; &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">min</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123; <span class="keyword">return</span> a&lt;b?a:b; &#125;</span><br><span class="line"><span class="keyword">short</span> f[N][N][N][N], g[N][N], h[N][N];</span><br><span class="line"><span class="keyword">char</span> s[N][N];</span><br><span class="line"><span class="keyword">int</span> n, m, ans, px, py;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n = read(), m = read(); <span class="built_in">memset</span>(f, <span class="number">-1</span>, <span class="keyword">sizeof</span>(f));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s[i]+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i][j] == <span class="string">&#x27;E&#x27;</span>) px = i, py = j;</span><br><span class="line">            g[i][j] = g[i][j<span class="number">-1</span>]+(s[i][j] == <span class="string">&#x27;o&#x27;</span>);</span><br><span class="line">            h[i][j] = h[i<span class="number">-1</span>][j]+(s[i][j] == <span class="string">&#x27;o&#x27;</span>); </span><br><span class="line">        &#125;    </span><br><span class="line">    f[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;    </span><br><span class="line">    <span class="keyword">int</span> pl = py<span class="number">-1</span>, pr = m-py, pd = px<span class="number">-1</span>, pu = n-px, p;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> l = <span class="number">0</span>; l &lt;= pl; ++l)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> r = <span class="number">0</span>; r &lt;= pr; ++r)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> d = <span class="number">0</span>; d &lt;= pd; ++d)</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> u = <span class="number">0</span>; u &lt;= pu; ++u)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(!(~f[l][r][d][u])) <span class="keyword">continue</span>;</span><br><span class="line">                    <span class="keyword">int</span> cl = max(r+<span class="number">1</span>, py-l), cr = min(m-l, py+r);</span><br><span class="line">                    <span class="keyword">int</span> cd = max(u+<span class="number">1</span>, px-d), cu = min(n-d, px+u);</span><br><span class="line">                    <span class="keyword">if</span>((p = py+r+<span class="number">1</span>) &lt;= m-l) f[l][r+<span class="number">1</span>][d][u] = max(f[l][r+<span class="number">1</span>][d][u], f[l][r][d][u]+h[cu][p]-h[cd<span class="number">-1</span>][p]);</span><br><span class="line">                    <span class="keyword">if</span>((p = py-l<span class="number">-1</span>) &gt;= r+<span class="number">1</span>) f[l+<span class="number">1</span>][r][d][u] = max(f[l+<span class="number">1</span>][r][d][u], f[l][r][d][u]+h[cu][p]-h[cd<span class="number">-1</span>][p]);</span><br><span class="line">                    <span class="keyword">if</span>((p = px+u+<span class="number">1</span>) &lt;= n-d) f[l][r][d][u+<span class="number">1</span>] = max(f[l][r][d][u+<span class="number">1</span>], f[l][r][d][u]+g[p][cr]-g[p][cl<span class="number">-1</span>]);</span><br><span class="line">                    <span class="keyword">if</span>((p = px-d<span class="number">-1</span>) &gt;= u+<span class="number">1</span>) f[l][r][d+<span class="number">1</span>][u] = max(f[l][r][d+<span class="number">1</span>][u], f[l][r][d][u]+g[p][cr]-g[p][cl<span class="number">-1</span>]);                 </span><br><span class="line">                    ans = max(ans, f[l][r][d][u]);</span><br><span class="line">                &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="namori"><a href="https://www.luogu.org/problem/AT2046">Namori</a></h2>
<blockquote>
<p>给定一个树或基环树，每个点初始是白色，每次操作可以处理一条边，其两个点如果颜色相同则都变成相反的颜色，询问能否将每个点都变为黑色</p>
</blockquote>
<p>首先考虑树的情况，考虑对树黑白染色，那么题中的操作就变成了把黑白交换位置，最终黑点变为原来的白点，白点变为原来的黑点，不妨将黑点的权值置为
<span class="math inline">\(-1\)</span>，白点的权值置为 <span class="math inline">\(1\)</span>，<span class="math inline">\(s_x\)</span> 为以 <span class="math inline">\(x\)</span> 为根的子树的点权和，<span class="math inline">\(p\)</span> 为根，显然 <span class="math inline">\(s_p\)</span> 不为 <span class="math inline">\(0\)</span> 时无解</p>
<p>考虑答案的下界，对于 <span class="math inline">\(s_x\)</span> 不为
<span class="math inline">\(0\)</span>，那么 <span class="math inline">\(x\)</span> 要向父边交换 <span class="math inline">\(|s_x|\)</span> 个点，则下界为 <span class="math inline">\(\sum|s_x|\)</span>，这个下界一定可以达到，因为考虑从叶子节点向上按照这样贪心，我们在对
<span class="math inline">\(x\)</span> 操作前，<span class="math inline">\(x\)</span>
的子树尽可能满足，即可以找到一个合适的顺序使父边只交换 <span class="math inline">\(|s_x|\)</span> 个点</p>
<p>再讨论基环树，我们把环上任意一边 <span class="math inline">\((p,\
q)\)</span>
删掉，首先是奇环，奇环不满足二分图性质，所以断掉的那条边意义与其他边不同，手模几组样例后发现，对这条边的操作可以使得黑白点的差减少
<span class="math inline">\(2\)</span>，所以当 <span class="math inline">\(s_p\)</span> 为奇数时问题无解，否则，答案加上
<span class="math inline">\(|\frac{s_p}{2}|\)</span>，环上所有 <span class="math inline">\(s_x\)</span> 减 <span class="math inline">\(\frac{s_p}{2}\)</span> 且 <span class="math inline">\(s_p\)</span> 自身变为 <span class="math inline">\(0\)</span>，其次是偶环，偶环满足二分图性质，边的的意义与其他边相同，对环上的交换单独考虑，发现就是一个均分纸牌，求个中位数即可</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">int</span> f = <span class="number">1</span>, <span class="keyword">int</span> x = <span class="number">0</span>, <span class="keyword">char</span> ch = <span class="string">&#x27; &#x27;</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">isdigit</span>(ch = getchar())) <span class="keyword">if</span>(ch == <span class="string">&#x27;-&#x27;</span>) f = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch)) x = x*<span class="number">10</span>+ch-<span class="string">&#x27;0&#x27;</span>, ch = getchar();</span><br><span class="line">    <span class="keyword">return</span> f*x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> next, to;</span><br><span class="line">    Edge(<span class="keyword">int</span> next = <span class="number">0</span>, <span class="keyword">int</span> to = <span class="number">0</span>):next(next), to(to) &#123;&#125;;</span><br><span class="line">&#125;edge[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> tot, head[N];</span><br><span class="line"><span class="keyword">void</span> _add(<span class="keyword">int</span> x, <span class="keyword">int</span> y) &#123; edge[++tot] = Edge(head[x], y); head[x] = tot; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123; _add(x, y); _add(y, x); &#125;</span><br><span class="line"><span class="keyword">int</span> n, m, cn, w[N], f[N], fa[N], s[N], p, q, ans;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="keyword">return</span> f[x] == x?x:f[x] = find(f[x]); &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> f, <span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    fa[x] = f, s[x] = c;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = head[x]; i; i = edge[i].next)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> y = edge[i].to; <span class="keyword">if</span>(y == f) <span class="keyword">continue</span>;</span><br><span class="line">        dfs(y, x, -c); s[x] += s[y];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n = read(), m = read(), p = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> x = <span class="number">1</span>; x &lt;= n; ++x) f[x] = x;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> x = read(), y = read();</span><br><span class="line">        <span class="keyword">if</span>(find(x) == find(y)) p = x, q = y;</span><br><span class="line">        <span class="keyword">else</span> f[find(y)] = find(x), add(x, y);</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(p, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(n == m)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x = q; x; x = fa[x]) w[++cn] = s[x];</span><br><span class="line">        <span class="keyword">if</span>(cn&amp;<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(s[p]&amp;<span class="number">1</span>) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>), <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> x = q; x; x = fa[x]) s[x] -= s[p]&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(s[p]) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>), <span class="number">0</span>;</span><br><span class="line">            sort(w+<span class="number">1</span>, w+<span class="number">1</span>+cn);   </span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> x = q; x; x = fa[x]) s[x] -= w[cn&gt;&gt;<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(s[p]) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>), <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> x = <span class="number">1</span>; x &lt;= n; ++x) ans += <span class="built_in">abs</span>(s[x]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>构造</tag>
        <tag>思维</tag>
        <tag>动态规划</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title>42709102 AGC003</title>
    <url>/2019/07/24/42709102-AGC003/</url>
    <content><![CDATA[<h2 id="anticube"><a href="https://www.luogu.org/problemnew/show/AT2004">Anticube</a></h2>
<blockquote>
<p>给定 <span class="math inline">\(n\)</span> 个数 <span class="math inline">\(s_i\)</span>，要求从中选出最多的数，满足任意两个数之积都不是完全立方数</p>
</blockquote>
<p>对于一个数 <span class="math inline">\(x\)</span>
进行唯一分解，把每个质因子的指数对 <span class="math inline">\(3\)</span> 取模构造出数 <span class="math inline">\(a\)</span>，再把 <span class="math inline">\(a\)</span> 的每个质因子指数相反数对 <span class="math inline">\(3\)</span> 取模得到 <span class="math inline">\(b\)</span>，我们发现 <span class="math inline">\(a\)</span> 和 <span class="math inline">\(b\)</span>
是一一对应的，贪心取较大的那一个即可，特判 <span class="math inline">\(x\)</span> 是完全平方数的情况</p>
<p>进行质因数分解时，可以筛到 <span class="math inline">\(10^{\frac{10}{3}}\)</span>
以内的质数，对于分解后剩下的数，要么是一个质数的完全平方数，要么是质数，判断一下即可
<a id="more"></a> <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> int64;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> int64 <span class="title">read</span><span class="params">(<span class="keyword">int</span> f = <span class="number">1</span>, int64 x = <span class="number">0</span>, <span class="keyword">char</span> ch = <span class="string">&#x27; &#x27;</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">isdigit</span>(ch = getchar())) <span class="keyword">if</span>(ch == <span class="string">&#x27;-&#x27;</span>) f = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch)) x = x*<span class="number">10</span>+ch-<span class="string">&#x27;0&#x27;</span>, ch = getchar();</span><br><span class="line">    <span class="keyword">return</span> f*x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> p[] = &#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">13</span>, <span class="number">17</span>, <span class="number">19</span>, <span class="number">23</span>, <span class="number">29</span>, <span class="number">31</span>, <span class="number">37</span>&#125;, S = <span class="number">127</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="function">int64 <span class="title">qpow</span><span class="params">(int64 a, int64 b, int64 n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    int64 ret = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>( ; b; b &gt;&gt;= <span class="number">1</span>, a = a*a%n) <span class="keyword">if</span>(b&amp;<span class="number">1</span>) ret = a*ret%n;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">int64 <span class="title">gcd</span><span class="params">(int64 a, int64 b)</span> </span>&#123; <span class="keyword">return</span> b?gcd(b, a%b):a; &#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">miller_rabin</span><span class="params">(int64 n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">12</span>; ++i) <span class="keyword">if</span>(n%p[i] == <span class="number">0</span>) <span class="keyword">return</span> n == p[i];</span><br><span class="line">    int64 r; <span class="keyword">int</span> t;</span><br><span class="line">    <span class="keyword">for</span>(r = n<span class="number">-1</span>, t = <span class="number">0</span>; ~r&amp;<span class="number">1</span>; r &gt;&gt;= <span class="number">1</span>, ++t);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">12</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        int64 x = qpow(p[i], r, n), xs;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= t; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            xs = x*x%n;</span><br><span class="line">            <span class="keyword">if</span>(xs == <span class="number">1</span>&amp;&amp;x != <span class="number">1</span>&amp;&amp;x != n<span class="number">-1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            x = xs;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(x != <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">vector</span>&lt;int64&gt; pd;</span><br><span class="line"><span class="keyword">int</span> n, c[N], ans;</span><br><span class="line">int64 a[N], b[N];</span><br><span class="line"><span class="built_in">map</span>&lt;int64, <span class="keyword">int</span>&gt; h, vis;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n = read();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">2200</span>; ++i) <span class="keyword">if</span>(miller_rabin(i)) pd.push_back(i); </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        int64 x = read(), t; a[i] = b[i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; pd.size(); ++k)</span><br><span class="line">        &#123;</span><br><span class="line">            c[k] = <span class="number">0</span>; <span class="keyword">while</span>(x%pd[k] == <span class="number">0</span>) ++c[k], x /= pd[k]; c[k] %= <span class="number">3</span>;</span><br><span class="line">            <span class="keyword">if</span>(c[k] == <span class="number">2</span>) a[i] *= pd[k]*pd[k], b[i] *= pd[k];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(c[k] == <span class="number">1</span>) a[i] *= pd[k], b[i] *= pd[k]*pd[k];</span><br><span class="line">        &#125;</span><br><span class="line">        t = <span class="built_in">sqrt</span>(x);</span><br><span class="line">        <span class="keyword">if</span>(t*t == x) a[i] *= t*t, b[i] *= t;</span><br><span class="line">        <span class="keyword">else</span> a[i] *= x, b[i] *= x*x;</span><br><span class="line">        ++h[a[i]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(vis[a[i]]||vis[b[i]]||a[i] == <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">        vis[a[i]] = <span class="number">1</span>; ans += max(h[a[i]], h[b[i]]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans+(h[<span class="number">1</span>] != <span class="number">0</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="sequential-operations-on-sequence"><a href="https://www.luogu.org/problemnew/show/AT2005">Sequential
operations on Sequence</a></h2>
<blockquote>
<p>初始为 <span class="math inline">\(1\)</span> 到 <span class="math inline">\(n\)</span> 的数列，每次操作把数组长度变为<span class="math inline">\(m\)</span>，新增的数为上一个操作后的数组的重复，问最终数出现的次数</p>
</blockquote>
<p>首先，对最终答案有贡献的一定是单调递增的操作序列，用单调栈维护，其次这个问题的实质是要维护出每个操作对应的序列在最终答案的出现次数，便于处理每次操作后对于的那些部分，那么需要从最后一个序列倒推，中间递归维护即可，最后中间涉及的区间加的操作差分就好了</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> int64;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> int64 <span class="title">read</span><span class="params">(<span class="keyword">int</span> f = <span class="number">1</span>, int64 x = <span class="number">0</span>, <span class="keyword">char</span> ch = <span class="string">&#x27; &#x27;</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">isdigit</span>(ch = getchar())) <span class="keyword">if</span>(ch == <span class="string">&#x27;-&#x27;</span>) f = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch)) x = x*<span class="number">10</span>+ch-<span class="string">&#x27;0&#x27;</span>, ch = getchar();</span><br><span class="line">    <span class="keyword">return</span> f*x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> n, q, top;</span><br><span class="line">int64 d[N], s[N], f[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(int64 p, int64 q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!p) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> r = upper_bound(s+<span class="number">1</span>, s+<span class="number">1</span>+top, p)-s<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(!r) d[<span class="number">1</span>] += q, d[p+<span class="number">1</span>] -= q;</span><br><span class="line">    <span class="keyword">else</span> f[r] += p/s[r]*q, solve(p%s[r], q);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    s[++top] = n = read(), q = read(); </span><br><span class="line">    <span class="keyword">while</span>(q--)</span><br><span class="line">    &#123;</span><br><span class="line">        int64 m = read();</span><br><span class="line">        <span class="keyword">while</span>(top&amp;&amp;s[top] &gt;= m) --top;</span><br><span class="line">        s[++top] = m;</span><br><span class="line">    &#125;</span><br><span class="line">    f[top] = <span class="number">1</span>; </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = top; i &gt;= <span class="number">2</span>; --i) </span><br><span class="line">        f[i<span class="number">-1</span>] += s[i]/s[i<span class="number">-1</span>]*f[i], solve(s[i]%s[i<span class="number">-1</span>], f[i]);</span><br><span class="line">    d[<span class="number">1</span>] += f[<span class="number">1</span>], d[s[<span class="number">1</span>]+<span class="number">1</span>] -= f[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, d[i] += d[i<span class="number">-1</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="fraction-of-fractal"><a href="https://www.luogu.org/problemnew/show/AT2006">Fraction of
Fractal</a></h2>
<blockquote>
<p>给定一个<span class="math inline">\(n\times
m\)</span>的黑白网格，保证黑格四连通且至少有一个黑格，求 <span class="math inline">\(k\)</span> 级分形的四联通数量</p>
</blockquote>
<p>首先，我们定义对于一个图形定义上下联通为上下对应的位置都为黑色，左右联通同理</p>
<p>那么若 <span class="math inline">\(1\)</span>
级分形若左右联通和上下联通同时存在，答案一定为 <span class="math inline">\(1\)</span>，若不是，我们只需要考虑一方面即可，以上下为例</p>
<p>当我们把 <span class="math inline">\(1\)</span>
级分形当作节点，节点与节点之间若联通则有边，则建出的图是若干条链组成的森林，那么
<span class="math inline">\(k\)</span> 级分形的联通块的个数即可用 <span class="math inline">\(v_k-e_k\)</span> 快速计算，<span class="math inline">\(v_k\)</span> 是点数，<span class="math inline">\(e_k\)</span> 是边数，此外还有几个变量 <span class="math inline">\(f_k\)</span> 为 <span class="math inline">\(k\)</span>
级分形上下联通<strong>节点</strong>个数，<span class="math inline">\(c\)</span> 为 <span class="math inline">\(1\)</span> 级分形黑色方块个数，<span class="math inline">\(a\)</span> 为 <span class="math inline">\(1\)</span> 级分形上下都为黑色的分界线个数，<span class="math inline">\(b\)</span> 为 <span class="math inline">\(1\)</span> 级分形上下联通方块个数</p>
<p>所以我们有</p>
<p><span class="math display">\[
f_k\ =\ f_{k-1}\times b，\ v_k\ =\ v_{k-1}\times c\\\\
e_k\ =\ e_{k-1}\times c\ +\ f_{k-1}\times a
\]</span></p>
<p>边界条件 <span class="math inline">\(f_1=1,\ v_1=1,\
e_1=0\)</span></p>
<p>通过手模样例即可理解</p>
<p>构造出矩阵转移即可</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> int64;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">int</span> f = <span class="number">1</span>, <span class="keyword">int</span> x = <span class="number">0</span>, <span class="keyword">char</span> ch = <span class="string">&#x27; &#x27;</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">isdigit</span>(ch  = getchar())) <span class="keyword">if</span>(ch == <span class="string">&#x27;-&#x27;</span>) f = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch)) x = x*<span class="number">10</span>+ch-<span class="string">&#x27;0&#x27;</span>, ch = getchar();</span><br><span class="line">    <span class="keyword">return</span> f*x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e3</span>+<span class="number">5</span>, P = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Matrix</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> __[<span class="number">2</span>][<span class="number">2</span>];</span><br><span class="line">    Matrix() &#123; <span class="built_in">memset</span>(__, <span class="number">0</span>, <span class="keyword">sizeof</span>(__)); &#125;</span><br><span class="line">    <span class="keyword">int</span>* <span class="keyword">operator</span> [] (<span class="keyword">const</span> <span class="keyword">int</span> i) &#123; <span class="keyword">return</span> __[i]; &#125;</span><br><span class="line">    Matrix <span class="keyword">operator</span> * (Matrix &amp;_) <span class="keyword">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        Matrix ret;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; ++i)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">2</span>; ++j)</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">2</span>; ++k)</span><br><span class="line">                    ret[i][j] = (ret[i][j]+<span class="number">1l</span>l*__[i][k]*_[k][j]%P)%P;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">()</span> </span>&#123; <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; ++i) __[i][i] = <span class="number">1</span>; &#125;</span><br><span class="line">&#125;f;</span><br><span class="line"><span class="function">Matrix <span class="title">qpow</span><span class="params">(Matrix a, int64 b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Matrix ret; ret.<span class="built_in">set</span>();</span><br><span class="line">    <span class="keyword">for</span>( ; b; b &gt;&gt;= <span class="number">1</span>, a = a*a) <span class="keyword">if</span>(b&amp;<span class="number">1</span>) ret = ret*a;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line">int64 k;</span><br><span class="line"><span class="keyword">char</span> s[N][N];</span><br><span class="line"><span class="keyword">int</span> p, q, a, b, c;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n = read(), m = read(); <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;k);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s[i]+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) p += s[i][<span class="number">1</span>]==<span class="string">&#x27;#&#x27;</span>&amp;&amp;s[i][m]==<span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) q += s[<span class="number">1</span>][i]==<span class="string">&#x27;#&#x27;</span>&amp;&amp;s[n][i]==<span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">    <span class="keyword">if</span>((p&amp;&amp;q)||k &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;1&quot;</span>), <span class="number">0</span>; b = p|q;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            c += s[i][j] == <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">            a += s[i][j] == <span class="string">&#x27;#&#x27;</span>&amp;&amp;s[i][j+<span class="number">1</span>] == <span class="string">&#x27;#&#x27;</span>&amp;&amp;p;</span><br><span class="line">            a += s[i][j] == <span class="string">&#x27;#&#x27;</span>&amp;&amp;s[i+<span class="number">1</span>][j] == <span class="string">&#x27;#&#x27;</span>&amp;&amp;q;</span><br><span class="line">        &#125;</span><br><span class="line">    f[<span class="number">0</span>][<span class="number">0</span>] = c, f[<span class="number">1</span>][<span class="number">0</span>] = a, f[<span class="number">1</span>][<span class="number">1</span>] = b; f = qpow(f, k<span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, (f[<span class="number">0</span>][<span class="number">0</span>]-f[<span class="number">1</span>][<span class="number">0</span>]+P)%P);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>思维</tag>
        <tag>组合计数</tag>
        <tag>贪心</tag>
        <tag>素数相关</tag>
      </tags>
  </entry>
  <entry>
    <title>32709102 AGC002</title>
    <url>/2019/07/23/32709102-AGC002/</url>
    <content><![CDATA[<h2 id="stamp-rally"><a href="https://www.luogu.org/problemnew/show/AT1998">Stamp Rally</a></h2>
<blockquote>
<p>一张连通图，<span class="math inline">\(q\)</span> 次询问从两个点
<span class="math inline">\(x\)</span> 和 <span class="math inline">\(y\)</span> 出发，希望经过的不重复点数量等于 <span class="math inline">\(z\)</span>，经过的边最大编号最小是多少</p>
</blockquote>
<p>在 <span class="math inline">\(Kruskal\)</span> 重构树上倍增二分即可
<a id="more"></a> <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;tuple&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">int</span> f = <span class="number">1</span>, <span class="keyword">int</span> x = <span class="number">0</span>, <span class="keyword">char</span> ch = <span class="string">&#x27; &#x27;</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">isdigit</span>(ch = getchar())) <span class="keyword">if</span>(ch == <span class="string">&#x27;-&#x27;</span>) f = - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch)) x = x*<span class="number">10</span>+ch-<span class="string">&#x27;0&#x27;</span>, ch = getchar();</span><br><span class="line">    <span class="keyword">return</span> f*x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">3e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, q, root;</span><br><span class="line">tuple&lt;<span class="keyword">int</span>, <span class="keyword">int</span>, <span class="keyword">int</span>&gt; edge[N];</span><br><span class="line"><span class="keyword">int</span> f[N], w[N], ac[<span class="number">20</span>][N], size[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="keyword">return</span> x == f[x]?x:f[x] = find(f[x]); &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">19</span>; ~i; --i) <span class="keyword">if</span>(w[ac[i][x]] &lt;= d) x = ac[i][x]; </span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">valid</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> z, <span class="keyword">int</span> mid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x = find(x, mid), y = find(y, mid);</span><br><span class="line">    <span class="keyword">if</span>(x == y) <span class="keyword">return</span> size[x] &gt;= z;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> size[x]+size[y] &gt;= z;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n = read(), m = read(), root = n, w[<span class="number">0</span>] = m+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> x = read(), y = read();</span><br><span class="line">        edge[i] = make_tuple(i, x, y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> x = <span class="number">1</span>; x &lt;= n; ++x) f[x] = x, size[x] = <span class="number">1</span>;</span><br><span class="line">    sort(edge+<span class="number">1</span>, edge+<span class="number">1</span>+m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> x = get&lt;<span class="number">1</span>&gt;(edge[i]), y = get&lt;<span class="number">2</span>&gt;(edge[i]), z = get&lt;<span class="number">0</span>&gt;(edge[i]);</span><br><span class="line">        x = find(x), y = find(y); <span class="keyword">if</span>(x == y) <span class="keyword">continue</span>;</span><br><span class="line">        f[x] = f[y] = ++root, f[root] = root, w[root] = z;</span><br><span class="line">        size[root] = size[x]+size[y];</span><br><span class="line">        ac[<span class="number">0</span>][x] = root, ac[<span class="number">0</span>][y] = root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> x = root; x; --x)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">20</span>; ++i)</span><br><span class="line">            ac[i][x] = ac[i<span class="number">-1</span>][ac[i<span class="number">-1</span>][x]];</span><br><span class="line">    q = read();</span><br><span class="line">    <span class="keyword">while</span>(q--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> x = read(), y = read(), z = read();</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">1</span>, r = m, ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(l &lt;= r)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(valid(x, y, z, mid)) ans = mid, r = mid<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">else</span> l = mid+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="candy-piles"><a href="https://www.luogu.org/problemnew/show/AT1999">Candy Piles</a></h2>
<blockquote>
<p>两人在玩游戏，轮流进行，每次进行将当前最大的那堆糖果全部吃完或将每堆糖果吃掉一个，吃完的人输,假设两人足够聪明，问谁能必胜</p>
</blockquote>
<p>将糖果从大到小排列，以下标作为横轴，个数作为数轴，那么这个游戏就转化为从
<span class="math inline">\((0,\
0)\)</span>，每个人可以向上或向右走，不能走的人输</p>
<p>对于这类博弈问题，有一个结论是对角线上的局面相同，简单证明一下，若
<span class="math inline">\((x,\ y)\)</span> 必输，那么处在 <span class="math inline">\((x-1,\ y-1)\)</span> 的人不管怎么走，依旧可以到达
<span class="math inline">\(SG(x,\ y)\)</span>，反之亦然</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">int</span> f = <span class="number">1</span>, <span class="keyword">int</span> x = <span class="number">0</span>, <span class="keyword">char</span> ch = <span class="string">&#x27; &#x27;</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">isdigit</span>(ch = getchar())) <span class="keyword">if</span>(ch == <span class="string">&#x27;-&#x27;</span>) f = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch)) x = x*<span class="number">10</span>+ch-<span class="string">&#x27;0&#x27;</span>, ch = getchar();</span><br><span class="line">    <span class="keyword">return</span> f*x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> n, a[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n = read();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) a[i] = read();</span><br><span class="line">    sort(a+<span class="number">1</span>, a+<span class="number">1</span>+n); reverse(a+<span class="number">1</span>, a+<span class="number">1</span>+n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="keyword">if</span>(i+<span class="number">1</span> &gt; a[i+<span class="number">1</span>])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i+<span class="number">1</span>; a[j] == i; ++j) ans ^= <span class="number">1</span>;</span><br><span class="line">            ans |= (a[i]-i)&amp;<span class="number">1</span>;</span><br><span class="line">            <span class="built_in">puts</span>(ans?<span class="string">&quot;First&quot;</span>:<span class="string">&quot;Second&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="leftmost-ball"><a href="https://www.luogu.org/problemnew/show/AT2000">Leftmost
Ball</a></h2>
<blockquote>
<p>给你 <span class="math inline">\(n\)</span>
种不含白色颜色的球，每个球有 <span class="math inline">\(m\)</span>
个，把这 <span class="math inline">\(n\times m\)</span>
个球排成一排，把每一种颜色的最左边出现的球涂成白色，求有多少种不同的颜色序列</p>
</blockquote>
<p>问题转换，有 <span class="math inline">\(n+1\)</span>
种颜色，其中白色有 <span class="math inline">\(n\)</span> 个，其他有
<span class="math inline">\(m-1\)</span>
个，求颜色序列满足任何前缀白色的个数不少于其他颜色的种数的方案数</p>
<p>序列计数 <span class="math inline">\(DP\)</span>
一般可以考虑枚举位置和枚举元素，这里用到后者，考虑状态 <span class="math inline">\(f_{i,\ j}\)</span> 为在 <span class="math inline">\(n\times m\)</span> 个位置上已填了 <span class="math inline">\(i\)</span> 个白球和 <span class="math inline">\(j\)</span> 种其他颜色的球</p>
<p>则有转移方程</p>
<p><span class="math display">\[
f_{i,j}\ =\ f_{i-1,j}+f_{i,j-1}\times(n-j+1)\times\binom{n\times
m-i-(m-1)\times (j-1)-1}{m-2}
\]</span></p>
<p>为了不重不漏，我们每次强制让球填在第一个空的位置上，所以 <span class="math inline">\(f_{i,\ j}\)</span> 可以由 <span class="math inline">\(f_{i-1,\ j}\)</span> 多填一个白球转移，也可以由
<span class="math inline">\(f_{i,\ j-1}\)</span> 从剩下 <span class="math inline">\(n-j+1\)</span> 个颜色选择一种颜色填完转移</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">int</span> f = <span class="number">1</span>, <span class="keyword">int</span> x = <span class="number">0</span>, <span class="keyword">char</span> ch = <span class="string">&#x27; &#x27;</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">isdigit</span>(ch = getchar())) <span class="keyword">if</span>(ch == <span class="string">&#x27;-&#x27;</span>) f = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch)) x = x*<span class="number">10</span>+ch-<span class="string">&#x27;0&#x27;</span>, ch = getchar();</span><br><span class="line">    <span class="keyword">return</span> f*x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e3</span>+<span class="number">5</span>, M = <span class="number">4e6</span>+<span class="number">5</span>, P = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, f[N][N], fac[M], ifac[M], inv[M], ans;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">C</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123; <span class="keyword">return</span> <span class="number">1l</span>l*fac[n]*ifac[n-m]%P*ifac[m]%P; &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n = read(), m = read(); </span><br><span class="line">    inv[<span class="number">1</span>] = ifac[<span class="number">0</span>] = fac[<span class="number">0</span>] = <span class="number">1</span>; </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n*m; ++i) inv[i] = <span class="number">1l</span>l*(P-P/i)*inv[P%i]%P;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n*m; ++i) fac[i] = <span class="number">1l</span>l*i*fac[i<span class="number">-1</span>]%P, ifac[i] = <span class="number">1l</span>l*inv[i]*ifac[i<span class="number">-1</span>]%P;</span><br><span class="line">    f[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= i; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            f[i][j] = f[i<span class="number">-1</span>][j];</span><br><span class="line">            <span class="keyword">if</span>(j) f[i][j] = (f[i][j]+<span class="number">1l</span>l*f[i][j<span class="number">-1</span>]*(n-j+<span class="number">1</span>)%P*C(n*m-i-(j<span class="number">-1</span>)*(m<span class="number">-1</span>)<span class="number">-1</span>, m<span class="number">-2</span>)%P)%P;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, m == <span class="number">1</span>?<span class="number">1</span>:f[n][n]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>构造</tag>
        <tag>思维</tag>
        <tag>动态规划</tag>
        <tag>组合计数</tag>
        <tag>最小生成树</tag>
        <tag>博弈论</tag>
      </tags>
  </entry>
  <entry>
    <title>91709102 AGC001</title>
    <url>/2019/07/19/91709102-AGC001/</url>
    <content><![CDATA[<h2 id="mysterious-light"><a href="https://www.luogu.org/problemnew/show/AT1980">Mysterious
Light</a></h2>
<blockquote>
<p>给定光源，求按照题意规则反射的总距离</p>
</blockquote>
<p>很容易观察出该题的重复子结构，每次可以看作从一个平行四边形的右下角向外发射，不妨设
<span class="math inline">\((a,\ b)\)</span>
来表示平行四边形的两边即初始状态有 <span class="math inline">\((n-x,\
x)\)</span></p>
<p>我们尝试用 <span class="math inline">\((a,\ b)\)</span>
推出下一个平行四边形的状态，显然 <a id="more"></a> <span class="math display">\[
(a,\ b)\rightarrow
\begin{cases}
\ (a-b,\ b),\ a &gt; b\\\\
\ (a,\ b-a),\ b &gt; a
\end{cases}
\]</span></p>
<p>显然终止状态为二元组其中一个变为 <span class="math inline">\(0\)</span> 时</p>
<p>设 <span class="math inline">\(f(a,\ b)\)</span> 为 <span class="math inline">\((a,\ b)\)</span> 到达终止状态的路径则有</p>
<p><span class="math display">\[
f(a,\ b)\ =\
\begin{cases}
2b+f(a-b,\ b),\ a &gt; b\\\\
2a+f(a,\ b-a),\ b &gt; a\\\\
a,\ a\ = b
\end{cases}
\]</span></p>
<p>很容易观察到这是一个更相减损的过程并用辗转相除优化</p>
<p>进一步的，我们观察最后路径会发现，不重不漏的走过所有轨迹三角形下面的边的路径总长度为
<span class="math inline">\(n-(n,\ x)\)</span>，这样即可快速的出答案</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> int64;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> int64 <span class="title">read</span><span class="params">(int64 f = <span class="number">1</span>, int64 x = <span class="number">0</span>, <span class="keyword">char</span> ch = <span class="string">&#x27; &#x27;</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">isdigit</span>(ch = getchar())) <span class="keyword">if</span>(ch == <span class="string">&#x27;-&#x27;</span>) f = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch)) x = x*<span class="number">10</span>+ch-<span class="string">&#x27;0&#x27;</span>, ch = getchar();</span><br><span class="line">    <span class="keyword">return</span> f*x;</span><br><span class="line">&#125;</span><br><span class="line">int64 n, x;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n = read(), x = read(); </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, <span class="number">3</span>*(n-__gcd(n, x)));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="shorten-diameter"><a href="https://www.luogu.org/problemnew/show/AT1981">Shorten
Diameter</a></h2>
<blockquote>
<p>删除一些点，使树的直径小于等于K，当且仅当删除某点不会对树的联通性产生影响时才可以删除，求最少点数</p>
</blockquote>
<p>我们注意到 <span class="math inline">\(n\)</span>
的范围，这道题一定是一道枚举，观察到最终的树一定存在一个中心，且当 <span class="math inline">\(n\)</span> 是奇数时，最终中心是一条边，<span class="math inline">\(n\)</span>
是偶数时，最终中心是一条边，枚举中心即可</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">int</span> f = <span class="number">1</span>, <span class="keyword">int</span> x = <span class="number">0</span>, <span class="keyword">char</span> ch = <span class="string">&#x27; &#x27;</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">isdigit</span>(ch = getchar())) <span class="keyword">if</span>(ch == <span class="string">&#x27;-&#x27;</span>) f = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch)) x = x*<span class="number">10</span>+ch-<span class="string">&#x27;0&#x27;</span>, ch = getchar();</span><br><span class="line">    <span class="keyword">return</span> f*x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e3</span>+<span class="number">5</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> next, to;</span><br><span class="line">    Edge(<span class="keyword">int</span> next = <span class="number">0</span>, <span class="keyword">int</span> to = <span class="number">0</span>):next(next), to(to) &#123;&#125;;</span><br><span class="line">&#125;edge[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> head[N], tot;</span><br><span class="line"><span class="keyword">void</span> _add(<span class="keyword">int</span> x, <span class="keyword">int</span> y) &#123; edge[++tot] = Edge(head[x], y); head[x] = tot; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123; _add(x, y); _add(y, x); &#125;</span><br><span class="line"><span class="keyword">int</span> n, k;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa, <span class="keyword">int</span> *d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = head[x]; i; i = edge[i].next)   </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> y = edge[i].to; <span class="keyword">if</span>(y == fa) <span class="keyword">continue</span>;</span><br><span class="line">        d[y] = d[x]+<span class="number">1</span>; dfs(y, x, d);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> d[N][N], ans;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n = read(), k = read(), ans = n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> x = read(), y = read();</span><br><span class="line">        add(x, y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> x = <span class="number">1</span>; x &lt;= n; ++x) dfs(x, <span class="number">0</span>, d[x]);</span><br><span class="line">    <span class="keyword">if</span>(k&amp;<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= tot; i += <span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> u = edge[i].to, v = edge[i+<span class="number">1</span>].to, c = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> y = <span class="number">1</span>; y &lt;= n; ++y) c += d[u][y] &gt; k/<span class="number">2</span>&amp;&amp;d[v][y] &gt; k/<span class="number">2</span>;</span><br><span class="line">            ans = min(ans, c);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x = <span class="number">1</span>; x &lt;= n; ++x) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> c = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> y = <span class="number">1</span>; y &lt;= n; ++y) c += d[x][y] &gt; k/<span class="number">2</span>;</span><br><span class="line">            ans = min(ans, c);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="arrays-and-palindrome"><a href="https://www.luogu.org/problemnew/show/AT1982">Arrays and
Palindrome</a></h2>
<blockquote>
<p>给定数列 <span class="math inline">\(A\)</span> 并给 <span class="math inline">\(A\)</span> 进行重排序，并构造数列 <span class="math inline">\(B\)</span>，满足 <span class="math inline">\(\sum_A=\sum_B\)</span>
并确定两种字符串的回文串划分使得字符串只能由同种字符构造</p>
</blockquote>
<p>通过手算样例过程中的推理建成图论模型，注意到这是一个一笔画问题，且
<span class="math inline">\(A\)</span> 中奇数个数不超过 <span class="math inline">\(2\)</span>，模拟构造即可</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">int</span> f = <span class="number">1</span>, <span class="keyword">int</span> x = <span class="number">0</span>, <span class="keyword">char</span> ch = <span class="string">&#x27; &#x27;</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">isdigit</span>(ch = getchar())) <span class="keyword">if</span>(ch == <span class="string">&#x27;-&#x27;</span>) f = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch)) x = x*<span class="number">10</span>+ch-<span class="string">&#x27;0&#x27;</span>, ch = getchar();</span><br><span class="line">    <span class="keyword">return</span> f*x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> a[N], b[N], cnt, ans;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n = read(), m = read();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) a[i] = read(), cnt += (a[i]&amp;<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(cnt &gt; <span class="number">2</span>) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;Impossible&quot;</span>), <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) <span class="keyword">if</span>(a[i]&amp;<span class="number">1</span>) swap(a[i], a[<span class="number">1</span>]), i = m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= m; ++i) <span class="keyword">if</span>(a[i]&amp;<span class="number">1</span>) swap(a[i], a[m]);</span><br><span class="line">    <span class="keyword">if</span>(a[<span class="number">1</span>] != <span class="number">1</span>) b[++ans] = a[<span class="number">1</span>]<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; m; ++i) b[++ans] = a[i]; b[++ans] = n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; ans; ++i) b[ans] -= b[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, a[i]); <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= ans; ++i) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, b[i]); <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="bbq-hard"><a href="https://www.luogu.org/problemnew/show/AT1983">BBQ Hard</a></h2>
<blockquote>
<p>给定数对 <span class="math inline">\((a,\ b)\)</span> 求 <span class="math inline">\(\sum_{i=1}^n\sum_{j=i+1}^n\binom{a_i+b_i+a_j+b_j}{a_i+a_j}\)</span></p>
</blockquote>
<p>考虑 <span class="math inline">\(\binom{a_i+b_i+a_j+b_j}{a_i+a_j}\)</span>
的几何意义，即从 <span class="math inline">\((0,\ 0)\)</span>
向上或向左到达 <span class="math inline">\((a_i+a_j,\ b_i+b_j)\)</span>
的方案数，所以不妨平移一下即有 <span class="math inline">\((-a_i,\
-b_i)\)</span> 到 <span class="math inline">\((a_j,\ b_j)\)</span>
的方案数， <span class="math inline">\(O(n^2)\)</span> 的 <span class="math inline">\(DP\)</span> 即可</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">int</span> f = <span class="number">1</span>, <span class="keyword">int</span> x = <span class="number">0</span>, <span class="keyword">char</span> ch = <span class="string">&#x27; &#x27;</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">isdigit</span>(ch = getchar())) <span class="keyword">if</span>(ch == <span class="string">&#x27;-&#x27;</span>) f = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch)) x = x*<span class="number">10</span>+ch-<span class="string">&#x27;0&#x27;</span>, ch = getchar();</span><br><span class="line">    <span class="keyword">return</span> f*x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span>+<span class="number">5</span>, M = <span class="number">4000</span>+<span class="number">5</span>, B = <span class="number">2001</span>, P = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> n, a[N], b[N], fac[N], inv[N], ifac[N];</span><br><span class="line"><span class="keyword">int</span> f[M][M], ans;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">C</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123; <span class="keyword">return</span> <span class="number">1l</span>l*fac[n]*ifac[n-m]%P*ifac[m]%P; &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n = N<span class="number">-5</span>, inv[<span class="number">1</span>] = fac[<span class="number">0</span>] = ifac[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) inv[i] = <span class="number">1l</span>l*(P-P/i)*inv[P%i]%P;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) fac[i] = <span class="number">1l</span>l*fac[i<span class="number">-1</span>]*i%P, ifac[i] = <span class="number">1l</span>l*ifac[i<span class="number">-1</span>]*inv[i]%P;</span><br><span class="line">    n = read();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) a[i] = read(), b[i] = read(), ++f[B-a[i]][B-b[i]];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; M; ++i)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; M; ++j)</span><br><span class="line">            f[i][j] = (f[i][j]+(f[i<span class="number">-1</span>][j]+f[i][j<span class="number">-1</span>])%P)%P;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) </span><br><span class="line">        ans = (ans+f[B+a[i]][B+b[i]])%P, </span><br><span class="line">        ans = (<span class="number">1l</span>l*ans+P-C(<span class="number">2</span>*(a[i]+b[i]), <span class="number">2</span>*a[i]))%P;</span><br><span class="line">    ans = <span class="number">1l</span>l*ans*inv[<span class="number">2</span>]%P;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="wide-swap"><a href="https://www.luogu.org/problemnew/show/AT1984">Wide Swap</a></h2>
<blockquote>
<p>给定排列 <span class="math inline">\(P\)</span>，当且仅当 <span class="math inline">\(i,\ j\)</span> 满足 <span class="math inline">\(|p_i-p_j|=1\)</span> 且 <span class="math inline">\(|i-j|\ge k\)</span> 是可以交换 <span class="math inline">\(p_i\)</span> 和 <span class="math inline">\(p_j\)</span> 求最终字典序最小的排列</p>
</blockquote>
<p>直接用题干的条件做极其困难，所以有一种十分启发性的想法</p>
<p>我们把下标和权值交换位置，即构造序列 <span class="math inline">\(q_{p_i}\ =\ i\)</span>
我们发现这样构造拥有十分好的性质</p>
<p>首先交换就变成当 <span class="math inline">\(|q_i-q_{i+1}|\ge
k\)</span> 时交换 <span class="math inline">\(q_i\)</span> 和 <span class="math inline">\(q_{i+1}\)</span> 所以对于 <span class="math inline">\(q_i\)</span> 而言，<span class="math inline">\(q_j\in\ [q_i-k+1,\ q_i+k-1]\)</span>
永远不会在它前面</p>
<p>其次，最终要求的字典序最小可以理解为下标尽量小，权值尽量小，拓扑排序过程贪心即可</p>
<p>同时我们手算样例的过程中发现建图可以优化边数，用线段树维护偏序即可</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">int</span> f = <span class="number">1</span>, <span class="keyword">int</span> x = <span class="number">0</span>, <span class="keyword">char</span> ch = <span class="string">&#x27; &#x27;</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">isdigit</span>(ch = getchar())) <span class="keyword">if</span>(ch == <span class="string">&#x27;-&#x27;</span>) f = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch)) x = x*<span class="number">10</span>+ch-<span class="string">&#x27;0&#x27;</span>, ch = getchar();</span><br><span class="line">    <span class="keyword">return</span> f*x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">5e5</span>+<span class="number">5</span>, INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> next, to; </span><br><span class="line">    Edge(<span class="keyword">int</span> next = <span class="number">0</span>, <span class="keyword">int</span> to = <span class="number">0</span>):next(next), to(to) &#123;&#125;;</span><br><span class="line">&#125;edge[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> tot, head[N], in[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123; edge[++tot] = Edge(head[x], y); head[x] = tot; ++in[y]; &#125;</span><br><span class="line"><span class="keyword">int</span> val[N&lt;&lt;<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> pos, <span class="keyword">int</span> d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    val[x] = min(val[x], d); <span class="keyword">if</span>(l == r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = (l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(pos &lt;= mid) <span class="keyword">return</span> change(x&lt;&lt;<span class="number">1</span>, l, mid, pos, d);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> change(x&lt;&lt;<span class="number">1</span>|<span class="number">1</span>, mid+<span class="number">1</span>, r, pos, d);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> ql, <span class="keyword">int</span> qr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(ql &gt; qr) <span class="keyword">return</span> INF;</span><br><span class="line">    <span class="keyword">if</span>(ql &lt;= l&amp;&amp;r &lt;= qr) <span class="keyword">return</span> val[x];</span><br><span class="line">    <span class="keyword">int</span> ret = INF, mid = (l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(ql &lt;= mid) ret = min(ret, query(x&lt;&lt;<span class="number">1</span>, l, mid, ql, qr));</span><br><span class="line">    <span class="keyword">if</span>(qr &gt; mid) ret = min(ret, query(x&lt;&lt;<span class="number">1</span>|<span class="number">1</span>, mid+<span class="number">1</span>, r, ql, qr));</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n, m, k, ans[N], p[N];</span><br><span class="line"><span class="built_in">priority_queue</span>&lt;<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &gt; q;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(val, <span class="number">0x3f</span>, <span class="keyword">sizeof</span>(val)); </span><br><span class="line">    n = read(), k = read();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) p[read()] = i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> x = n, y; x; --x)</span><br><span class="line">    &#123;</span><br><span class="line">        y = query(<span class="number">1</span>, <span class="number">1</span>, n, max(p[x]-k+<span class="number">1</span>, <span class="number">1</span>), p[x]<span class="number">-1</span>); <span class="keyword">if</span>(y != INF) add(x, y);</span><br><span class="line">        y = query(<span class="number">1</span>, <span class="number">1</span>, n, p[x]+<span class="number">1</span>, min(p[x]+k<span class="number">-1</span>, n)); <span class="keyword">if</span>(y != INF) add(x, y);</span><br><span class="line">        change(<span class="number">1</span>, <span class="number">1</span>, n, p[x], x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> x = <span class="number">1</span>; x &lt;= n; ++x) <span class="keyword">if</span>(!in[x]) q.push(<span class="built_in">make_pair</span>(-p[x], x));</span><br><span class="line">    <span class="keyword">while</span>(q.size())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> x = q.top().second; q.pop();</span><br><span class="line">        ++m; ans[p[x]] = m;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = head[x]; i; i = edge[i].next)   </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> y = edge[i].to;</span><br><span class="line">            <span class="keyword">if</span>(--in[y] == <span class="number">0</span>) q.push(<span class="built_in">make_pair</span>(-p[y], y));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>构造</tag>
        <tag>思维</tag>
        <tag>贪心</tag>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title>[LGR-059]缩小社交圈</title>
    <url>/2019/07/15/LGR-059-%E7%BC%A9%E5%B0%8F%E7%A4%BE%E4%BA%A4%E5%9C%88/</url>
    <content><![CDATA[<h2 id="题面描述">题面描述</h2>
<p>给定区间集合，交集不为空的互相连边，求所有生成树数量</p>
<h2 id="题解">题解</h2>
<p>看见生成树就想到了矩阵树定理骗分，结果发现审错题了，就自闭了</p>
<p><del>智商什么时候可以练上去啊</del></p>
<p>根据题意，最后树的形态一定是有区间可以向只有相交关系的区间连边，且后者连的区间不能与其相交，向自己子区间连边时，子区间不能相交
<a id="more"></a>
并且从中我们可以看到一个区间能被正常计算，只有当其子区间已被计算过了，所以我们需要排序，按右端点为第一关键字，左端点为第二关键字排序即可</p>
<p>最后用前缀和优化即可</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">int</span> f = <span class="number">1</span>, <span class="keyword">int</span> x = <span class="number">0</span>, <span class="keyword">char</span> ch = <span class="string">&#x27; &#x27;</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">isdigit</span>(ch = getchar())) <span class="keyword">if</span>(ch == <span class="string">&#x27;-&#x27;</span>) f =<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch)) x = x*<span class="number">10</span>+ch-<span class="string">&#x27;0&#x27;</span>, ch = getchar();</span><br><span class="line">    <span class="keyword">return</span> f*x; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">4e3</span>+<span class="number">5</span>, P = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; p[N];</span><br><span class="line"><span class="keyword">int</span> pl[N], pr[N], f[N][N], g[N][N], h[N][N], ans;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n = read();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> l = read(), r = read();</span><br><span class="line">        p[i] = <span class="built_in">make_pair</span>(r, l);</span><br><span class="line">    &#125; </span><br><span class="line">    sort(p+<span class="number">1</span>, p+<span class="number">1</span>+n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) pl[i] = p[i].second, pr[i] = p[i].first;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(pl[j] &lt; pl[i]&amp;&amp;pl[i] &lt;= pr[j]) </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> k = lower_bound(pr+<span class="number">1</span>, pr+<span class="number">1</span>+n, pl[i])-pr<span class="number">-1</span>;</span><br><span class="line">                f[i][j] = (<span class="number">1</span>+g[j][k])%P;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(pl[i] &lt;= pl[j]&amp;&amp;pr[j] &lt;= pr[i])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> k = lower_bound(pr+<span class="number">1</span>, pr+<span class="number">1</span>+n, pl[j])-pr<span class="number">-1</span>;</span><br><span class="line">                f[i][j] = (<span class="number">1</span>+g[i][k])%P;</span><br><span class="line">            &#125;  </span><br><span class="line">            ans = (ans+f[i][j])%P, g[i][j] = (g[i][j<span class="number">-1</span>]+f[i][j])%P;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>组合计数</tag>
      </tags>
  </entry>
  <entry>
    <title>[LUOGU4859]已经没有什么好害怕的了</title>
    <url>/2019/07/15/LUOGU4859-%E5%B7%B2%E7%BB%8F%E6%B2%A1%E6%9C%89%E4%BB%80%E4%B9%88%E5%A5%BD%E5%AE%B3%E6%80%95%E7%9A%84%E4%BA%86/</url>
    <content><![CDATA[<h2 id="题面描述">题面描述</h2>
<p>给定集合 <span class="math inline">\(A\)</span> 和 <span class="math inline">\(B\)</span>，求完全匹配满足 <span class="math inline">\(\sum[a_i&gt;b_i]-[a_i\le b_i]=k\)</span>
的方案数</p>
<h2 id="题解">题解</h2>
<p>首先，题意即是要求匹配满足 <span class="math inline">\(\sum[a_i&gt;b_i]=\frac{n+k}{2}\)</span>
的方案数，假设状态 <span class="math inline">\(h_{i,j}\)</span> 表示前
<span class="math inline">\(i\)</span> 个 匹配满足 <span class="math inline">\(\sum[a_k&gt;b_k]=j\)</span> 的方案数</p>
<p>考虑转移的顺序，发现对于当前决策<span class="math inline">\(a_k&gt;b_k\)</span>而言，必须考虑当前状态下有多少满足的
<span class="math inline">\(b_k\)</span>，这就要求我们一开始把两者排序，则当前符合决策的
<span class="math inline">\(b_k\)</span> 必定有 <span class="math inline">\(j\)</span> 个已选，即有转移</p>
<p><span class="math display">\[
h_{i,j}\ =\ h_{i-1,j}+h_{i-1,j-1}\times(less_i-(j-1))
\]</span> <a id="more"></a> 我们发现对于 <span class="math inline">\(h_{n,k}\)</span>
而言，我们得出并不是合法方案，因为中间放弃匹配的 <span class="math inline">\(a\)</span> 最后必须匹配，所以 <span class="math inline">\(h_{n,k}\times(n-k)!\)</span> 就是至少选出 <span class="math inline">\(k\)</span> 个匹配的方案数</p>
<p>不妨设 <span class="math inline">\(f_k\)</span> 为恰好为 <span class="math inline">\(k\)</span> 组的方案数，<span class="math inline">\(g_k\)</span> 为至少为 <span class="math inline">\(k\)</span> 组的方案数，注意到 <span class="math inline">\(f_i\)</span> 与 <span class="math inline">\(f_j\)</span> 表示的集合无交集，发现 <span class="math inline">\(f\)</span> 和 <span class="math inline">\(g\)</span> 正好满足</p>
<p><span class="math display">\[
g_k\ =\ \sum_{i=k}^n\binom{i}{k}f_k
\]</span></p>
<p>根据二项式反演</p>
<p><span class="math display">\[
f_k\ =\ \sum_{i=k}^n(-1)^{i-k}\binom{i}{k}g_k
\]</span></p>
<p>最后求解即可</p>
<p>实际上这就是广义容斥的至少到恰好的运用</p>
<p>若有集合 <span class="math inline">\(S_1\)</span>，<span class="math inline">\(S_2\)</span>，<span class="math inline">\(S_3\)</span>， ... <span class="math inline">\(S_n\)</span> 和指标集 <span class="math inline">\(\mathcal{I}\)</span>，和作用于指标集的函数 <span class="math inline">\(f\)</span> 和 <span class="math inline">\(g\)</span> 有</p>
<p><span class="math display">\[
f(I)\ =\ |\bigcap_{\alpha\in I}S_{\alpha}-\bigcup_{\alpha\notin
I}S_{\alpha}|
\]</span></p>
<p>即 <span class="math inline">\(f(I)\)</span> 满足元素恰好在指标集
<span class="math inline">\(I\)</span>
所代表的集合的交中，而不在其他不属于 <span class="math inline">\(I\)</span> 的集合中</p>
<p><span class="math display">\[
g(I)\ =\ |\bigcap_{\alpha\in I}S_{\alpha}|
\]</span></p>
<p>即 <span class="math inline">\(g(I)\)</span> 满足至少在指标集 <span class="math inline">\(I\)</span> 的元素个数</p>
<p><span class="math display">\[
g(I)\ =\ \sum_{I\subseteq J}f(J)
\]</span></p>
<p>则有</p>
<p><span class="math display">\[
f(I)\ =\ \sum_{I\subseteq J}(-1)^{|J|-|I|}g(J)
\]</span></p>
<p>而在这道题的对于我们就是把 <span class="math inline">\(S_i\)</span>
表示 <span class="math inline">\(a_i\)</span> 的所配对的 <span class="math inline">\(b_i\)</span> 有 <span class="math inline">\(a_i&gt;b_i\)</span>，在这个意义下使用广义容斥罢了</p>
<p>特别的，假如说对于 <span class="math inline">\(|I|\)</span>
一定的子集的贡献可以统一起来用组合数计算贡献时，广义容斥即派生出组合广义容斥</p>
<p>此外，对于</p>
<p><span class="math display">\[
g(I)\ =\ |\bigcup_{\alpha\in I}S_{\alpha}-\bigcup_{\alpha\notin
I}S_{\alpha}|
\]</span></p>
<p><span class="math inline">\(g(I)\)</span> 表示至多在指标集 <span class="math inline">\(I\)</span> 的元素个数，有</p>
<p><span class="math display">\[
g(I)\ =\ \sum_{J\subseteq I}f(J)
\]</span> <span class="math display">\[
f(I)\ =\ \sum_{J\subseteq I}(-1)^{|I|-|J|}g(J)  
\]</span></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">int</span> f = <span class="number">1</span>, <span class="keyword">int</span> x = <span class="number">0</span>, <span class="keyword">char</span> ch = <span class="string">&#x27; &#x27;</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">isdigit</span>(ch = getchar())) <span class="keyword">if</span>(ch == <span class="string">&#x27;-&#x27;</span>) f = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch)) x = x*<span class="number">10</span>+ch-<span class="string">&#x27;0&#x27;</span>, ch = getchar();</span><br><span class="line">    <span class="keyword">return</span> f*x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e3</span>+<span class="number">5</span>, P = <span class="number">1e9</span>+<span class="number">9</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qpow</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>( ; b; b &gt;&gt;= <span class="number">1</span>, a = <span class="number">1l</span>l*a*a%P) <span class="keyword">if</span>(b&amp;<span class="number">1</span>) ret = <span class="number">1l</span>l*ret*a%P;</span><br><span class="line">    <span class="keyword">return</span> ret; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n, k, a[N], b[N];</span><br><span class="line"><span class="keyword">int</span> h[N][N], f[N], g[N], res[N];</span><br><span class="line"><span class="keyword">int</span> fac[N], ifac[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">C</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123; <span class="keyword">return</span> <span class="number">1l</span>l*fac[n]*ifac[n-m]%P*ifac[m]%P; &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n = read(), k = read(); fac[<span class="number">0</span>] = ifac[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>((n+k)&amp;<span class="number">1</span>) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;0&quot;</span>), <span class="number">0</span>; k = (n+k)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) a[i] = read();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) b[i] = read();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) fac[i] = <span class="number">1l</span>l*fac[i<span class="number">-1</span>]*i%P; </span><br><span class="line">    ifac[n] = qpow(fac[n], P<span class="number">-2</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = n<span class="number">-1</span>; i; --i) ifac[i] = <span class="number">1l</span>l*ifac[i+<span class="number">1</span>]*(i+<span class="number">1</span>)%P;</span><br><span class="line">    sort(a+<span class="number">1</span>, a+<span class="number">1</span>+n); sort(b+<span class="number">1</span>, b+<span class="number">1</span>+n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>, p = <span class="number">0</span>; i &lt;= n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>( ; p &lt; n&amp;&amp;b[p+<span class="number">1</span>] &lt; a[i]; ++p);</span><br><span class="line">        res[i] = p;</span><br><span class="line">    &#125;</span><br><span class="line">    h[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        h[i][<span class="number">0</span>] = h[i<span class="number">-1</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; ++j)</span><br><span class="line">            h[i][j] = (h[i<span class="number">-1</span>][j]+<span class="number">1l</span>l*h[i<span class="number">-1</span>][j<span class="number">-1</span>]*max(<span class="number">0</span>, res[i]-j+<span class="number">1</span>)%P)%P;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; ++i) g[i] = <span class="number">1l</span>l*h[n][i]*fac[n-i]%P;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = k; i &lt;= n; ++i) </span><br><span class="line">        <span class="keyword">if</span>((i-k)&amp;<span class="number">1</span>) f[k] = (f[k]+P<span class="number">-1l</span>l*C(i, k)*g[i]%P)%P;</span><br><span class="line">        <span class="keyword">else</span> f[k] = (f[k]+<span class="number">1l</span>l*C(i, k)*g[i]%P)%P;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, f[k]);</span><br><span class="line">    <span class="keyword">return</span>  <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>模板</category>
      </categories>
      <tags>
        <tag>组合计数</tag>
        <tag>容斥</tag>
      </tags>
  </entry>
  <entry>
    <title>[HNOI2013]游走</title>
    <url>/2019/07/13/HNOI2013-%E6%B8%B8%E8%B5%B0/</url>
    <content><![CDATA[<h2 id="题面描述">题面描述</h2>
<p>在图上随机游走，有一个终止节点，每次经过获得该边权的分数，构造边权赋值方案，使获得的边数期望次数最小。</p>
<h2 id="题解">题解</h2>
<p>首先，初步转换为算出每条边的期望经过次数，期望经过次数小的边权大</p>
<p>之后，我们发现直接求边的期望不好求，即转化为点的期望，列出等式
<a id="more"></a> <span class="math display">\[
E(U)=[u=1]+\sum_{(u,v)\in E}
\frac{E(V)}{d_v}[\ v \ne n]
\]</span></p>
<p>意义是每次可以由四周过来，<span class="math inline">\(n\)</span>
是终止节点不能再过来，<span class="math inline">\(1\)</span>
一开始出现了一次</p>
<p>高斯消元即可</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">500</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> EPS = <span class="number">1e-6</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Matrix</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    <span class="keyword">double</span> __mat[N][N];</span><br><span class="line">    Matrix(<span class="keyword">int</span> n = <span class="number">0</span>, <span class="keyword">int</span> m = <span class="number">0</span>):n(n), m(m) &#123; <span class="built_in">memset</span>(__mat, <span class="number">0</span>, <span class="keyword">sizeof</span>(__mat)); &#125;</span><br><span class="line">    <span class="keyword">double</span>* <span class="keyword">operator</span>[] (<span class="keyword">const</span> <span class="keyword">int</span> i) &#123; <span class="keyword">return</span> __mat[i]; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">double</span> r, <span class="keyword">int</span> j)</span> </span>&#123; <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= m; ++k) __mat[j][k] += __mat[i][k]*r; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">exchange</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123; <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= m; ++k) swap(__mat[i][k], __mat[j][k]); &#125;</span><br><span class="line">&#125;A, B;</span><br><span class="line"><span class="keyword">int</span> n, m, deg[N];</span><br><span class="line"><span class="keyword">int</span> u[N*N], v[N*N];</span><br><span class="line"><span class="keyword">double</span> f[N*N], ans;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Gauss</span><span class="params">(Matrix &amp;A, Matrix &amp;B)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = A.n, p;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>, c = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(p = c; p &lt;= n&amp;&amp;<span class="built_in">fabs</span>(A[c][i]) &lt; EPS; ++p);</span><br><span class="line">        <span class="keyword">if</span>(p == n+<span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">        A.exchange(p, c); B.exchange(p, c);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = c+<span class="number">1</span>; j &lt;= n; ++j)</span><br><span class="line">            B.change(c, -A[j][i]/A[c][i], j),</span><br><span class="line">            A.change(c, -A[j][i]/A[c][i], j);</span><br><span class="line">        ++c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = n; i; --i)</span><br><span class="line">    &#123;</span><br><span class="line">        B[i][<span class="number">1</span>] /= A[i][i], A[i][i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i<span class="number">-1</span>; j; --j) B[j][<span class="number">1</span>] -= A[j][i]*B[i][<span class="number">1</span>], A[j][i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m); A = Matrix(n<span class="number">-1</span>, n<span class="number">-1</span>); B = Matrix(n<span class="number">-1</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;u[i], &amp;v[i]);</span><br><span class="line">        ++deg[u[i]], ++deg[v[i]];</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) A[i][i] = <span class="number">1</span>; B[<span class="number">1</span>][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(deg[v[i]]&amp;&amp;v[i] != n) A[u[i]][v[i]] += <span class="number">-1.0</span>/deg[v[i]];</span><br><span class="line">        <span class="keyword">if</span>(deg[u[i]]&amp;&amp;u[i] != n) A[v[i]][u[i]] += <span class="number">-1.0</span>/deg[u[i]];</span><br><span class="line">    &#125;</span><br><span class="line">    Gauss(A, B);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(u[i] != n) f[i] += B[u[i]][<span class="number">1</span>]/deg[u[i]];</span><br><span class="line">        <span class="keyword">if</span>(v[i] != n) f[i] += B[v[i]][<span class="number">1</span>]/deg[v[i]];</span><br><span class="line">    &#125;</span><br><span class="line">    sort(f+<span class="number">1</span>, f+<span class="number">1</span>+m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) ans += (m-i+<span class="number">1</span>)*f[i];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%.3lf\n&quot;</span>, ans); </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>概率期望</tag>
        <tag>高斯消元</tag>
      </tags>
  </entry>
  <entry>
    <title>[BZOJ2164]采矿</title>
    <url>/2019/07/11/BZOJ2164-%E9%87%87%E7%9F%BF/</url>
    <content><![CDATA[<h2 id="题面描述">题面描述</h2>
<p>支持修改点权，维护子树内和链上的的背包。</p>
<h2 id="题解">题解</h2>
<p>用线段树维护一下背包就好了，但不管怎么 <span class="math inline">\(O(m^2)\)</span> 常数的更新的复杂度避免不了
<a id="more"></a> <del>读入过于毒瘤</del></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> int64;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">int</span> f = <span class="number">1</span>, <span class="keyword">int</span> x = <span class="number">0</span>, <span class="keyword">char</span> ch = <span class="string">&#x27; &#x27;</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">isdigit</span>(ch = getchar())) <span class="keyword">if</span>(ch == <span class="string">&#x27;-&#x27;</span>) f = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch)) x = x*<span class="number">10</span>+ch-<span class="string">&#x27;0&#x27;</span>, ch = getchar();</span><br><span class="line">    <span class="keyword">return</span> f*x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e4</span>+<span class="number">5</span>, M = <span class="number">50</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> X = <span class="number">1</span>&lt;&lt;<span class="number">16</span>, Y = ~<span class="number">0u</span>&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> next, to;</span><br><span class="line">    Edge(<span class="keyword">int</span> next = <span class="number">0</span>, <span class="keyword">int</span> to = <span class="number">0</span>):next(next), to(to) &#123;&#125;;</span><br><span class="line">&#125;edge[N];</span><br><span class="line"><span class="keyword">int</span> tot, head[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123; edge[++tot] = Edge(head[x], y); head[x] = tot; &#125;</span><br><span class="line"><span class="keyword">int</span> n, m, A, B, Q, T;</span><br><span class="line">int64 tab[N][M];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">getint</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A=((A^B)+(B/X)+(B*X))&amp;Y;</span><br><span class="line">    B=((A^B)+(A/X)+(A*X))&amp;Y;</span><br><span class="line">    <span class="keyword">return</span> (A^B)%Q;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> fa[N], top[N], size[N], d[N], dfn[N], nfd[N], son[N], t;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    size[x] = <span class="number">1</span>, d[x] = d[fa[x]]+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = head[x]; i; i = edge[i].next)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> y = edge[i].to; dfs(y); size[x] += size[y]; </span><br><span class="line">        son[x] = size[son[x]]&gt;size[y]?son[x]:y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> topf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dfn[x] = ++t, top[x] = topf, nfd[t] = x;</span><br><span class="line">    <span class="keyword">if</span>(son[x]) dfs(son[x], topf);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = head[x]; i; i = edge[i].next)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> y = edge[i].to;</span><br><span class="line">        <span class="keyword">if</span>(son[x] != y) dfs(y, y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Bag</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    int64 f[M];</span><br><span class="line">    Bag() &#123; <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= m; ++i) f[i] = <span class="number">0</span>; &#125;</span><br><span class="line">    Bag <span class="keyword">operator</span> + (<span class="keyword">const</span> Bag &amp;_) <span class="keyword">const</span> </span><br><span class="line">    &#123;  </span><br><span class="line">        Bag ret;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= m; ++i) ret.f[i] = max(f[i], _.f[i]);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    Bag <span class="keyword">operator</span> * (<span class="keyword">const</span> Bag &amp;_) <span class="keyword">const</span> </span><br><span class="line">    &#123;</span><br><span class="line">        Bag ret;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= m; ++i)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= m-i; ++j)</span><br><span class="line">                ret.f[i+j] = max(ret.f[i+j], f[i]+_.f[j]);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;b1[N&lt;&lt;<span class="number">2</span>], b2[N&lt;&lt;<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushup</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; b1[x] = b1[x&lt;&lt;<span class="number">1</span>]+b1[x&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]; b2[x] = b2[x&lt;&lt;<span class="number">1</span>]*b2[x&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l == r) <span class="keyword">return</span> (<span class="keyword">void</span>)(<span class="built_in">memcpy</span>(b1[x].f, tab[nfd[l]], <span class="keyword">sizeof</span>(b1[x].f)), b2[x] = b1[x]);</span><br><span class="line">    <span class="keyword">int</span> mid = (l+r)&gt;&gt;<span class="number">1</span>; build(x&lt;&lt;<span class="number">1</span>, l, mid); build(x&lt;&lt;<span class="number">1</span>|<span class="number">1</span>, mid+<span class="number">1</span>, r); pushup(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> pos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l == r) <span class="keyword">return</span> (<span class="keyword">void</span>)(<span class="built_in">memcpy</span>(b1[x].f, tab[nfd[l]], <span class="keyword">sizeof</span>(b1[x].f)), b2[x] = b1[x]);</span><br><span class="line">    <span class="keyword">int</span> mid = (l+r)&gt;&gt;<span class="number">1</span>; </span><br><span class="line">    <span class="keyword">if</span>(pos &lt;= mid) change(x&lt;&lt;<span class="number">1</span>, l, mid, pos);</span><br><span class="line">    <span class="keyword">else</span> change(x&lt;&lt;<span class="number">1</span>|<span class="number">1</span>, mid+<span class="number">1</span>, r, pos);</span><br><span class="line">    pushup(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Bag <span class="title">query1</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> ql, <span class="keyword">int</span> qr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(ql &lt;= l&amp;&amp;r &lt;= qr) <span class="keyword">return</span> b1[x];</span><br><span class="line">    <span class="keyword">int</span> mid = (l+r)&gt;&gt;<span class="number">1</span>; Bag ret;</span><br><span class="line">    <span class="keyword">if</span>(ql &lt;= mid) ret = ret+query1(x&lt;&lt;<span class="number">1</span>, l, mid, ql, qr);</span><br><span class="line">    <span class="keyword">if</span>(qr &gt; mid) ret = ret+query1(x&lt;&lt;<span class="number">1</span>|<span class="number">1</span>, mid+<span class="number">1</span>, r, ql, qr);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Bag <span class="title">query2</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> ql, <span class="keyword">int</span> qr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(ql &lt;= l&amp;&amp;r &lt;= qr) <span class="keyword">return</span> b2[x];</span><br><span class="line">    <span class="keyword">int</span> mid = (l+r)&gt;&gt;<span class="number">1</span>; Bag ret;</span><br><span class="line">    <span class="keyword">if</span>(ql &lt;= mid) ret = ret*query2(x&lt;&lt;<span class="number">1</span>, l, mid, ql, qr);</span><br><span class="line">    <span class="keyword">if</span>(qr &gt; mid) ret = ret*query2(x&lt;&lt;<span class="number">1</span>|<span class="number">1</span>, mid+<span class="number">1</span>, r, ql, qr);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Bag <span class="title">query</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Bag ret; <span class="keyword">if</span>(x == y) <span class="keyword">return</span> ret; x = fa[x];</span><br><span class="line">    <span class="keyword">while</span>(top[x] != top[y]) ret = ret+query1(<span class="number">1</span>, <span class="number">1</span>, n, dfn[top[x]], dfn[x]), x = fa[top[x]];</span><br><span class="line">    ret = ret+query1(<span class="number">1</span>, <span class="number">1</span>, n, dfn[y], dfn[x]);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n = read(), m = read(), A = read(), B = read(), Q = read();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++j) tab[i][j] = getint();</span><br><span class="line">        sort(tab[i]+<span class="number">1</span>, tab[i]+m+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> x = <span class="number">2</span>; x &lt;= n; ++x) add(fa[x] = read(), x);</span><br><span class="line">    dfs(<span class="number">1</span>); dfs(<span class="number">1</span>, <span class="number">1</span>); build(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">    T = read();</span><br><span class="line">    <span class="keyword">while</span>(T--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> opt = read(), x = read(), y;</span><br><span class="line">        <span class="keyword">if</span>(opt == <span class="number">0</span>)</span><br><span class="line">        &#123;        </span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) tab[x][i] = getint();</span><br><span class="line">            sort(tab[x]+<span class="number">1</span>, tab[x]+m+<span class="number">1</span>);</span><br><span class="line">            change(<span class="number">1</span>, <span class="number">1</span>, n, dfn[x]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">        &#123;</span><br><span class="line">            y = read(); Bag ans = query(x, y)*query2(<span class="number">1</span>, <span class="number">1</span>, n, dfn[x], dfn[x]+size[x]<span class="number">-1</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans.f[m]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>线段树</tag>
        <tag>树链剖分</tag>
      </tags>
  </entry>
  <entry>
    <title>[BZOJ3589]动态树</title>
    <url>/2019/07/11/BZOJ3589-%E5%8A%A8%E6%80%81%E6%A0%91/</url>
    <content><![CDATA[<h2 id="题面描述">题面描述</h2>
<p>求若干条树链的并</p>
<h2 id="题解">题解</h2>
<p>做法有很多，首先是用容斥把树链的并转化为树链的交，或者是建出虚树，利用
<span class="math inline">\(dfs\)</span>
序虚树求值，但两者细节较多，所以直接用线段树的区间覆盖标记了
<a id="more"></a> 虚树的性质挺巧妙的，可能之后会整理</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">int</span> f = <span class="number">1</span>, <span class="keyword">int</span> x = <span class="number">0</span>, <span class="keyword">char</span> ch = <span class="string">&#x27; &#x27;</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">isdigit</span>(ch = getchar())) <span class="keyword">if</span>(ch == <span class="string">&#x27;-&#x27;</span>) f = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch)) x = x*<span class="number">10</span>+ch-<span class="string">&#x27;0&#x27;</span>, ch = getchar();</span><br><span class="line">    <span class="keyword">return</span> f*x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> next, to;</span><br><span class="line">    Edge(<span class="keyword">int</span> next = <span class="number">0</span>, <span class="keyword">int</span> to = <span class="number">0</span>):next(next), to(to) &#123;&#125;;</span><br><span class="line">&#125;edge[N&lt;&lt;<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> tot, head[N];</span><br><span class="line"><span class="keyword">void</span> _add(<span class="keyword">int</span> x, <span class="keyword">int</span> y) &#123; edge[++tot] = Edge(head[x], y); head[x] = tot; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123; _add(x, y); _add(y, x); &#125;</span><br><span class="line"><span class="keyword">int</span> n, T;</span><br><span class="line"><span class="keyword">int</span> size[N], son[N], top[N], fa[N], dfn[N], nfd[N], d[N], t;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> f)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    fa[x] = f, d[x] = d[f]+<span class="number">1</span>, size[x] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = head[x]; i; i = edge[i].next)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> y = edge[i].to; <span class="keyword">if</span>(y == f) <span class="keyword">continue</span>;</span><br><span class="line">        dfs1(y, x); size[x] += size[y];</span><br><span class="line">        son[x] = size[son[x]]&gt;size[y]?son[x]:y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> topf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    top[x] = topf, dfn[x] = ++t, nfd[t] = x;</span><br><span class="line">    <span class="keyword">if</span>(son[x]) dfs2(son[x], topf);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = head[x]; i; i = edge[i].next)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> y = edge[i].to;</span><br><span class="line">        <span class="keyword">if</span>(fa[x] == y||son[x] == y) <span class="keyword">continue</span>;</span><br><span class="line">        dfs2(y, y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> v[N&lt;&lt;<span class="number">2</span>], a[N&lt;&lt;<span class="number">2</span>], val[N&lt;&lt;<span class="number">2</span>], cov[N&lt;&lt;<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pusha</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> d)</span> </span>&#123; v[x] += d*(r-l+<span class="number">1</span>), a[x] += d; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushup</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; v[x] = v[x&lt;&lt;<span class="number">1</span>]+v[x&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]; val[x] = val[x&lt;&lt;<span class="number">1</span>]+val[x&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushc</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> d)</span> </span>&#123; val[x] = v[x]*(d<span class="number">-1</span>), cov[x] = d;  &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushdown</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mid = (l+r)&gt;&gt;<span class="number">1</span>, d = a[x]; a[x] = <span class="number">0</span>;</span><br><span class="line">    pusha(x&lt;&lt;<span class="number">1</span>, l ,mid, d); pusha(x&lt;&lt;<span class="number">1</span>|<span class="number">1</span>, mid+<span class="number">1</span>, r, d);</span><br><span class="line">    <span class="keyword">if</span>(cov[x]) pushc(x&lt;&lt;<span class="number">1</span>, cov[x]), pushc(x&lt;&lt;<span class="number">1</span>|<span class="number">1</span>, cov[x]), cov[x] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> ql, <span class="keyword">int</span> qr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(ql &lt;= l&amp;&amp;r &lt;= qr) <span class="keyword">return</span> val[x];</span><br><span class="line">    <span class="keyword">int</span> mid = (l+r)&gt;&gt;<span class="number">1</span>; <span class="keyword">int</span> ret = <span class="number">0</span>; pushdown(x, l, r);</span><br><span class="line">    <span class="keyword">if</span>(ql &lt;= mid) ret += query(x&lt;&lt;<span class="number">1</span>, l, mid, ql, qr);</span><br><span class="line">    <span class="keyword">if</span>(qr &gt; mid) ret += query(x&lt;&lt;<span class="number">1</span>|<span class="number">1</span>, mid+<span class="number">1</span>, r, ql, qr);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> ql, <span class="keyword">int</span> qr, <span class="keyword">int</span> d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(ql &lt;= l&amp;&amp;r &lt;= qr) <span class="keyword">return</span> pusha(x, l, r, d);</span><br><span class="line">    <span class="keyword">int</span> mid = (l+r)&gt;&gt;<span class="number">1</span>; pushdown(x, l, r);</span><br><span class="line">    <span class="keyword">if</span>(ql &lt;= mid) add(x&lt;&lt;<span class="number">1</span>, l, mid, ql, qr, d);</span><br><span class="line">    <span class="keyword">if</span>(qr &gt; mid) add(x&lt;&lt;<span class="number">1</span>|<span class="number">1</span>, mid+<span class="number">1</span>, r, ql, qr, d);</span><br><span class="line">    pushup(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> ql, <span class="keyword">int</span> qr, <span class="keyword">int</span> d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="keyword">if</span>(ql &lt;= l&amp;&amp;r &lt;= qr) <span class="keyword">return</span> pushc(x, d);</span><br><span class="line">    <span class="keyword">int</span> mid = (l+r)&gt;&gt;<span class="number">1</span>; pushdown(x, l, r);</span><br><span class="line">    <span class="keyword">if</span>(ql &lt;= mid) change(x&lt;&lt;<span class="number">1</span>, l, mid, ql, qr, d);</span><br><span class="line">    <span class="keyword">if</span>(qr &gt; mid) change(x&lt;&lt;<span class="number">1</span>|<span class="number">1</span>, mid+<span class="number">1</span>, r, ql, qr, d);</span><br><span class="line">    pushup(x);   </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">color</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(top[x] != top[y])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(d[top[x]] &lt; d[top[y]]) swap(x, y);</span><br><span class="line">        change(<span class="number">1</span>, <span class="number">1</span>, n, dfn[top[x]], dfn[x], <span class="number">2</span>); x = fa[top[x]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(d[x] &lt; d[y]) swap(x, y);</span><br><span class="line">    change(<span class="number">1</span>, <span class="number">1</span>, n, dfn[y], dfn[x], <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> p[N];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123; <span class="keyword">return</span> dfn[x] &lt; dfn[y]; &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n = read(); pushc(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> x = read(), y = read();</span><br><span class="line">        add(x, y);</span><br><span class="line">    &#125;</span><br><span class="line">    dfs1(<span class="number">1</span>, <span class="number">0</span>); dfs2(<span class="number">1</span>, <span class="number">1</span>); </span><br><span class="line">    T = read();</span><br><span class="line">    <span class="keyword">while</span>(T--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> opt = read(), x, y, k, ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(opt == <span class="number">0</span>) x = read(), k = read(), add(<span class="number">1</span>, <span class="number">1</span>, n, dfn[x], dfn[x]+size[x]<span class="number">-1</span>, k);</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">        &#123;</span><br><span class="line">            k = read();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; ++i) x = read(), y = read(), color(x, y);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, val[<span class="number">1</span>]&amp;<span class="number">0x7fffffff</span>); pushc(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>线段树</tag>
        <tag>树链剖分</tag>
      </tags>
  </entry>
  <entry>
    <title>CF997E Good Subsegments</title>
    <url>/2019/07/10/CF997E-Good-Subsegments/</url>
    <content><![CDATA[<h2 id="题面描述">题面描述</h2>
<p>询问区间内所有满足重排后连续的区间个数</p>
<h2 id="题解">题解</h2>
<p>第一道真正利用线段树历史标记的题</p>
<p>终于知道线段树统计子区间问题的一种方法了</p>
<p>结合 <a href="https://www.luogu.org/problemnew/show/P4747">[CERC2017]Intrinsic
Interval</a> 食用更佳</p>
<p>考虑把操作离线，枚举每个右端点 <span class="math inline">\(r\)</span>，对于左端点 <span class="math inline">\(l\)</span> 记录 <span class="math inline">\(cnt+l-r\)</span>，<span class="math inline">\(cnt\)</span> 为区间 <span class="math inline">\([l,\ r]\)</span> 的满足 <span class="math inline">\(|a-b|&lt;1\)</span> 的无序数对 <span class="math inline">\((a,\ b)\)</span> 的数量，当一个区间合法当且仅当
<span class="math inline">\(cnt+l-r=0\)</span>，其余情况 <span class="math inline">\(cnt+l-r\le
r\)</span>，在线段树上维护最大值和最大值出现次数，每次右端点移动时用合法的相邻的数统计一下即可
<a id="more"></a> 下面就是如何维护子区间的问题了，我们引入一个新的标记 <span class="math inline">\(ti\)</span>，用于累计历史最大值及其次数的贡献，每次下传时，当且仅当
<span class="math inline">\(maxv_{fa}\ =\ maxv_{son}\)</span> 是下传
<span class="math inline">\(ti\)</span>，并累计贡献，同时注意 <span class="math inline">\(add\)</span> 和 <span class="math inline">\(ti\)</span> 的顺序，应下传 <span class="math inline">\(add\)</span> 再下传 <span class="math inline">\(ti\)</span>，子节点有还未更新到合法状态</p>
<p>细节见注释</p>
<p><del>本来以为比单调栈的做法常数小，但其实差的也不多</del></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> int64;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">int</span> f = <span class="number">1</span>, <span class="keyword">int</span> x = <span class="number">0</span>, <span class="keyword">char</span> ch = <span class="string">&#x27; &#x27;</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">isdigit</span>(ch = getchar())) <span class="keyword">if</span>(ch == <span class="string">&#x27;-&#x27;</span>) f = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch)) x = x*<span class="number">10</span>+ch-<span class="string">&#x27;0&#x27;</span>, ch = getchar();</span><br><span class="line">    <span class="keyword">return</span> f*x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">12e4</span>+<span class="number">5</span>;</span><br><span class="line">int64 val[N&lt;&lt;<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> c[N&lt;&lt;<span class="number">2</span>], v[N&lt;&lt;<span class="number">2</span>], ti[N&lt;&lt;<span class="number">2</span>], a[N&lt;&lt;<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pusha</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> d)</span> </span>&#123; v[x] += d, a[x] += d; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushti</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> d)</span> </span>&#123; val[x] += d*c[x], ti[x] += d; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushdown</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a[x]) pusha(x&lt;&lt;<span class="number">1</span>, a[x]), pusha(x&lt;&lt;<span class="number">1</span>|<span class="number">1</span>, a[x]), a[x] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(ti[x]) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(v[x] == v[x&lt;&lt;<span class="number">1</span>]) pushti(x&lt;&lt;<span class="number">1</span>, ti[x]);</span><br><span class="line">        <span class="keyword">if</span>(v[x] == v[x&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]) pushti(x&lt;&lt;<span class="number">1</span>|<span class="number">1</span>, ti[x]);</span><br><span class="line">        ti[x] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushup</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    v[x] = max(v[x&lt;&lt;<span class="number">1</span>], v[x&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]); c[x] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(v[x] == v[x&lt;&lt;<span class="number">1</span>]) c[x] += c[x&lt;&lt;<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">if</span>(v[x] == v[x&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]) c[x] += c[x&lt;&lt;<span class="number">1</span>|<span class="number">1</span>];</span><br><span class="line">    val[x] = val[x&lt;&lt;<span class="number">1</span>]+val[x&lt;&lt;<span class="number">1</span>|<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l == r) <span class="keyword">return</span> <span class="keyword">void</span>(c[x] = <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> mid = (l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    build(x&lt;&lt;<span class="number">1</span>, l, mid); build(x&lt;&lt;<span class="number">1</span>|<span class="number">1</span>, mid+<span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> ql, <span class="keyword">int</span> qr, <span class="keyword">int</span> d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(ql &lt;= l&amp;&amp;r &lt;= qr) <span class="keyword">return</span> pusha(x, d);</span><br><span class="line">    <span class="keyword">int</span> mid = (l+r)&gt;&gt;<span class="number">1</span>; pushdown(x);</span><br><span class="line">    <span class="keyword">if</span>(ql &lt;= mid) change(x&lt;&lt;<span class="number">1</span>, l, mid, ql, qr, d);</span><br><span class="line">    <span class="keyword">if</span>(qr &gt; mid) change(x&lt;&lt;<span class="number">1</span>|<span class="number">1</span>, mid+<span class="number">1</span>, r, ql, qr, d);</span><br><span class="line">    pushup(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">int64 <span class="title">query</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> ql, <span class="keyword">int</span> qr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(ql &lt;= l&amp;&amp;r &lt;= qr) <span class="keyword">return</span> val[x];</span><br><span class="line">    <span class="keyword">int</span> mid = (l+r)&gt;&gt;<span class="number">1</span>; int64 ret = <span class="number">0</span>; pushdown(x);</span><br><span class="line">    <span class="keyword">if</span>(ql &lt;= mid) ret += query(x&lt;&lt;<span class="number">1</span>, l, mid, ql, qr);</span><br><span class="line">    <span class="keyword">if</span>(qr &gt; mid) ret += query(x&lt;&lt;<span class="number">1</span>|<span class="number">1</span>, mid+<span class="number">1</span>, r, ql, qr);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n, m, f[N], g[N];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &gt; s[N];</span><br><span class="line">int64 ans[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n = read(); build(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) f[i] = read(), g[f[i]] = i;</span><br><span class="line">    m = read(); </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> l = read(), r = read();</span><br><span class="line">        s[r].push_back(<span class="built_in">make_pair</span>(l, i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        pusha(<span class="number">1</span>, <span class="number">-1</span>); change(<span class="number">1</span>, <span class="number">1</span>, n, i, i, i); <span class="comment">// 只能依次加，否则 cnt+l-r &lt;= 0 性质不满足</span></span><br><span class="line">        <span class="keyword">if</span>(f[i] != <span class="number">1</span>&amp;&amp;g[f[i]<span class="number">-1</span>] &lt; i) change(<span class="number">1</span>, <span class="number">1</span>, n, <span class="number">1</span>, g[f[i]<span class="number">-1</span>], <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(f[i] != n&amp;&amp;g[f[i]+<span class="number">1</span>] &lt; i) change(<span class="number">1</span>, <span class="number">1</span>, n, <span class="number">1</span>, g[f[i]+<span class="number">1</span>], <span class="number">1</span>);</span><br><span class="line">        pushti(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; s[i].size(); ++k) </span><br><span class="line">            ans[s[i][k].second] = query(<span class="number">1</span>, <span class="number">1</span>, n, s[i][k].first, i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>模板</category>
      </categories>
      <tags>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title>[CERC2017]Intrinsic Interval</title>
    <url>/2019/07/10/CERC2017-Intrinsic-Interval/</url>
    <content><![CDATA[<h2 id="题面描述">题面描述</h2>
<p>求一个区间被包含的最短重排后连续区间。</p>
<h2 id="题解">题解</h2>
<p>判断区间是否连续有一个十分显然的做法，即判断 <span class="math inline">\(max-min=r-l\)</span>，但是这样的做法并不能很好维护</p>
<p>但我们发现该区间重排后为等差数列，所以我们可以认为一个区间满足 <span class="math inline">\(|a-b|\le 1\)</span> 的无序数对 <span class="math inline">\((a,\ b)\)</span> 个数为 <span class="math inline">\(r-l\)</span>，那么这个区间合法 <a id="more"></a>
这就十分容易维护了，把询问离线，考虑枚举右端点 <span class="math inline">\(r\)</span>，首先每次移动只会因为前面有没有和 <span class="math inline">\(p_r\)</span> 绝对值相差超过 <span class="math inline">\(1\)</span> 而产生贡献，对于每个 <span class="math inline">\(l\)</span> 维护 <span class="math inline">\(cnt+l\)</span> 的值，由于 <span class="math inline">\(cnt\le r-l\)</span>
那么在相应区间查最大值即可，在用一个堆维护合法询问，这个题就解决了</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">int</span> f = <span class="number">1</span>, <span class="keyword">int</span> x = <span class="number">0</span>, <span class="keyword">char</span> ch = <span class="string">&#x27; &#x27;</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">isdigit</span>(ch = getchar())) <span class="keyword">if</span>(ch == <span class="string">&#x27;-&#x27;</span>) f = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch)) x = x*<span class="number">10</span>+ch-<span class="string">&#x27;0&#x27;</span>, ch = getchar();</span><br><span class="line">    <span class="keyword">return</span> f*x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> val[N&lt;&lt;<span class="number">2</span>], add[N&lt;&lt;<span class="number">2</span>], p[N&lt;&lt;<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pusha</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> d)</span> </span>&#123; add[x] += d, val[x] += d; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushdown</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="keyword">if</span>(add[x]) pusha(x&lt;&lt;<span class="number">1</span>, add[x]), pusha(x&lt;&lt;<span class="number">1</span>|<span class="number">1</span>, add[x]), add[x] = <span class="number">0</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushup</span><span class="params">(<span class="keyword">int</span> x)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">if</span>(val[x&lt;&lt;<span class="number">1</span>] &gt; val[x&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]) p[x] = p[x&lt;&lt;<span class="number">1</span>], val[x] = val[x&lt;&lt;<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">else</span> val[x] = val[x&lt;&lt;<span class="number">1</span>|<span class="number">1</span>], p[x] = p[x&lt;&lt;<span class="number">1</span>|<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l == r) <span class="keyword">return</span> <span class="keyword">void</span>(val[x] = p[x] = l);</span><br><span class="line">    <span class="keyword">int</span> mid = (l+r)&gt;&gt;<span class="number">1</span>; </span><br><span class="line">    build(x&lt;&lt;<span class="number">1</span>, l, mid), build(x&lt;&lt;<span class="number">1</span>|<span class="number">1</span>, mid+<span class="number">1</span>, r);</span><br><span class="line">    pushup(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> ql, <span class="keyword">int</span> qr, <span class="keyword">int</span> d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(ql &lt;= l&amp;&amp;r &lt;= qr) <span class="keyword">return</span> pusha(x, d);</span><br><span class="line">    <span class="keyword">int</span> mid = (l+r)&gt;&gt;<span class="number">1</span>; pushdown(x);</span><br><span class="line">    <span class="keyword">if</span>(ql &lt;= mid) change(x&lt;&lt;<span class="number">1</span>, l, mid, ql, qr, d);</span><br><span class="line">    <span class="keyword">if</span>(qr &gt; mid) change(x&lt;&lt;<span class="number">1</span>|<span class="number">1</span>, mid+<span class="number">1</span>, r, ql, qr, d);</span><br><span class="line">    pushup(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> ansl, ansr;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> ql, <span class="keyword">int</span> qr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(ql &lt;= l&amp;&amp;r &lt;= qr) <span class="keyword">return</span> (<span class="keyword">void</span>)(ansl = ansr&lt;=val[x]?p[x]:ansl, ansr = max(ansr, val[x]));</span><br><span class="line">    <span class="keyword">int</span> mid = (l+r)&gt;&gt;<span class="number">1</span>; pushdown(x);</span><br><span class="line">    <span class="keyword">if</span>(ql &lt;= mid) query(x&lt;&lt;<span class="number">1</span>, l, mid, ql, qr);</span><br><span class="line">    <span class="keyword">if</span>(qr &gt; mid) query(x&lt;&lt;<span class="number">1</span>|<span class="number">1</span>, mid+<span class="number">1</span>, r, ql, qr);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; ans[N];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">valid</span><span class="params">(<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; p, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ansr = <span class="number">-1</span>; query(<span class="number">1</span>, <span class="number">1</span>, n, <span class="number">1</span>, p.first);</span><br><span class="line">    <span class="keyword">if</span>(ansr == r) <span class="keyword">return</span> ans[p.second] = <span class="built_in">make_pair</span>(ansl, ansr), <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> f[N], g[N];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &gt; s[N];</span><br><span class="line"><span class="built_in">priority_queue</span>&lt;<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &gt; q;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n = read(); build(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) f[i] = read(), g[f[i]] = i;</span><br><span class="line">    m = read();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> l = read(), r = read();</span><br><span class="line">        s[r].push_back(<span class="built_in">make_pair</span>(l, i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(f[i] != <span class="number">1</span>&amp;&amp;g[f[i]<span class="number">-1</span>] &lt; i) change(<span class="number">1</span>, <span class="number">1</span>, n, <span class="number">1</span>, g[f[i]<span class="number">-1</span>], <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(f[i] != n&amp;&amp;g[f[i]+<span class="number">1</span>] &lt; i) change(<span class="number">1</span>, <span class="number">1</span>, n, <span class="number">1</span>, g[f[i]+<span class="number">1</span>], <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; s[i].size(); ++k) q.push(s[i][k]);</span><br><span class="line">        <span class="keyword">while</span>(q.size()&amp;&amp;valid(q.top(), i)) q.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>, ans[i].first, ans[i].second);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>构造</tag>
        <tag>思维</tag>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title>[LUOGU4299]首都</title>
    <url>/2019/07/06/LUOGU4299-%E9%A6%96%E9%83%BD/</url>
    <content><![CDATA[<h2 id="题面描述">题面描述</h2>
<p>动态维护树的重心</p>
<h2 id="题解">题解</h2>
<p>树的重心就是满足以重心为根时子节点所在最大子树最小的点</p>
<p>树的重心的性质</p>
<ul>
<li>树的重心为根是子节点所在最大子树大小不超过整体的一半</li>
<li>树的所有点到重心的简单路径和最小</li>
<li>两个联通块合并时，新的树的重心必定在原来两个联通块树的重心的简单路径上</li>
</ul>
<p>简单证明一下 <a id="more"></a> 对于性质 <span class="math inline">\(1\)</span>，假如说树的重心所在子树大小超过一半，那么除去这个子树剩下的部分大小小于一半，所以一定可以向这个子树方向上调整使最大的子树大小减小</p>
<p>对于性质 <span class="math inline">\(2\)</span>，考虑最优决策点为
<span class="math inline">\(x\)</span>，所有到 <span class="math inline">\(x\)</span> 的简单路径长度之和为 <span class="math inline">\(f\)</span>，则与它相邻的节点 <span class="math inline">\(y\)</span> 到其的长度之和为 <span class="math inline">\(f+S-2size_y\)</span>那么 <span class="math inline">\(x\)</span> 比周围节点优的条件为 <span class="math inline">\(S-2size_y\ge0\)</span> 即 <span class="math inline">\(size_y\le\frac{1}{2}S\)</span>，满足重心的性质</p>
<p>对于性质 <span class="math inline">\(3\)</span>，在连线上的点的最大子树一定是重心方向上，假设不在重心方向，那么原来两个子树重心就不合法了，可以向该点调整，对于不在子树上的点，它的最大子树，方向在连线上，如果不在，那么原来没有前者优</p>
<p>这道题关键在于如何处理这条树链，我们单独把这个树链抽出来，在对应
<span class="math inline">\(splay\)</span>
上二分，求出每个节点向两个方向的最大子树，每次向更大子树移动即可</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">int</span> f = <span class="number">1</span>, <span class="keyword">int</span> x = <span class="number">0</span>, <span class="keyword">char</span> ch = <span class="string">&#x27; &#x27;</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">isdigit</span>(ch = getchar())) <span class="keyword">if</span>(ch == <span class="string">&#x27;-&#x27;</span>) f = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch)) x = x*<span class="number">10</span>+ch-<span class="string">&#x27;0&#x27;</span>, ch = getchar();</span><br><span class="line">    <span class="keyword">return</span> f*x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> n, q;</span><br><span class="line"><span class="keyword">int</span> c[N][<span class="number">2</span>], fa[N], s[N], si[N], rev[N];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">nroot</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="keyword">return</span> c[fa[x]][<span class="number">0</span>] == x||c[fa[x]][<span class="number">1</span>]  == x; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushup</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="keyword">if</span>(x) s[x] = s[c[x][<span class="number">0</span>]]+s[c[x][<span class="number">1</span>]]+si[x]+<span class="number">1</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushr</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="keyword">if</span>(x) rev[x] ^= <span class="number">1</span>, swap(c[x][<span class="number">0</span>], c[x][<span class="number">1</span>]); &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushdown</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="keyword">if</span>(rev[x]) pushr(c[x][<span class="number">0</span>]), pushr(c[x][<span class="number">1</span>]), rev[x] = <span class="number">0</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushall</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="keyword">if</span>(nroot(x)) pushall(fa[x]); pushdown(x); &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> y = fa[x], z = fa[y], k = c[y][<span class="number">1</span>] == x, w = c[x][!k];</span><br><span class="line">    <span class="keyword">if</span>(nroot(y)) c[z][c[z][<span class="number">1</span>] == y] = x; c[x][!k] = y; c[y][k] = w;</span><br><span class="line">    <span class="keyword">if</span>(w) fa[w] = y; fa[y] = x; fa[x] = z; </span><br><span class="line">    pushup(y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">splay</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    pushall(x);</span><br><span class="line">    <span class="keyword">while</span>(nroot(x))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> y = fa[x], z = fa[y];</span><br><span class="line">        <span class="keyword">if</span>(nroot(y)) rotate(c[y][<span class="number">1</span>] == x^c[z][<span class="number">1</span>] == y?x:y);</span><br><span class="line">        rotate(x);</span><br><span class="line">    &#125;</span><br><span class="line">    pushup(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">access</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> y = <span class="number">0</span>; x; x = fa[y = x])</span><br><span class="line">        splay(x), si[x] += s[c[x][<span class="number">1</span>]], si[x] -= s[c[x][<span class="number">1</span>] = y], pushup(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">makeroot</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; access(x); splay(x); pushr(x); &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">split</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123; makeroot(x); access(y); splay(y);  &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">link</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    split(x, y);</span><br><span class="line">    si[fa[x] = y] += s[x];</span><br><span class="line">    pushup(y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> f[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="keyword">return</span> x == f[x]?x:f[x] = find(f[x]); &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> is_odd, hal, sil, sir, p;</span><br><span class="line">    is_odd = s[x]&amp;<span class="number">1</span>, hal = s[x]&gt;&gt;<span class="number">1</span>, sil = sir = <span class="number">0</span>, p = n+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(x)</span><br><span class="line">    &#123;</span><br><span class="line">        pushdown(x);</span><br><span class="line">        <span class="keyword">int</span> sl = sil+s[c[x][<span class="number">0</span>]], sr = sir+s[c[x][<span class="number">1</span>]];</span><br><span class="line">        <span class="keyword">if</span>(sl &lt;= hal&amp;&amp;sr &lt;= hal&amp;&amp;(is_odd||p &gt; x)) p = x;</span><br><span class="line">        <span class="keyword">if</span>(sl &lt; sr) sil = sl+si[x]+<span class="number">1</span>, x = c[x][<span class="number">1</span>]; </span><br><span class="line">        <span class="keyword">else</span> sir = sr+si[x]+<span class="number">1</span>, x = c[x][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    splay(p); </span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> ans;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n = read(), q = read();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> x = <span class="number">1</span>; x &lt;= n; ++x) f[x] = x, s[x] = <span class="number">1</span>, ans ^= x; </span><br><span class="line">    <span class="keyword">while</span>(q--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">char</span> op[<span class="number">7</span>]; <span class="keyword">int</span> x, y, z; <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, op);</span><br><span class="line">        <span class="keyword">if</span>(op[<span class="number">0</span>] == <span class="string">&#x27;A&#x27;</span>)  </span><br><span class="line">        &#123;</span><br><span class="line">            x = read(), y = read(); </span><br><span class="line">            link(x, y); split(x = find(x), y = find(y)); z = update(y);</span><br><span class="line">            ans ^= x^y^z; f[x] = f[y] = f[z] = z;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(op[<span class="number">0</span>] == <span class="string">&#x27;Q&#x27;</span>) x = read(), <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, find(x));</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>动态树</tag>
      </tags>
  </entry>
  <entry>
    <title>[BZOJ1396]识别子串</title>
    <url>/2019/07/05/BZOJ1396-%E8%AF%86%E5%88%AB%E5%AD%90%E4%B8%B2/</url>
    <content><![CDATA[<h2 id="题目描述">题目描述</h2>
<p>求字符串每个位置被包含且出现只有一次的最短子串长度。</p>
<h2 id="题解">题解</h2>
<p><span class="math inline">\(SAM\)</span>
部分很好想，关键是如何用线段树维护，我们假设当前位置为 <span class="math inline">\(r\)</span>，对应的 <span class="math inline">\(np\)</span> 节点为 <span class="math inline">\(x\)</span>，则有左端点 <span class="math inline">\(l\ =\ r-maxlen(parent(x))\)</span> 在区间 <span class="math inline">\([l,\ r]\)</span> 内最小值为 <span class="math inline">\(maxlen(parent(x))+1\)</span> 并且对于区间 <span class="math inline">\([1,\ l-1]\)</span> 每个位置 <span class="math inline">\(i\)</span> 来说，答案更新为 <span class="math inline">\(r-i+1\)</span>，前面的信息很好维护，对于后面的位置来说，我们只需要做到单点查询，所以可以把
<span class="math inline">\(i\)</span>
挪到外面，用另外一颗线段树维护即可 <a id="more"></a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> last = <span class="number">1</span>, tot = <span class="number">1</span>, ch[N][<span class="number">26</span>], fa[N], len[N], pos[N], size[N];</span><br><span class="line"><span class="keyword">int</span> n, tax[N], p[N];</span><br><span class="line"><span class="keyword">char</span> s[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cur = ++tot, pre = last; last = tot;</span><br><span class="line">    len[cur] = len[pre]+<span class="number">1</span>; pos[len[cur]] = cur; size[cur] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(pre&amp;&amp;!ch[pre][c]) ch[pre][c] = cur, pre = fa[pre];</span><br><span class="line">    <span class="keyword">if</span>(!pre) <span class="keyword">return</span> <span class="keyword">void</span>(fa[cur] = <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> x = ch[pre][c];</span><br><span class="line">    <span class="keyword">if</span>(len[pre]+<span class="number">1</span> == len[x]) <span class="keyword">return</span> <span class="keyword">void</span>(fa[cur] = x);</span><br><span class="line">    <span class="keyword">int</span> y = ++tot; len[y] = len[pre]+<span class="number">1</span>; fa[y] = fa[x]; fa[x] = fa[cur] = y;</span><br><span class="line">    <span class="built_in">memcpy</span>(ch[y], ch[x], <span class="keyword">sizeof</span>(ch[x]));</span><br><span class="line">    <span class="keyword">while</span>(pre&amp;&amp;ch[pre][c] == x) ch[pre][c] = y, pre = fa[pre];</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Segment</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> val[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line">    Segment() &#123; <span class="built_in">memset</span>(val, <span class="number">0x3f</span>, <span class="keyword">sizeof</span>(val)); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> ql, <span class="keyword">int</span> qr, <span class="keyword">int</span> d)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(ql &gt; qr) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(ql &lt;= l&amp;&amp;r &lt;= qr) <span class="keyword">return</span> <span class="keyword">void</span>(val[x] = min(val[x], d));</span><br><span class="line">        <span class="keyword">int</span> mid = (l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(ql &lt;= mid) update(x&lt;&lt;<span class="number">1</span>, l, mid, ql, qr, d);</span><br><span class="line">        <span class="keyword">if</span>(qr &gt; mid) update(x&lt;&lt;<span class="number">1</span>|<span class="number">1</span>, mid+<span class="number">1</span>, r, ql, qr, d);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> pos)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l == r) <span class="keyword">return</span> val[x];</span><br><span class="line">        <span class="keyword">int</span> mid = (l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(pos &lt;= mid) <span class="keyword">return</span> min(val[x], query(x&lt;&lt;<span class="number">1</span>, l, mid, pos));</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> min(val[x], query(x&lt;&lt;<span class="number">1</span>|<span class="number">1</span>, mid+<span class="number">1</span>, r, pos));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;a, b;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s+<span class="number">1</span>); n = <span class="built_in">strlen</span>(s+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) insert(s[i]-<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= tot; ++i) ++tax[len[i]];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= tot; ++i) tax[i] += tax[i<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= tot; ++i) p[tax[len[i]]--] = i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = tot; i; --i) size[fa[p[i]]] += size[p[i]];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> x = pos[i]; <span class="keyword">if</span>(size[x] &gt; <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">        a.update(<span class="number">1</span>, <span class="number">1</span>, n, i-len[fa[x]], i, len[fa[x]]+<span class="number">1</span>);</span><br><span class="line">        b.update(<span class="number">1</span>, <span class="number">1</span>, n, <span class="number">1</span>, i-len[fa[x]]<span class="number">-1</span>, i+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, min(a.query(<span class="number">1</span>, <span class="number">1</span>, n, i), b.query(<span class="number">1</span>, <span class="number">1</span>, n, i)-i));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>思维</tag>
        <tag>线段树</tag>
        <tag>后缀自动机</tag>
      </tags>
  </entry>
  <entry>
    <title>SP8093 JZPGYZ - Sevenk Love Oimaster</title>
    <url>/2019/07/05/SP8093-JZPGYZ-Sevenk-Love-Oimaster/</url>
    <content><![CDATA[<h2 id="题面描述">题面描述</h2>
<p>给定n个模板串，以及m个查询串，查询每一个查询串是多少个模板串的子串</p>
<h2 id="题解">题解</h2>
<p>广义后缀自动机匹配和子树数颜色，后者用启发式合并即可</p>
<p><del>广义后缀自动机的拓扑序又双叒叕挂掉了，上次口胡的解决方法错了，我不想建树啊，谁来救救蒟蒻啊啊啊啊</del>
<a id="more"></a> <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> n, q;</span><br><span class="line"><span class="keyword">char</span> s[N];</span><br><span class="line"><span class="keyword">int</span> ch[N][<span class="number">26</span>], tot = <span class="number">1</span>, last = <span class="number">1</span>, fa[N], len[N], size[N];</span><br><span class="line"><span class="keyword">int</span> tax[N], p[N];</span><br><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; f[N];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; son[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cur = ++tot, pre = last; last = cur;</span><br><span class="line">    len[cur] = len[pre]+<span class="number">1</span>; </span><br><span class="line">    <span class="keyword">while</span>(pre&amp;&amp;!ch[pre][c]) ch[pre][c] = cur, pre = fa[pre];</span><br><span class="line">    <span class="keyword">if</span>(!pre) <span class="keyword">return</span> <span class="keyword">void</span>(fa[cur] = <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> x = ch[pre][c];</span><br><span class="line">    <span class="keyword">if</span>(len[pre]+<span class="number">1</span> == len[x]) <span class="keyword">return</span> <span class="keyword">void</span>(fa[cur] = x);</span><br><span class="line">    <span class="keyword">int</span> y = ++tot; fa[y] = fa[x]; fa[x] = fa[cur] = y; len[y] = len[pre]+<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">memcpy</span>(ch[y], ch[x], <span class="keyword">sizeof</span>(ch[x]));</span><br><span class="line">    <span class="keyword">while</span>(pre&amp;&amp;ch[pre][c] == x) ch[pre][c] = y, pre = fa[pre];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; son[x].size(); ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> y = son[x][i]; dfs(y);</span><br><span class="line">        <span class="keyword">if</span>(f[x].size() &lt; f[y].size()) swap(f[x], f[y]);</span><br><span class="line">        f[x].insert(f[y].begin(), f[y].end()); f[y].clear();</span><br><span class="line">    &#125;</span><br><span class="line">    size[x] = f[x].size();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;q);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s); last = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; s[k]; ++k) insert(s[k]-<span class="string">&#x27;a&#x27;</span>), f[last].insert(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= tot; ++i) son[fa[i]].push_back(i); dfs(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">while</span>(q--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s);</span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">1</span>, lcs = <span class="number">0</span>, strl = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; s[i]; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(x&amp;&amp;!ch[x][s[i]-<span class="string">&#x27;a&#x27;</span>]) x = fa[x], lcs = len[x];</span><br><span class="line">            <span class="keyword">if</span>(!x) x = <span class="number">1</span>, lcs = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span> x = ch[x][s[i]-<span class="string">&#x27;a&#x27;</span>], ++lcs;</span><br><span class="line">            ++strl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, size[x]*(lcs == strl));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>后缀自动机</tag>
        <tag>启发式合并</tag>
      </tags>
  </entry>
  <entry>
    <title>[HEOI2015]最短不公共子串</title>
    <url>/2019/07/05/HEOI2015-%E6%9C%80%E7%9F%AD%E4%B8%8D%E5%85%AC%E5%85%B1%E5%AD%90%E4%B8%B2/</url>
    <content><![CDATA[<h2 id="题面描述">题面描述</h2>
<p>求两个字符串最短不公共子序列和子串</p>
<h2 id="题解">题解</h2>
<p>我们需要两个自动机，一个可以接受所有子串，另一个可以接受所有子序列，前者我们可以使用
<span class="math inline">\(SAM\)</span>，后者我们要构造一个叫做序列自动机的东西</p>
<p>序列自动机的构造不难理解，记录每个字符上一个出现位置，连转移边即可，构造复杂度为
<span class="math inline">\(O(n|S|)\)</span>，感性理解下就是每一次加入的复杂度等价为从这一次加入到上一加入之间有多少字符，单看每个字符这个整体求和后是
<span class="math inline">\(O(n)\)</span>，字符集大小为 <span class="math inline">\(|S|\)</span>，所以复杂度为 <span class="math inline">\(O(n|S|)\)</span> <a id="more"></a> <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Sqam</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> root, tot, last[<span class="number">26</span>], pre[N], ch[N][<span class="number">26</span>];</span><br><span class="line">    Sqam() &#123; root = tot = <span class="number">1</span>; <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; ++i) last[i] = <span class="number">1</span>;  &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cur = ++tot; pre[cur] = last[c];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; ++i)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = last[i]; k&amp;&amp;!ch[k][c]; k = pre[k])</span><br><span class="line">                ch[k][c] = cur;</span><br><span class="line">        last[c] = cur;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>那么这题就用 <span class="math inline">\(BFS\)</span>
暴力匹配即可</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;tuple&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">4e3</span>+<span class="number">5</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Sam</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> tot = <span class="number">1</span>, last = <span class="number">1</span>, ch[N][<span class="number">26</span>], len[N], fa[N];</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cur = ++tot, pre = last; last = tot;</span><br><span class="line">        len[cur] = len[pre]+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(pre&amp;&amp;!ch[pre][c]) ch[pre][c] = cur, pre = fa[pre];</span><br><span class="line">        <span class="keyword">if</span>(!pre) <span class="keyword">return</span> <span class="keyword">void</span>(fa[cur] = <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> x = ch[pre][c];</span><br><span class="line">        <span class="keyword">if</span>(len[x] == len[pre]+<span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">void</span>(fa[cur] = x);</span><br><span class="line">        <span class="keyword">int</span> y = ++tot; fa[y] = fa[x]; fa[cur] = fa[x] = y; len[y] = len[pre]+<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">memcpy</span>(ch[y], ch[x], <span class="keyword">sizeof</span>(ch[x]));</span><br><span class="line">        <span class="keyword">while</span>(pre&amp;&amp;ch[pre][c] == x) ch[pre][c] = y, pre = fa[pre]; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;sama, samb;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Sqam</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> root, tot, last[<span class="number">26</span>], pre[N], ch[N][<span class="number">26</span>];</span><br><span class="line">    Sqam() &#123; root = tot = <span class="number">1</span>; <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; ++i) last[i] = <span class="number">1</span>;  &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cur = ++tot; pre[cur] = last[c];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; ++i)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = last[i]; k&amp;&amp;!ch[k][c]; k = pre[k])</span><br><span class="line">                ch[k][c] = cur;</span><br><span class="line">        last[c] = cur;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;sqama, sqamb;</span><br><span class="line"><span class="keyword">char</span> s[N];</span><br><span class="line"><span class="keyword">int</span> d[N][N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bfs1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &gt; q;</span><br><span class="line">    <span class="built_in">memset</span>(d, <span class="number">0</span>, <span class="keyword">sizeof</span>(d));</span><br><span class="line">    d[<span class="number">1</span>][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    q.push(<span class="built_in">make_pair</span>(<span class="number">1</span>, <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">while</span>(q.size())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> xa = q.front().first, xb = q.front().second; q.pop();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> ya = sama.ch[xa][i], yb = samb.ch[xb][i];</span><br><span class="line">            <span class="keyword">if</span>(ya&amp;&amp;yb&amp;&amp;!d[ya][yb]) d[ya][yb] = d[xa][xb]+<span class="number">1</span>, q.push(<span class="built_in">make_pair</span>(ya, yb));</span><br><span class="line">            <span class="keyword">if</span>(ya&amp;&amp;!yb) <span class="keyword">return</span> d[xa][xb];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bfs2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &gt; q;</span><br><span class="line">    <span class="built_in">memset</span>(d, <span class="number">0</span>, <span class="keyword">sizeof</span>(d)); </span><br><span class="line">    d[<span class="number">1</span>][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    q.push(<span class="built_in">make_pair</span>(<span class="number">1</span>, <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">while</span>(q.size())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> xa = q.front().first, xb = q.front().second; q.pop();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> ya = sama.ch[xa][i], yb = sqamb.ch[xb][i];</span><br><span class="line">            <span class="keyword">if</span>(ya&amp;&amp;yb&amp;&amp;!d[ya][yb]) d[ya][yb] = d[xa][xb]+<span class="number">1</span>, q.push(<span class="built_in">make_pair</span>(ya, yb));</span><br><span class="line">            <span class="keyword">if</span>(ya&amp;&amp;!yb) <span class="keyword">return</span> d[xa][xb];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bfs3</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &gt; q;</span><br><span class="line">    <span class="built_in">memset</span>(d, <span class="number">0</span>, <span class="keyword">sizeof</span>(d));</span><br><span class="line">    d[<span class="number">1</span>][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    q.push(<span class="built_in">make_pair</span>(<span class="number">1</span>, <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">while</span>(q.size())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> xa = q.front().first, xb = q.front().second; q.pop();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> ya = sqama.ch[xa][i], yb = samb.ch[xb][i];</span><br><span class="line">            <span class="keyword">if</span>(ya&amp;&amp;yb&amp;&amp;!d[ya][yb]) d[ya][yb] = d[xa][xb]+<span class="number">1</span>, q.push(<span class="built_in">make_pair</span>(ya, yb));</span><br><span class="line">            <span class="keyword">if</span>(ya&amp;&amp;!yb) <span class="keyword">return</span> d[xa][xb];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bfs4</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &gt; q;</span><br><span class="line">    <span class="built_in">memset</span>(d, <span class="number">0</span>, <span class="keyword">sizeof</span>(d));</span><br><span class="line">    d[<span class="number">1</span>][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    q.push(<span class="built_in">make_pair</span>(<span class="number">1</span>, <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">while</span>(q.size())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> xa = q.front().first, xb = q.front().second; q.pop();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> ya = sqama.ch[xa][i], yb = sqamb.ch[xb][i];</span><br><span class="line">            <span class="keyword">if</span>(ya&amp;&amp;yb&amp;&amp;!d[ya][yb]) d[ya][yb] = d[xa][xb]+<span class="number">1</span>, q.push(<span class="built_in">make_pair</span>(ya, yb));</span><br><span class="line">            <span class="keyword">if</span>(ya&amp;&amp;!yb) <span class="keyword">return</span> d[xa][xb];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; s[i]; ++i) </span><br><span class="line">        sama.insert(s[i]-<span class="string">&#x27;a&#x27;</span>), sqama.insert(s[i]-<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; s[i]; ++i) </span><br><span class="line">        samb.insert(s[i]-<span class="string">&#x27;a&#x27;</span>), sqamb.insert(s[i]-<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n%d\n%d\n%d\n&quot;</span>, bfs1(), bfs2(), bfs3(), bfs4());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>模板</category>
      </categories>
      <tags>
        <tag>后缀自动机</tag>
        <tag>序列自动机</tag>
      </tags>
  </entry>
  <entry>
    <title>[十二省联考2019]字符串问题</title>
    <url>/2019/07/04/%E5%8D%81%E4%BA%8C%E7%9C%81%E8%81%94%E8%80%832019-%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h2 id="题目描述">题目描述</h2>
<p>给定子串集合 <span class="math inline">\(A\)</span> 和 <span class="math inline">\(B\)</span>，和支配关系，构造最长目标串满足由 <span class="math inline">\(A\)</span> 构成，对于相邻 <span class="math inline">\(A\)</span>，后一个存在前缀为 <span class="math inline">\(B\)</span>，且被 <span class="math inline">\(A\)</span> 支配</p>
<h2 id="题解">题解</h2>
<p>很明显，这道题的目的是优化建图，由于在练习 <span class="math inline">\(SAM\)</span>，所以就不考虑 <span class="math inline">\(SA\)</span> 了</p>
<p>对于原串建一颗后缀树，发现题目中的建边正好是对于后缀树子树的连边，直接
<span class="math inline">\(DFS\)</span>
序搞一下线段树优化建图跑个拓扑就行了</p>
<p>但注意，对于倍增向上跳的节点对于后 <span class="math inline">\(20\)</span>
分不完全合法，只向部分连边，所以当时口胡的做法是每个节点按长度在排个序，再搞一次线段树优化建图就行了
<a id="more"></a> 但嫌麻烦直接打了个暴力交了，居然水过去了</p>
<p>一定要算好空间，<del>两次死在空间上</del></p>
<p>最后注意 <span class="math inline">\(long\ long\)</span>
<del>神仙数据构造</del></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> int64;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">int</span> f = <span class="number">1</span>, <span class="keyword">int</span> x = <span class="number">0</span>, <span class="keyword">char</span> ch = <span class="string">&#x27; &#x27;</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">isdigit</span>(ch = getchar())) <span class="keyword">if</span>(ch == <span class="string">&#x27;-&#x27;</span>) f = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch)) x = x*<span class="number">10</span>+ch-<span class="string">&#x27;0&#x27;</span>, ch = getchar();</span><br><span class="line">    <span class="keyword">return</span> f*x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">4e6</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> T;</span><br><span class="line"><span class="keyword">int</span> ns, na, nb, n, m;</span><br><span class="line"><span class="keyword">int</span> last = <span class="number">1</span>, tot = <span class="number">1</span>, ch[N][<span class="number">26</span>], fa[N], len[N], pos[N];</span><br><span class="line"><span class="keyword">char</span> s[N];</span><br><span class="line"><span class="keyword">int</span> p[N], tax[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cur = ++tot, pre = last; last = cur;</span><br><span class="line">    len[cur] = len[pre]+<span class="number">1</span>; pos[ns-len[cur]+<span class="number">1</span>] = cur;</span><br><span class="line">    <span class="keyword">while</span>(pre&amp;&amp;!ch[pre][c]) ch[pre][c] = cur, pre = fa[pre];</span><br><span class="line">    <span class="keyword">if</span>(!pre) <span class="keyword">return</span> <span class="keyword">void</span>(fa[cur] = <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> x = ch[pre][c];</span><br><span class="line">    <span class="keyword">if</span>(len[pre]+<span class="number">1</span> == len[x]) <span class="keyword">return</span> <span class="keyword">void</span>(fa[cur] = x);</span><br><span class="line">    <span class="keyword">int</span> y = ++tot; fa[y] = fa[x]; fa[x] = fa[cur] = y; len[y] = len[pre]+<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">memcpy</span>(ch[y], ch[x], <span class="keyword">sizeof</span>(ch[y]));</span><br><span class="line">    <span class="keyword">while</span>(pre&amp;&amp;ch[pre][c] == x) ch[pre][c] = y, pre = fa[pre];</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &gt; sub[N];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; edge[N];</span><br><span class="line"><span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; b[N];</span><br><span class="line"><span class="keyword">int</span> seg[N], in[N], out[N], ac[<span class="number">20</span>][N], w[N], deg[N], dfn[N], t;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123; edge[x].push_back(y); ++deg[y]; &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">19</span>; ~i; --i) <span class="keyword">if</span>(len[ac[i][x]] &gt;= d) x = ac[i][x];</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    in[x] = ++t; dfn[t] = x;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; edge[x].size(); ++i) dfs(edge[x][i]);</span><br><span class="line">    out[x] = t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    seg[x] = ++n;</span><br><span class="line">    <span class="keyword">if</span>(l == r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sub[dfn[l]].size(); ++i)</span><br><span class="line">            add(seg[x], sub[dfn[l]][i].second);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        build(x&lt;&lt;<span class="number">1</span>, l, mid); build(x&lt;&lt;<span class="number">1</span>|<span class="number">1</span>, mid+<span class="number">1</span>, r);</span><br><span class="line">        add(seg[x], seg[x&lt;&lt;<span class="number">1</span>]); add(seg[x], seg[x&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> ql, <span class="keyword">int</span> qr, <span class="keyword">int</span> d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(ql &lt;= l&amp;&amp;r &lt;= qr) <span class="keyword">return</span> add(d, seg[x]);</span><br><span class="line">    <span class="keyword">int</span> mid = (l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(ql &lt;= mid) update(x&lt;&lt;<span class="number">1</span>, l, mid, ql, qr, d);</span><br><span class="line">    <span class="keyword">if</span>(qr &gt; mid) update(x&lt;&lt;<span class="number">1</span>|<span class="number">1</span>, mid+<span class="number">1</span>, r, ql, qr, d);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">int64 f[N];</span><br><span class="line"><span class="function">int64 <span class="title">topo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    int64 ret = <span class="number">0</span>; <span class="keyword">int</span> cnt = <span class="number">0</span>; <span class="built_in">memset</span>(f, <span class="number">0</span>, <span class="keyword">sizeof</span>(f));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> x = <span class="number">1</span>; x &lt;= n; ++x) <span class="keyword">if</span>(!deg[x]) q.push(x);</span><br><span class="line">    <span class="keyword">while</span>(q.size())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> x = q.front(); q.pop(); </span><br><span class="line">        f[x] += w[x]; ++cnt;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; edge[x].size(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> y = edge[x][i];</span><br><span class="line">            f[y] = max(f[x], f[y]);</span><br><span class="line">            <span class="keyword">if</span>(--deg[y] == <span class="number">0</span>) q.push(y);</span><br><span class="line">        &#125;</span><br><span class="line">        ret = max(f[x], ret);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt == n?ret:<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    T = read();</span><br><span class="line">    <span class="keyword">while</span>(T--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s+<span class="number">1</span>); ns = <span class="built_in">strlen</span>(s+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = ns; i; --i) insert(s[i]-<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= tot; ++i) ++tax[len[i]];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= tot; ++i) tax[i] += tax[i<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = tot; i; --i) p[tax[len[i]]--] = i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= tot; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> x = p[i]; ac[<span class="number">0</span>][x] = fa[x]; edge[fa[x]].push_back(x);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>; k &lt; <span class="number">20</span>; ++k) ac[k][x] = ac[k<span class="number">-1</span>][ac[k<span class="number">-1</span>][x]];</span><br><span class="line">        &#125; </span><br><span class="line">        dfs(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= tot; ++i) edge[i].clear();</span><br><span class="line"></span><br><span class="line">        na = read(); n = na;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> l = read(), r = read(); w[i] = r-l+<span class="number">1</span>;</span><br><span class="line">            sub[find(pos[l], r-l+<span class="number">1</span>)].push_back(<span class="built_in">make_pair</span>(r-l+<span class="number">1</span>, i));</span><br><span class="line">        &#125;</span><br><span class="line">        build(<span class="number">1</span>, <span class="number">1</span>, tot);</span><br><span class="line"></span><br><span class="line">        nb = read();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= nb; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> l = read(), r = read();</span><br><span class="line">            b[i] = <span class="built_in">make_pair</span>(find(pos[l], r-l+<span class="number">1</span>), r-l+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        m = read();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> u = read(), v = read(), x = b[v].first;</span><br><span class="line">            <span class="keyword">if</span>(in[x] &lt; out[x]) update(<span class="number">1</span>, <span class="number">1</span>, tot, in[x]+<span class="number">1</span>, out[x], u);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; sub[x].size(); ++k)</span><br><span class="line">                <span class="keyword">if</span>(b[v].second &lt;= sub[x][k].first) </span><br><span class="line">                    add(u, sub[x][k].second);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, topo());</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= tot; ++i) </span><br><span class="line">            <span class="built_in">memset</span>(ch[i], <span class="number">0</span>, <span class="keyword">sizeof</span>(ch[i])),</span><br><span class="line">            sub[i].clear(),</span><br><span class="line">            fa[i] = len[i] = pos[i] = p[i] = tax[i] = <span class="number">0</span>;</span><br><span class="line">        tot = last = <span class="number">1</span>; t = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) edge[i].clear(), w[i] = <span class="number">0</span>, deg[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>线段树</tag>
        <tag>后缀自动机</tag>
      </tags>
  </entry>
  <entry>
    <title>CF786B Legacy</title>
    <url>/2019/07/04/CF786B-Legacy/</url>
    <content><![CDATA[<h2 id="题面描述">题面描述</h2>
<p>支持区间向单点连边的单源最短路问题。</p>
<h2 id="题解">题解</h2>
<p>线段树优化建图模板题，建立两个线段树，一个由内向外连，一个由外向内连即可，具体细节就按照线段树区间操作口胡一下就好了
<a id="more"></a> <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> int64;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">int</span> f = <span class="number">1</span>, <span class="keyword">int</span> x = <span class="number">0</span>, <span class="keyword">char</span> ch = <span class="string">&#x27; &#x27;</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">isdigit</span>(ch = getchar())) <span class="keyword">if</span>(ch == <span class="string">&#x27;-&#x27;</span>) f = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch)) x = x*<span class="number">10</span>+ch-<span class="string">&#x27;0&#x27;</span>, ch = getchar();</span><br><span class="line">    <span class="keyword">return</span> f*x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">3e6</span>+<span class="number">5</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> next, to, w;</span><br><span class="line">    Edge(<span class="keyword">int</span> next = <span class="number">0</span>, <span class="keyword">int</span> to = <span class="number">0</span>, <span class="keyword">int</span> w = <span class="number">0</span>):next(next), to(to), w(w) &#123;&#125;;</span><br><span class="line">&#125;edge[N];</span><br><span class="line"><span class="keyword">int</span> tot, head[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> z)</span> </span>&#123; edge[++tot] = Edge(head[x], y, z); head[x] = tot; &#125;</span><br><span class="line"><span class="keyword">int</span> n, m, q, s;</span><br><span class="line">int64 d[N];</span><br><span class="line"><span class="keyword">int</span> in[N], out[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l == r) <span class="keyword">return</span> <span class="keyword">void</span>(in[x] = out[x] = l);</span><br><span class="line">    <span class="keyword">int</span> mid = (l+r)&gt;&gt;<span class="number">1</span>; in[x] = ++m; out[x] = ++m;</span><br><span class="line">    build(x&lt;&lt;<span class="number">1</span>, l, mid); build(x&lt;&lt;<span class="number">1</span>|<span class="number">1</span>, mid+<span class="number">1</span>, r);</span><br><span class="line">    add(in[x], in[x&lt;&lt;<span class="number">1</span>], <span class="number">0</span>); add(in[x], in[x&lt;&lt;<span class="number">1</span>|<span class="number">1</span>], <span class="number">0</span>);</span><br><span class="line">    add(out[x&lt;&lt;<span class="number">1</span>], out[x], <span class="number">0</span>); add(out[x&lt;&lt;<span class="number">1</span>|<span class="number">1</span>], out[x], <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">outUpdate</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> ql, <span class="keyword">int</span> qr, <span class="keyword">int</span> d, <span class="keyword">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(ql &lt;= l&amp;&amp;r &lt;= qr) <span class="keyword">return</span> add(out[x], d, w);</span><br><span class="line">    <span class="keyword">int</span> mid = (l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(ql &lt;= mid) outUpdate(x&lt;&lt;<span class="number">1</span>, l, mid, ql, qr, d, w);</span><br><span class="line">    <span class="keyword">if</span>(qr &gt; mid) outUpdate(x&lt;&lt;<span class="number">1</span>|<span class="number">1</span>, mid+<span class="number">1</span>, r, ql, qr, d, w);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inUpdate</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> ql, <span class="keyword">int</span> qr, <span class="keyword">int</span> d, <span class="keyword">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(ql &lt;= l&amp;&amp;r &lt;= qr) <span class="keyword">return</span> add(d, in[x], w);</span><br><span class="line">    <span class="keyword">int</span> mid = (l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(ql &lt;= mid) inUpdate(x&lt;&lt;<span class="number">1</span>, l, mid, ql, qr, d, w);</span><br><span class="line">    <span class="keyword">if</span>(qr &gt; mid) inUpdate(x&lt;&lt;<span class="number">1</span>|<span class="number">1</span>, mid+<span class="number">1</span>, r, ql, qr, d, w);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n = read(), q = read(), s = read(); m = n;</span><br><span class="line">    build(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= q; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> op = read(), v = read(), u, l, r, w;</span><br><span class="line">        <span class="keyword">if</span>(op == <span class="number">1</span>) u = read(), w = read(), add(v, u, w);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(op == <span class="number">2</span>) l = read(), r = read(), w = read(), inUpdate(<span class="number">1</span>, <span class="number">1</span>, n, l, r, v, w);</span><br><span class="line">        <span class="keyword">else</span> l = read(), r = read(), w = read(), outUpdate(<span class="number">1</span>, <span class="number">1</span>, n, l, r, v, w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(d, <span class="number">0x3f</span>, <span class="keyword">sizeof</span>(d)); d[s] = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">priority_queue</span>&lt;<span class="built_in">pair</span>&lt;int64, <span class="keyword">int</span>&gt; &gt; q; q.push(<span class="built_in">make_pair</span>(<span class="number">0</span>, s));</span><br><span class="line">    <span class="keyword">while</span>(q.size())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> x = q.top().second;</span><br><span class="line">        int64 dx = -q.top().first; q.pop();</span><br><span class="line">        <span class="keyword">if</span>(dx != d[x]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = head[x]; i; i = edge[i].next)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> y = edge[i].to, z = edge[i].w;</span><br><span class="line">            <span class="keyword">if</span>(d[y] &gt; d[x]+z) d[y] = d[x]+z, q.push(<span class="built_in">make_pair</span>(-d[y], y));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> x = <span class="number">1</span>; x &lt;= n; ++x) <span class="built_in">printf</span>(<span class="string">&quot;%lld &quot;</span>, d[x]^d[<span class="number">0</span>]?d[x]:<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>题解</category>
        <category>模板</category>
      </categories>
      <tags>
        <tag>线段树</tag>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title>[NOI2018]你的名字</title>
    <url>/2019/07/02/NOI2018-%E4%BD%A0%E7%9A%84%E5%90%8D%E5%AD%97/</url>
    <content><![CDATA[<h2 id="题面描述">题面描述</h2>
<p>求一个字符串的连续非空子串与询问串本质不同的非公共子串个数</p>
<h2 id="题解">题解</h2>
<p>一开始没看到本质不同，第二个下发数据完全不一致才发现</p>
<p>如果我们要求一个字符串的本质不同子串个数，那么我们只需要对于 <span class="math inline">\(Parent\)</span> 树上的每一个节点 <span class="math inline">\(x\)</span> 累计求和 <span class="math inline">\(maxlen(x)-maxlen(parent(x))\)</span></p>
<p>现在，又多了一个字符串，导致每个节点产生和原来不一致的贡献，考虑每个节点表示的子串是相应
<span class="math inline">\(endpos\)</span>
前缀的后缀，也就是说对于每个位置，我们处理下以该位置结尾的前缀与另一个字符串某一子串
<span class="math inline">\(LCS\)</span> 的最大值 <span class="math inline">\(L\)</span>，处理一下 <span class="math inline">\((0,\ L]\)</span> 和 <span class="math inline">\((maxlen(parent(x)), maxlen(x)]\)</span>
的区间交算下贡献即可，<span class="math inline">\(L\)</span>
可以通过后缀自动机上的匹配解决 <a id="more"></a>
之后题目又加上区间的限制，那么我们匹配到一个节点 <span class="math inline">\(x\)</span> 后需要不停判断该节点是否符合条件，二分
<span class="math inline">\(L\)</span>，找到 <span class="math inline">\(L\)</span> 对应的 <span class="math inline">\(x\)</span> 的祖先，判断在 <span class="math inline">\([l+L-1,\ r]\)</span> 有没有 <span class="math inline">\(endpos\)</span> 即可</p>
<p>因为倍增顺序写反调了一下午的蒟蒻的代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> int64;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">int</span> f = <span class="number">1</span>, <span class="keyword">int</span> x = <span class="number">0</span>, <span class="keyword">char</span> ch = <span class="string">&#x27; &#x27;</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">isdigit</span>(ch = getchar())) <span class="keyword">if</span>(ch == <span class="string">&#x27;-&#x27;</span>) f = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch)) x = x*<span class="number">10</span>+ch-<span class="string">&#x27;0&#x27;</span>, ch = getchar();</span><br><span class="line">    <span class="keyword">return</span> f*x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> n, q;</span><br><span class="line"><span class="keyword">int</span> root[N], val[N&lt;&lt;<span class="number">6</span>], tot, ls[N&lt;&lt;<span class="number">6</span>], rs[N&lt;&lt;<span class="number">6</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> &amp;x, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> pos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!x) x = ++tot; val[x] |= <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(l == r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = (l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(pos &lt;= mid) <span class="keyword">return</span> add(ls[x], l, mid, pos);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> add(rs[x], mid+<span class="number">1</span>, r, pos);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> ql, <span class="keyword">int</span> qr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(ql &gt; qr) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(!x||(ql &lt;= l&amp;&amp;r &lt;= qr)) <span class="keyword">return</span> val[x];</span><br><span class="line">    <span class="keyword">int</span> mid = (l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(ql &lt;= mid&amp;&amp;query(ls[x], l, mid, ql, qr)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(qr &gt; mid&amp;&amp;query(rs[x], mid+<span class="number">1</span>, r, ql, qr)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!x||!y) <span class="keyword">return</span> x|y;</span><br><span class="line">    <span class="keyword">int</span> z = ++tot; </span><br><span class="line">    val[z] = val[x]|val[y];</span><br><span class="line">    ls[z] = merge(ls[x], ls[y]);</span><br><span class="line">    rs[z] = merge(rs[x], rs[y]);</span><br><span class="line">    <span class="keyword">return</span> z;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">char</span> s[N];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Sam</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> tot = <span class="number">1</span>, last = <span class="number">1</span>, ch[N][<span class="number">26</span>], fa[N], len[N], ac[<span class="number">20</span>][N], w[N];</span><br><span class="line">    int64 ans;</span><br><span class="line">    <span class="keyword">int</span> tax[N], p[N];</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= tot; ++i)</span><br><span class="line">            <span class="built_in">memset</span>(ch[i], <span class="number">0</span>, <span class="keyword">sizeof</span>(ch[i])),</span><br><span class="line">            fa[i] = w[i] = tax[i] = <span class="number">0</span>;    </span><br><span class="line">        tot = <span class="number">1</span>, last = <span class="number">1</span>, ans = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> c, <span class="keyword">int</span> val = <span class="number">-1</span>)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cur = ++tot, pre = last; last = cur;</span><br><span class="line">        len[cur] = len[pre]+<span class="number">1</span>; </span><br><span class="line">        <span class="keyword">if</span>(val == <span class="number">-1</span>) add(root[cur], <span class="number">1</span>, n, len[cur]); <span class="keyword">else</span> w[cur] = val;</span><br><span class="line">        <span class="keyword">while</span>(pre&amp;&amp;!ch[pre][c]) ch[pre][c] = cur, pre = fa[pre];</span><br><span class="line">        <span class="keyword">if</span>(!pre) <span class="keyword">return</span> <span class="keyword">void</span>(fa[cur] = <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> x = ch[pre][c];</span><br><span class="line">        <span class="keyword">if</span>(len[pre]+<span class="number">1</span> == len[x]) <span class="keyword">return</span> <span class="keyword">void</span>(fa[cur] = x);</span><br><span class="line">        <span class="keyword">int</span> y = ++tot; len[y] = len[pre]+<span class="number">1</span>; fa[y] = fa[x]; fa[x] = fa[cur] = y;</span><br><span class="line">        <span class="built_in">memcpy</span>(ch[y], ch[x], <span class="keyword">sizeof</span>(ch[x]));</span><br><span class="line">        <span class="keyword">while</span>(pre&amp;&amp;ch[pre][c] == x) ch[pre][c] = y, pre = fa[pre]; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> type = <span class="number">1</span>)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= tot; ++i) ++tax[len[i]];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= tot; ++i) tax[i] += tax[i<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= tot; ++i) p[tax[len[i]]--] = i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = tot; i &gt; <span class="number">1</span>; --i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> x = p[i]; </span><br><span class="line">            <span class="keyword">if</span>(type) root[fa[x]] = merge(root[fa[x]], root[x]);</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">            &#123;</span><br><span class="line">                w[fa[x]] = max(w[x], w[fa[x]]);</span><br><span class="line">                ans += max(<span class="number">0</span>, len[x]-max(w[x], len[fa[x]]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(type)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= tot; ++i)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> x = p[i]; ac[<span class="number">0</span>][x] = fa[x];</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>; k &lt; <span class="number">20</span>; ++k) ac[k][x] = ac[k<span class="number">-1</span>][ac[k<span class="number">-1</span>][x]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> d)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">19</span>; ~i; --i) <span class="keyword">if</span>(len[ac[i][x]] &gt;= d) x = ac[i][x];</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> ql, <span class="keyword">int</span> qr, <span class="keyword">int</span> lcs)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(query(root[x], <span class="number">1</span>, n, ql+lcs<span class="number">-1</span>, qr)) <span class="keyword">return</span> lcs;</span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">0</span>, l = <span class="number">1</span>, r = lcs<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l &lt;= r)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(query(root[find(x, mid)], <span class="number">1</span>, n, ql+mid<span class="number">-1</span>, qr)) ret = mid, l = mid+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> r = mid<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;sam, buf;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s); q = read(); n = <span class="built_in">strlen</span>(s);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; s[i]; ++i) sam.insert(s[i]-<span class="string">&#x27;a&#x27;</span>); sam.build();</span><br><span class="line">    <span class="keyword">while</span>(q--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s); <span class="keyword">int</span> l = read(), r = read();</span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">1</span>, lcs = <span class="number">0</span>; buf.clear();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; s[i]; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(x&amp;&amp;!sam.ch[x][s[i]-<span class="string">&#x27;a&#x27;</span>]) x = sam.fa[x], lcs = sam.len[x];</span><br><span class="line">            <span class="keyword">if</span>(!x) x = <span class="number">1</span>, lcs = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span> x = sam.ch[x][s[i]-<span class="string">&#x27;a&#x27;</span>], ++lcs;</span><br><span class="line">            buf.insert(s[i]-<span class="string">&#x27;a&#x27;</span>, sam.get(x, l, r, lcs));</span><br><span class="line">        &#125;</span><br><span class="line">        buf.build(<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, buf.ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>线段树</tag>
        <tag>后缀自动机</tag>
      </tags>
  </entry>
  <entry>
    <title>[雅礼集训2017Day7]事情的相似度</title>
    <url>/2019/07/02/%E9%9B%85%E7%A4%BC%E9%9B%86%E8%AE%AD2017Day7-%E4%BA%8B%E6%83%85%E7%9A%84%E7%9B%B8%E4%BC%BC%E5%BA%A6/</url>
    <content><![CDATA[<h2 id="题目描述">题目描述</h2>
<p>给定前缀结束位置区间，求其两两间 <span class="math inline">\(LCS\)</span> 的最大值</p>
<h2 id="题解">题解</h2>
<p><del>一个人学 <span class="math inline">\(SAM\)</span>，也需要考虑历史的进程</del></p>
<p>这道题在一开始有一个口胡的后缀数组和莫队的 <span class="math inline">\(O(n\sqrt{nlogn})\)</span>
做法，但觉得常数有点大，就放弃了</p>
<p>之后又错误估计了预处理的点对数量，以为是 <span class="math inline">\(O(n^2)\)</span>，然后就看了题解，发现是 <span class="math inline">\(O(nlogn)\)</span></p>
<p>任意两前缀的 <span class="math inline">\(LCS\)</span> 一定是相应
<span class="math inline">\(np\)</span> 节点在 <span class="math inline">\(Parent\)</span> 树上的 <span class="math inline">\(LCA\)</span> 的 <span class="math inline">\(maxlen\)</span>，我们预处理一些点对即可，具体来说，两个子节点合并到父节点时，我们找最接近的合并一定不会差，这样和启发式合并复杂度一致
<a id="more"></a> 之后把操作离线，用后缀树状数组搞一下扫描线即可</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">int</span> f = <span class="number">1</span>, <span class="keyword">int</span> x = <span class="number">0</span>, <span class="keyword">char</span> ch = <span class="string">&#x27; &#x27;</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">isdigit</span>(ch = getchar())) <span class="keyword">if</span>(ch == <span class="string">&#x27;-&#x27;</span>) f = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch)) x = x*<span class="number">10</span>+ch-<span class="string">&#x27;0&#x27;</span>, ch = getchar();</span><br><span class="line">    <span class="keyword">return</span> f*x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> last = <span class="number">1</span>, tot = <span class="number">1</span>, ch[N][<span class="number">2</span>], fa[N], len[N];</span><br><span class="line"><span class="keyword">int</span> m, p[N], tax[N];</span><br><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; t[N];</span><br><span class="line"><span class="keyword">char</span> s[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cur = ++tot, pre = last; last = cur;</span><br><span class="line">    len[cur] = len[pre]+<span class="number">1</span>; t[cur].insert(len[cur]);</span><br><span class="line">    <span class="keyword">while</span>(pre&amp;&amp;!ch[pre][c]) ch[pre][c] = cur, pre = fa[pre];</span><br><span class="line">    <span class="keyword">if</span>(!pre) <span class="keyword">return</span> <span class="keyword">void</span>(fa[cur] = <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> x = ch[pre][c];</span><br><span class="line">    <span class="keyword">if</span>(len[pre]+<span class="number">1</span> == len[x]) <span class="keyword">return</span> <span class="keyword">void</span>(fa[cur] = x);</span><br><span class="line">    <span class="keyword">int</span> y = ++tot; fa[y] = fa[x]; fa[x] = fa[cur] = y; len[y] = len[pre]+<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">memcpy</span>(ch[y], ch[x], <span class="keyword">sizeof</span>(ch[x]));</span><br><span class="line">    <span class="keyword">while</span>(pre&amp;&amp;ch[pre][c] == x) ch[pre][c] = y, pre = fa[pre];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n, q;</span><br><span class="line"><span class="keyword">int</span> ans[N];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Tup</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> w[<span class="number">3</span>];</span><br><span class="line">    Tup(<span class="keyword">int</span> x = <span class="number">0</span>, <span class="keyword">int</span> y = <span class="number">0</span>, <span class="keyword">int</span> z = <span class="number">0</span>)&#123; w[<span class="number">0</span>] = x; w[<span class="number">1</span>] = y; w[<span class="number">2</span>] = z; &#125;</span><br><span class="line">    <span class="keyword">int</span> <span class="keyword">operator</span> [] (<span class="keyword">const</span> <span class="keyword">int</span> x) &#123; <span class="keyword">return</span> w[x]; &#125; </span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Tup &amp;_) <span class="keyword">const</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i)</span><br><span class="line">            <span class="keyword">if</span>(w[i] != _.w[i]) <span class="keyword">return</span> w[i] &lt; _.w[i];</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;tup[N&lt;&lt;<span class="number">6</span>], par[N]; </span><br><span class="line"><span class="keyword">int</span> val[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> d)</span> </span>&#123; <span class="keyword">for</span>( ; x; x -= x&amp;-x) val[x] = max(val[x], d); &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="keyword">int</span> ret = <span class="number">0</span>; <span class="keyword">for</span>( ; x &lt;= n; x += x&amp;-x) ret = max(ret, val[x]); <span class="keyword">return</span> ret;  &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;q); <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) insert(s[i]-<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= tot; ++i) ++tax[len[i]];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= tot; ++i) tax[i] += tax[i<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= tot; ++i) p[tax[len[i]]--] = i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = tot; i &gt; <span class="number">1</span>; --i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> x = p[i]; <span class="keyword">if</span>(t[x].size() &gt; t[fa[x]].size()) swap(t[x], t[fa[x]]);</span><br><span class="line">        <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;::iterator it, a, b, c;</span><br><span class="line">        <span class="keyword">for</span>(it = t[x].begin(); it != t[x].end(); ++it)</span><br><span class="line">        &#123;</span><br><span class="line">            t[fa[x]].insert(*it); a = b = c = t[fa[x]].find(*it); ++c;</span><br><span class="line">            <span class="keyword">if</span>(a != t[fa[x]].begin()) --a, tup[++m] = Tup(*b, *a, len[fa[x]]);</span><br><span class="line">            <span class="keyword">if</span>(c != t[fa[x]].end()) tup[++m] = Tup(*c, *b, len[fa[x]]);</span><br><span class="line">            t[fa[x]].erase(*it);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(it = t[x].begin(); it != t[x].end(); ++it) t[fa[x]].insert(*it);</span><br><span class="line">    &#125;</span><br><span class="line">    sort(tup+<span class="number">1</span>, tup+<span class="number">1</span>+m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= q; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> l = read(), r = read();</span><br><span class="line">        par[i] = Tup(r, l, i);</span><br><span class="line">    &#125;</span><br><span class="line">    sort(par+<span class="number">1</span>, par+<span class="number">1</span>+q);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>, ptr = <span class="number">1</span>; i &lt;= q; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(ptr &lt;= m&amp;&amp;tup[ptr][<span class="number">0</span>] &lt;= par[i][<span class="number">0</span>]) change(tup[ptr][<span class="number">1</span>], tup[ptr][<span class="number">2</span>]), ++ptr;</span><br><span class="line">        ans[par[i][<span class="number">2</span>]] = query(par[i][<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= q; ++i) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>后缀自动机</tag>
        <tag>扫描线</tag>
      </tags>
  </entry>
  <entry>
    <title>[BZOJ3413]匹配</title>
    <url>/2019/07/01/BZOJ3413-%E5%8C%B9%E9%85%8D/</url>
    <content><![CDATA[<h2 id="题面描述">题面描述</h2>
<p>求 <span class="math inline">\(A\)</span> 串对 <span class="math inline">\(B\)</span> 串朴素匹配的比较次数</p>
<h2 id="题解">题解</h2>
<p>一道综合性和思维性很好的题</p>
<p>解决的关键在于把匹配的复杂度转移到 <span class="math inline">\(A\)</span> 上</p>
<p>起初没什么思路，只知道这道题一定是在 <span class="math inline">\(B\)</span> 的 <span class="math inline">\(Parent\)</span> 树上乱搞</p>
<p>对着样例和 <span class="math inline">\(Parent\)</span>
树找了快半个小时的规律才知道怎么做</p>
<p>首先分两种情况讨论 <a id="more"></a> 第一种，<span class="math inline">\(A\)</span> 可以匹配上 <span class="math inline">\(B\)</span>，记匹配位置为 <span class="math inline">\(pos\)</span></p>
<p>那么答案即为</p>
<p><span class="math display">\[
\sum_{i=1}^{pos-1}[LCP(A,\ B[1,i])+1]+len(B)
\]</span></p>
<p>我们在 <span class="math inline">\(B\)</span> 的 <span class="math inline">\(SAM\)</span> 上匹配 <span class="math inline">\(A\)</span>，匹配上时的节点为 <span class="math inline">\(x\)</span>，不难发现，<span class="math inline">\(pos\ =\ min\lbrace k\rbrace,k\in
endpos(x)\)</span></p>
<p>考虑前面的式子如何求出，我们会发现正串的 <span class="math inline">\(Parent\)</span> 树向上跳时方便求出的是 <span class="math inline">\(LCS\)</span>
与该题结合十分不自然，所以不妨在反串上建 <span class="math inline">\(SAM\)</span>，得出后缀树</p>
<p>在后缀树上向上跳，<span class="math inline">\(A\)</span>和<span class="math inline">\(B\)</span>前缀不断缩小，具有相同前缀的位置越来越多，正好与匹配过程相一致，具体来说，<span class="math inline">\(LCP\)</span>即为相应位置第一次在向上跳相遇时 <span class="math inline">\(endpos\)</span>
集合的最长长度，前面的式子用后缀树改写即为</p>
<p><span class="math display">\[
\sum_{i=1}^{pos-1}[maxlen(p_i)+1],\ \forall i\in p_k\ maxlen(p_i) \ge
maxlen(p_k),\ p_i\in path(x,S)
\]</span></p>
<p>所以我们只需要向上跳后缀树，每次加上该节点小于 <span class="math inline">\(pos\)</span> 的 <span class="math inline">\(endpos\)</span>
个数乘上该节点所表示字符串的长度区间长度即可，每个位置的贡献恰好按照上式不重不漏统计了一次，最后再加上
<span class="math inline">\(pos-1\)</span> 即可，用线段树合并即可</p>
<p>第二种，<span class="math inline">\(A\)</span> 匹配不上 <span class="math inline">\(B\)</span> 那么答案即为</p>
<p><span class="math display">\[
\sum_{i=1}^{len(B)}[LCP(A,\ B[1,i])+1]
\]</span></p>
<p>记匹配最后节点为 <span class="math inline">\(x\)</span>，按照上述讨论，答案变为</p>
<p><span class="math display">\[
\sum_{i=1}^{len(B)}[maxlen(p_i)+1],\ \forall i\in p_k\ maxlen(p_i) \ge
maxlen(p_k),\ p_i\in path(x,S)
\]</span></p>
<p>然而答案错误，是由于 <span class="math inline">\(x\)</span>
的贡献不一定是 <span class="math inline">\(maxlen(x)\)</span>，有可能只是一部分，所以特殊统计一下就好了，与
<a href="https://www.luogu.org/problemnew/show/P3181">[HAOI2016]找相同字符</a>
类似</p>
<p>此题空间严格，需要仔细计算空间大小</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> int64;</span><br><span class="line"><span class="keyword">int</span> n, m, q;</span><br><span class="line"><span class="keyword">char</span> s[N];</span><br><span class="line"><span class="keyword">namespace</span> sam</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> tot = <span class="number">1</span>, last = <span class="number">1</span>, ch[N][<span class="number">10</span>], fa[N], len[N], pos[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cur = ++tot, pre = last; last = cur;</span><br><span class="line">    len[cur] = len[pre]+<span class="number">1</span>; pos[cur] = len[cur];</span><br><span class="line">    <span class="keyword">while</span>(pre&amp;&amp;!ch[pre][c]) ch[pre][c] = cur, pre = fa[pre];</span><br><span class="line">    <span class="keyword">if</span>(!pre) <span class="keyword">return</span> <span class="keyword">void</span>(fa[cur] = <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> x = ch[pre][c];</span><br><span class="line">    <span class="keyword">if</span>(len[pre]+<span class="number">1</span> == len[x]) <span class="keyword">return</span> (<span class="keyword">void</span>)(fa[cur] = x);</span><br><span class="line">    <span class="keyword">int</span> y = ++tot; fa[y] = fa[x]; fa[x] = fa[cur] = y; pos[y] = pos[cur]; len[y] = len[pre]+<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">memcpy</span>(ch[y], ch[x], <span class="keyword">sizeof</span>(ch[y]));</span><br><span class="line">    <span class="keyword">while</span>(pre&amp;&amp;ch[pre][c] == x) ch[pre][c] = y, pre = fa[pre];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> tot, root[N], val[N&lt;&lt;<span class="number">5</span>], ls[N&lt;&lt;<span class="number">5</span>], rs[N&lt;&lt;<span class="number">5</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> &amp;x, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> pos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!x) x = ++tot; ++val[x];</span><br><span class="line">    <span class="keyword">if</span>(l == r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = (l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(pos &lt;= mid) add(ls[x], l, mid, pos);</span><br><span class="line">    <span class="keyword">else</span> add(rs[x], mid+<span class="number">1</span>, r, pos);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!x||!y) <span class="keyword">return</span> x|y;</span><br><span class="line">    <span class="keyword">int</span> z = ++tot;</span><br><span class="line">    val[z] = val[x]+val[y];</span><br><span class="line">    ls[z] = merge(ls[x], ls[y]);</span><br><span class="line">    rs[z] = merge(rs[x], rs[y]);</span><br><span class="line">    <span class="keyword">return</span> z;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> ql, <span class="keyword">int</span> qr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!x||(ql &lt;= l&amp;&amp;r &lt;= qr)) <span class="keyword">return</span> val[x];</span><br><span class="line">    <span class="keyword">int</span> mid = (l+r)&gt;&gt;<span class="number">1</span>, ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(ql &lt;= mid) ret += query(ls[x], l, mid, ql, qr);</span><br><span class="line">    <span class="keyword">if</span>(qr &gt; mid) ret += query(rs[x], mid+<span class="number">1</span>, r, ql, qr);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> tax[N], p[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%s%d&quot;</span>, &amp;n, s+<span class="number">1</span>, &amp;q);</span><br><span class="line">    reverse(s+<span class="number">1</span>, s+<span class="number">1</span>+n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) sam::insert(s[i]-<span class="string">&#x27;0&#x27;</span>), add(root[sam::last], <span class="number">1</span>, n, i);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= sam::tot; ++i) ++tax[sam::len[i]];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= sam::tot; ++i) tax[i] += tax[i<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= sam::tot; ++i) p[tax[sam::len[i]]--] = i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = sam::tot; i &gt; <span class="number">1</span>; --i) </span><br><span class="line">        sam::pos[sam::fa[p[i]]] = max(sam::pos[sam::fa[p[i]]], sam::pos[p[i]]),</span><br><span class="line">        root[sam::fa[p[i]]] = merge(root[sam::fa[p[i]]], root[p[i]]);</span><br><span class="line">    <span class="keyword">while</span>(q--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s+<span class="number">1</span>); m = <span class="built_in">strlen</span>(s+<span class="number">1</span>); reverse(s+<span class="number">1</span>, s+<span class="number">1</span>+m);</span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">1</span>, lcs = <span class="number">0</span>, p = <span class="number">1</span>; int64 ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(x&amp;&amp;!sam::ch[x][s[i]-<span class="string">&#x27;0&#x27;</span>]) x = sam::fa[x], lcs = sam::len[x];</span><br><span class="line">            <span class="keyword">if</span>(!x) x = <span class="number">1</span>, lcs = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span> x = sam::ch[x][s[i]-<span class="string">&#x27;0&#x27;</span>], ++lcs;</span><br><span class="line">            <span class="keyword">if</span>(lcs == m) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(lcs == m) p = sam::pos[x]+<span class="number">1</span>, ans += m, x = sam::fa[x];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(x != <span class="number">1</span>) ans += <span class="number">1l</span>l*(lcs-sam::len[sam::fa[x]])*query(root[x], <span class="number">1</span>, n, p, n), x = sam::fa[x];</span><br><span class="line">        <span class="keyword">while</span>(x != <span class="number">1</span>) ans += <span class="number">1l</span>l*(sam::len[x]-sam::len[sam::fa[x]])*query(root[x], <span class="number">1</span>, n, p, n), x = sam::fa[x];</span><br><span class="line">        ans += query(root[x], <span class="number">1</span>, n, p, n);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>线段树</tag>
        <tag>后缀自动机</tag>
      </tags>
  </entry>
  <entry>
    <title>[BZOJ3879]Svt</title>
    <url>/2019/07/01/BZOJ3879-Svt/</url>
    <content><![CDATA[<h2 id="题面描述">题面描述</h2>
<p>给定后缀集合 <span class="math inline">\(S\)</span> , 求 <span class="math inline">\(\sum_{s_i,s_j\in S}LCP(s_i,\ s_j)\)</span></p>
<h2 id="题解">题解</h2>
<p>很套路的一道题，在反串构造后缀自动机建后缀树</p>
<p>在后缀树上 <span class="math inline">\(DP\)</span> 统计以当前节点为
<span class="math inline">\(LCA\)</span> 的路径数即可</p>
<p>多组询问就用虚树搞一下就好了 <a id="more"></a> 此题轻微卡常，最好用树剖
<span class="math inline">\(LCA\)</span></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> int64;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">int</span> f = <span class="number">1</span>, <span class="keyword">int</span> x = <span class="number">0</span>, <span class="keyword">char</span> ch = <span class="number">0</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">isdigit</span>(ch = getchar())) <span class="keyword">if</span>(ch == <span class="string">&#x27;-&#x27;</span>) f = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch)) x = x*<span class="number">10</span>+ch-<span class="string">&#x27;0&#x27;</span>, ch = getchar();</span><br><span class="line">    <span class="keyword">return</span> f*x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span>+<span class="number">5</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> next, to;</span><br><span class="line">    Edge(<span class="keyword">int</span> next = <span class="number">0</span>, <span class="keyword">int</span> to = <span class="number">0</span>):next(next), to(to) &#123;&#125;;</span><br><span class="line">&#125;edge[N];</span><br><span class="line"><span class="keyword">int</span> tot, head[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123; edge[++tot] = Edge(head[x], y); head[x] = tot;  &#125;</span><br><span class="line"><span class="keyword">namespace</span> sam</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> last = <span class="number">1</span>, tot = <span class="number">1</span>, ch[N][<span class="number">26</span>], fa[N], len[N], pos[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cur = ++tot, pre = last; last = cur;</span><br><span class="line">    len[cur] = len[pre]+<span class="number">1</span>; pos[len[cur]] = cur;</span><br><span class="line">    <span class="keyword">while</span>(pre&amp;&amp;!ch[pre][c]) ch[pre][c] = cur, pre = fa[pre];</span><br><span class="line">    <span class="keyword">if</span>(!pre) <span class="keyword">return</span> <span class="keyword">void</span>(fa[cur] = <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> x = ch[pre][c];</span><br><span class="line">    <span class="keyword">if</span>(len[pre]+<span class="number">1</span> == len[x]) <span class="keyword">return</span> <span class="keyword">void</span>(fa[cur] = x);</span><br><span class="line">    <span class="keyword">int</span> y = ++tot; fa[y] = fa[x]; len[y] = len[pre]+<span class="number">1</span>; fa[x] = fa[cur] = y;</span><br><span class="line">    <span class="built_in">memcpy</span>(ch[y], ch[x], <span class="keyword">sizeof</span>(ch[x]));</span><br><span class="line">    <span class="keyword">while</span>(pre&amp;&amp;ch[pre][c] == x) ch[pre][c] = y, pre = fa[pre]; </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n, m, q;</span><br><span class="line"><span class="keyword">char</span> s[N];</span><br><span class="line"><span class="keyword">int</span> d[N], dfn[N], t, son[N], top[N], size[N], pos[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dfn[x] = ++t; d[x] = d[sam::fa[x]]+<span class="number">1</span>; size[x] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = head[x]; i; i = edge[i].next) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> y = edge[i].to; dfs(y); </span><br><span class="line">        size[x] += size[y]; son[x] = size[son[x]]&gt;size[y]?son[x]:y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> topf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    top[x] = topf;</span><br><span class="line">    <span class="keyword">if</span>(son[x]) dfs(son[x], topf);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = head[x]; i; i = edge[i].next)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> y = edge[i].to; </span><br><span class="line">        <span class="keyword">if</span>(y^son[x]) dfs(y, y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LCA</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(top[x] != top[y]) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(d[top[x]] &lt; d[top[y]]) swap(x, y);</span><br><span class="line">        x = sam::fa[top[x]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> d[x]&lt;d[y]?x:y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> p[N];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123; <span class="keyword">return</span> dfn[x] &lt; dfn[y]; &#125;</span><br><span class="line"><span class="keyword">namespace</span> vtree</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> top, s[N], col[N], f[N];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; edge[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123; edge[x].push_back(y); &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> lca = LCA(x, s[top]);</span><br><span class="line">    <span class="keyword">if</span>(s[top] == lca) <span class="keyword">return</span> <span class="keyword">void</span>(s[++top] = x);</span><br><span class="line">    <span class="keyword">while</span>(top &gt; <span class="number">1</span>&amp;&amp;dfn[s[top<span class="number">-1</span>]] &gt;= dfn[lca]) add(s[top<span class="number">-1</span>], s[top]), --top;</span><br><span class="line">    <span class="keyword">if</span>(s[top] != lca) add(lca, s[top]), s[top] = lca;</span><br><span class="line">    s[++top] = x;</span><br><span class="line">&#125;  </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    s[top = <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) insert(p[i]), col[p[i]] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(top &gt; <span class="number">1</span>) add(s[top<span class="number">-1</span>], s[top]), --top;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">int64 <span class="title">dp</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    int64 ret = <span class="number">0</span>; f[x] = col[x]; col[x] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; edge[x].size(); ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> y = edge[x][i]; ret += dp(y);</span><br><span class="line">        ret += <span class="number">1l</span>l*f[x]*f[y]*sam::len[x];</span><br><span class="line">        f[x] += f[y];</span><br><span class="line">    &#125;</span><br><span class="line">    edge[x].clear();</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n = read(), q = read(); <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s+<span class="number">1</span>); reverse(s+<span class="number">1</span>, s+<span class="number">1</span>+n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) sam::insert(s[i]-<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> x = <span class="number">2</span>; x &lt;= sam::tot; ++x) add(sam::fa[x], x); </span><br><span class="line">    dfs(<span class="number">1</span>); dfs(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">while</span>(q--)</span><br><span class="line">    &#123;</span><br><span class="line">        m = read();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) p[i] = sam::pos[n-read()+<span class="number">1</span>];</span><br><span class="line">        sort(p+<span class="number">1</span>, p+<span class="number">1</span>+m); m = unique(p+<span class="number">1</span>, p+<span class="number">1</span>+m)-p<span class="number">-1</span>; </span><br><span class="line">        sort(p+<span class="number">1</span>, p+<span class="number">1</span>+m, cmp); vtree::build();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, vtree::dp(<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>后缀自动机</tag>
        <tag>虚树</tag>
      </tags>
  </entry>
  <entry>
    <title>[SDOI2011]消耗战</title>
    <url>/2019/07/01/SDOI2011-%E6%B6%88%E8%80%97%E6%88%98/</url>
    <content><![CDATA[<h2 id="题面描述">题面描述</h2>
<p>给定关键点，求树的最小割</p>
<h2 id="题解">题解</h2>
<p>虚树模板题，虚树是用来解决多次询问，但关键点总数有限的优化方法，就是将关键点及其
<span class="math inline">\(LCA\)</span> 提取出来在进行 <span class="math inline">\(DP\)</span></p>
<p>具体来说，我们先将关键点按 <span class="math inline">\(dfn\)</span>
排序，依次加入一个栈中，这个栈维护了从根到栈顶的一条链</p>
<p>设加入节点为 <span class="math inline">\(p\)</span>
则分如下情况讨论</p>
<p>若 <span class="math inline">\(LCA(p,\ S_{top})\ =\ S_{top}\)</span>
说明 <span class="math inline">\(p\)</span> 仍在链上，直接入栈</p>
<p>反之，则说明已经到另外一颗子树上了 <a id="more"></a> 不断弹出栈顶直到
<span class="math inline">\(dfn_{S_{top-1}}&lt;dfn_{lca}\)</span> 并且
连边 <span class="math inline">\((S_{top-1},\ S_{top})\)</span> 把 <span class="math inline">\(S_{top}\)</span> 到 <span class="math inline">\(lca\)</span> 的点提取出来</p>
<p>如果 <span class="math inline">\(S_{top}\ne lca\)</span> 则连边 <span class="math inline">\((lca,\ S_{top})\)</span> 将栈顶变为 <span class="math inline">\(lca\)</span></p>
<p>然后，<span class="math inline">\(p\)</span> 再入栈</p>
<p>最后在处理下栈中剩下的链即可</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> int64;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">int</span> f = <span class="number">1</span>, <span class="keyword">int</span> x = <span class="number">0</span>, <span class="keyword">char</span> ch = <span class="string">&#x27; &#x27;</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">isdigit</span>(ch = getchar())) <span class="keyword">if</span>(ch == <span class="string">&#x27;-&#x27;</span>) f = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch)) x = x*<span class="number">10</span>+ch-<span class="string">&#x27;0&#x27;</span>, ch = getchar();</span><br><span class="line">    <span class="keyword">return</span> f*x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">5e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> next, to, w;</span><br><span class="line">    Edge(<span class="keyword">int</span> next = <span class="number">0</span>, <span class="keyword">int</span> to = <span class="number">0</span>, <span class="keyword">int</span> w = <span class="number">0</span>):next(next), to(to), w(w) &#123;&#125;;</span><br><span class="line">&#125;edge[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> head[N], tot;</span><br><span class="line"><span class="keyword">void</span> _add(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> z) &#123; edge[++tot] = Edge(head[x], y, z); head[x] = tot; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> z)</span> </span>&#123; _add(x, y, z); _add(y, x, z); &#125;</span><br><span class="line"><span class="keyword">int</span> n, m, q, ac[<span class="number">20</span>][N], d[N], nfd[N], dfn[N], t, p[N];</span><br><span class="line">int64 f[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ac[<span class="number">0</span>][x] = fa; dfn[++t] = x; nfd[x] = t; d[x] = d[fa]+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">20</span>; ++i) ac[i][x] = ac[i<span class="number">-1</span>][ac[i<span class="number">-1</span>][x]];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = head[x]; i; i = edge[i].next)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> y = edge[i].to, z = edge[i].w;</span><br><span class="line">        <span class="keyword">if</span>(y == fa) <span class="keyword">continue</span>; </span><br><span class="line">        f[y] = min(f[x], <span class="number">1l</span>l*z); dfs(y, x); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LCA</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(d[x] &gt; d[y]) swap(x, y);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">19</span>; ~i; --i)</span><br><span class="line">        <span class="keyword">if</span>(d[ac[i][y]] &gt;= d[x]) y = ac[i][y];</span><br><span class="line">    <span class="keyword">if</span>(x == y) <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">19</span>; ~i; --i) </span><br><span class="line">        <span class="keyword">if</span>(ac[i][x] != ac[i][y]) x = ac[i][x], y = ac[i][y];</span><br><span class="line">    <span class="keyword">return</span> ac[<span class="number">0</span>][x]; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123; <span class="keyword">return</span> nfd[x] &lt; nfd[y]; &#125;</span><br><span class="line"><span class="keyword">namespace</span> vtree</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> s[N], top, cov[N];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; edge[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123; edge[x].push_back(y); &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> lca = LCA(x, s[top]);</span><br><span class="line">    <span class="keyword">if</span>(lca == s[top]) <span class="keyword">return</span> <span class="keyword">void</span>(s[++top] = x);</span><br><span class="line">    <span class="keyword">while</span>(top &gt; <span class="number">1</span>&amp;&amp;nfd[s[top<span class="number">-1</span>]] &gt;= nfd[lca]) add(s[top<span class="number">-1</span>], s[top]), --top;</span><br><span class="line">    <span class="keyword">if</span>(s[top] != lca) add(lca, s[top]), s[top] = lca;</span><br><span class="line">    s[++top] = x;  </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    s[top = <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= m; ++k) cov[p[k]] = <span class="number">1</span>, insert(p[k]); </span><br><span class="line">    <span class="keyword">while</span>(top &gt; <span class="number">1</span>) add(s[top<span class="number">-1</span>], s[top]), --top;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">int64 <span class="title">dp</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    int64 ret = <span class="number">0</span>; </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; edge[x].size(); ++i) </span><br><span class="line">        ret += dp(edge[x][i]);</span><br><span class="line">    edge[x].clear();</span><br><span class="line">    <span class="keyword">if</span>(!cov[x]) <span class="keyword">return</span> min(ret, f[x]);</span><br><span class="line">    cov[x] = <span class="number">0</span>; <span class="keyword">return</span> f[x];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n = read();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> x = read(), y = read(), z = read();</span><br><span class="line">        add(x, y, z); </span><br><span class="line">    &#125;</span><br><span class="line">    q = read(); <span class="built_in">memset</span>(f, <span class="number">0x3f</span>, <span class="keyword">sizeof</span>(f)); dfs(<span class="number">1</span>, <span class="number">0</span>); </span><br><span class="line">    <span class="keyword">while</span>(q--)</span><br><span class="line">    &#123;</span><br><span class="line">        m = read();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= m; ++k) p[k] = read();</span><br><span class="line">        sort(p+<span class="number">1</span>, p+<span class="number">1</span>+m, cmp); vtree::build(); </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, vtree::dp(<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>虚树</tag>
      </tags>
  </entry>
  <entry>
    <title>[USACO17DEC]Standing Out from the Herd</title>
    <url>/2019/07/01/USACO17DEC-Standing-Out-from-the-Herd/</url>
    <content><![CDATA[<h2 id="题面描述">题面描述</h2>
<p>给定字符串集合，求只属于该字符串的本质不同的非空子串的个数</p>
<h2 id="题解">题解</h2>
<p>难度一般，建一个广义 <span class="math inline">\(SAM\)</span> 在
<span class="math inline">\(Parent\)</span> 树上对 <span class="math inline">\(endpos\)</span> 全部属于同一个字符串的统计即可</p>
<p>关键是下面的错误和解决方法</p>
<p>大部分直接按照 <span class="math inline">\(maxlen\)</span> 拓扑序会
<span class="math inline">\(WA\)</span>，是因为如果字符串具有相同前缀则在广义
<span class="math inline">\(SAM\)</span> 中会出现 <span class="math inline">\(maxlen(parent(A))= maxlen(A)\)</span></p>
<p>主要是因为大部分广义 <span class="math inline">\(SAM\)</span>
的写法每次都必须新建一个 <span class="math inline">\(np\)</span>
节点，但实际上这个 <span class="math inline">\(np\)</span>
节点所表示的原串的前缀有可能在 <span class="math inline">\(SAM\)</span>
上出现了，但由于 <span class="math inline">\(Parent\)</span>
树的性质两者间有边相连，导致了 <span class="math inline">\(maxlen\)</span> 非严格单调递增的父子关系，可以通过
<span class="math inline">\(\lbrace ab, abc\ \rbrace\)</span> 体会一下
<a id="more"></a> 所以当 <span class="math inline">\(maxlen\)</span>
相同时，后加入的节点要靠后</p>
<p>但是按照我这种写法又 <span class="math inline">\(WA\)</span> 第 <span class="math inline">\(2\)</span> 个点，是由于新建的 <span class="math inline">\(nq\)</span> 节点应该继承 <span class="math inline">\(np\)</span> 节点的某一个 <span class="math inline">\(endpos\)</span> 而不是 <span class="math inline">\(q\)</span> 节点的 <span class="math inline">\(endpos\)</span></p>
<p>原因是我们会认为在某次加入操作时 <span class="math inline">\(nq\)</span> 的加入顺序晚于 <span class="math inline">\(np\)</span>，导致 <span class="math inline">\(np\)</span> 最后不能及时更新 <span class="math inline">\(nq\)</span>，那么一开始我们就应该将更晚的 <span class="math inline">\(np\)</span> 的某一个 <span class="math inline">\(endpos\)</span> 赋值给 <span class="math inline">\(nq\)</span> <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> int64;</span><br><span class="line"><span class="keyword">int</span> last = <span class="number">1</span>, tot = <span class="number">1</span>, pre, pos[N], len[N], fa[N], ch[N][<span class="number">26</span>];</span><br><span class="line"><span class="keyword">int</span> tax[N], p[N];</span><br><span class="line">int64 ans[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> c, <span class="keyword">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cur = ++tot, pre = last; last = cur;</span><br><span class="line">    len[cur] = len[pre]+<span class="number">1</span>; pos[cur] = p;</span><br><span class="line">    <span class="keyword">while</span>(pre&amp;&amp;!ch[pre][c]) ch[pre][c] = cur, pre = fa[pre];</span><br><span class="line">    <span class="keyword">if</span>(!pre) <span class="keyword">return</span> <span class="keyword">void</span>(fa[cur] = <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> x = ch[pre][c];</span><br><span class="line">    <span class="keyword">if</span>(len[pre]+<span class="number">1</span> == len[x]) <span class="keyword">return</span> <span class="keyword">void</span>(fa[cur] = x);</span><br><span class="line">    <span class="keyword">int</span> y = ++tot; fa[y] = fa[x]; pos[y] = p;</span><br><span class="line">    fa[x] = fa[cur] = y; len[y] = len[pre]+<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">memcpy</span>(ch[y], ch[x], <span class="keyword">sizeof</span>(ch[x]));</span><br><span class="line">    <span class="keyword">while</span>(pre&amp;&amp;ch[pre][c] == x) ch[pre][c] = y, pre = fa[pre]; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">char</span> s[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        last = <span class="number">1</span>; <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; s[k]; ++k) insert(s[k]-<span class="string">&#x27;a&#x27;</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= tot; ++i) ++tax[len[i]];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= tot; ++i) tax[i] += tax[i<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = tot; i; --i) p[tax[len[i]]--] = i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = tot; i; --i) <span class="keyword">if</span>(pos[fa[p[i]]] != pos[p[i]]) pos[fa[p[i]]] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= tot; ++i) ans[pos[i]] += len[i]-len[fa[i]];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>后缀自动机</tag>
      </tags>
  </entry>
  <entry>
    <title>CF700E Cool Slogans</title>
    <url>/2019/06/30/CF700E-Cool-Slogans/</url>
    <content><![CDATA[<h2 id="题面描述">题面描述</h2>
<p>求最长子串序列使得后一个在前一个出现至少 <span class="math inline">\(2\)</span> 次</p>
<h2 id="题解">题解</h2>
<p>子串序列显然属于 <span class="math inline">\(Parent\)</span>
树从根节点到叶子节点的链上，考虑 <span class="math inline">\(Parent\)</span> 树上 <span class="math inline">\(DP\)</span></p>
<p>但是，答案是最长的一条链吗？</p>
<p>自己多试几组发现并不是如此，比如 <span class="math inline">\(abababb\)</span> 中 <span class="math inline">\(parent(ab) = a\)</span> 但并没有出现两次</p>
<p>本题的关键在于此</p>
<p>首先，不难证明一个结论 <span class="math inline">\(A\)</span>
的最长串 <span class="math inline">\(S\)</span> 被<span class="math inline">\(Parent\)</span> 树上的祖先 <span class="math inline">\(B\)</span> 的任意 <span class="math inline">\(S&#39;\)</span>
匹配状态相同，所以选最长串作为序列即可 <a id="more"></a> 对于一个 <span class="math inline">\(endpos\)</span> 集合，只要其中 <span class="math inline">\(1\)</span>
个合法，其他都合法，所以只需判断一次即可，具体来说，设 <span class="math inline">\(parent(A) = B\)</span>，若 <span class="math inline">\(p\in endpos(B)\cap [pos(A)-len(A)+len(B),\
pos(B)-1]\)</span> 则出现两次</p>
<p>线段树合并搞一下就好了</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">4e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> last = <span class="number">1</span>, sam_tot = <span class="number">1</span>, fa[N], ch[N][<span class="number">26</span>], size[N], len[N], pos[N];</span><br><span class="line"><span class="keyword">int</span> tax[N], p[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">samAdd</span><span class="params">(<span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cur = ++sam_tot, pre = last; last = sam_tot;</span><br><span class="line">    len[cur] = len[pre]+<span class="number">1</span>; pos[cur] = len[cur];</span><br><span class="line">    <span class="keyword">while</span>(pre&amp;&amp;!ch[pre][c]) ch[pre][c] = cur, pre = fa[pre];</span><br><span class="line">    <span class="keyword">if</span>(!pre) <span class="keyword">return</span> <span class="keyword">void</span>(fa[cur] = <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> x = ch[pre][c];</span><br><span class="line">    <span class="keyword">if</span>(len[pre]+<span class="number">1</span> == len[x]) <span class="keyword">return</span> <span class="keyword">void</span>(fa[cur] = x);</span><br><span class="line">    <span class="keyword">int</span> y = ++sam_tot; fa[y] = fa[x]; pos[y] = pos[x];</span><br><span class="line">    len[y] = len[pre]+<span class="number">1</span>; fa[x] = fa[cur] = y; </span><br><span class="line">    <span class="built_in">memcpy</span>(ch[y], ch[x], <span class="keyword">sizeof</span>(ch[x]));</span><br><span class="line">    <span class="keyword">while</span>(pre&amp;&amp;ch[pre][c] == x) ch[pre][c] = y, pre = fa[pre];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n, f[N], top[N];</span><br><span class="line"><span class="keyword">char</span> s[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> seg_tot, root[N], ls[N&lt;&lt;<span class="number">6</span>], rs[N&lt;&lt;<span class="number">6</span>], val[N&lt;&lt;<span class="number">6</span>], ans;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!x||!y) <span class="keyword">return</span> x|y;</span><br><span class="line">    <span class="keyword">int</span> z = ++seg_tot;</span><br><span class="line">    val[z] = val[x]+val[y];</span><br><span class="line">    ls[z] = merge(ls[x], ls[y]);</span><br><span class="line">    rs[z] = merge(rs[x], rs[y]);</span><br><span class="line">    <span class="keyword">return</span> z;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> &amp;x, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> pos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!x) x = ++seg_tot; ++val[x];</span><br><span class="line">    <span class="keyword">if</span>(l == r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = (l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(pos &lt;= mid) add(ls[x], l, mid, pos);</span><br><span class="line">    <span class="keyword">else</span> add(rs[x], mid+<span class="number">1</span>, r, pos);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> ql, <span class="keyword">int</span> qr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!x||(ql &lt;= l&amp;&amp;r &lt;= qr)) <span class="keyword">return</span> val[x];</span><br><span class="line">    <span class="keyword">int</span> mid = (l+r)&gt;&gt;<span class="number">1</span>; <span class="keyword">bool</span> ret = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(ql &lt;= mid) ret |= query(ls[x], l, mid, ql, qr);</span><br><span class="line">    <span class="keyword">if</span>(qr &gt; mid) ret |= query(rs[x], mid+<span class="number">1</span>, r, ql, qr);</span><br><span class="line">    <span class="keyword">return</span> ret;   </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%s&quot;</span>, &amp;n, s+<span class="number">1</span>); </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) add(root[sam_tot+<span class="number">1</span>], <span class="number">1</span>, n, i), samAdd(s[i]-<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= sam_tot; ++i) ++tax[len[i]];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= sam_tot; ++i) tax[i] += tax[i<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= sam_tot; ++i) p[tax[len[i]]--] = i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = sam_tot; i &gt; <span class="number">1</span>; --i) root[fa[p[i]]] = merge(root[fa[p[i]]], root[p[i]]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= sam_tot; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> x = p[i]; </span><br><span class="line">        <span class="keyword">if</span>(fa[x] == <span class="number">1</span>) f[x] = <span class="number">1</span>, top[x] = x;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(query(root[top[fa[x]]], <span class="number">1</span>, n, pos[x]-len[x]+len[top[fa[x]]], pos[x]<span class="number">-1</span>)) f[x] = f[top[fa[x]]]+<span class="number">1</span>, top[x] = x;</span><br><span class="line">            <span class="keyword">else</span> f[x] = f[top[fa[x]]], top[x] = top[fa[x]];</span><br><span class="line">        &#125;</span><br><span class="line">        ans = max(ans, f[x]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>线段树</tag>
        <tag>后缀自动机</tag>
      </tags>
  </entry>
  <entry>
    <title>29609102 NOIP模拟题</title>
    <url>/2019/06/30/29609102-NOIP%E6%A8%A1%E6%8B%9F%E9%A2%98/</url>
    <content><![CDATA[<h2 id="gardenp3160-cqoi2012局部极小值"><del>Garden</del><a href="https://www.luogu.org/problemnew/show/P3160">P3160
[CQOI2012]局部极小值</a></h2>
<blockquote>
<p>对 <span class="math inline">\(n\times m\)</span> 的矩阵进行不重复的
<span class="math inline">\([1,\ n\times m]\)</span>
整数填数，定义局部最小值为比其八连通块都小的位置，给定局部最小值，求合法方案数</p>
</blockquote>
<p><del>如果罗兹瓦尔说的像这样清晰该有多好</del></p>
<p>还是我语文太差了</p>
<p>先不讨论非局部最小值的合法性，显然这是一个拓扑排序计数问题，对于一般图的拓扑排序计数问题，通常使用状压<span class="math inline">\(DP\)</span>，把已排序好的集合作为状态，在转移时判断加入集合的点的前驱是否都已排序，而顺序性体现已排序集合的扩大的过程中，这也是排序问题的核心思想
<a id="more"></a> 在这道题里还有一个比较明显的性质，局部最小值的数量不超过
<span class="math inline">\(8\)</span></p>
<p>所以考场上直接写了一个裸的拓扑排序计数和一个小小的剪枝</p>
<p><del>然后，果断便会白给</del></p>
<p>没有生成一组极限数据测状态数</p>
<p>正解首先是对 <span class="math inline">\(DP\)</span> 的优化</p>
<p>设局部最小值的填数状态为 <span class="math inline">\(S\)</span> 已填
<span class="math inline">\(i\)</span> 个数的方案数 <span class="math inline">\(f_{i,S}\)</span> 和在状态 <span class="math inline">\(S\)</span> 下不受局部最小值限制的位置个数为 <span class="math inline">\(g_S\)</span> 则有转移</p>
<p><span class="math display">\[
f_{i,S}\ =\ f_{i-1,S}\times (g_S-(i-1))+\sum_{p\in S}f_{i-1,S-p}
\]</span></p>
<p>前一部是当前的数不给局部最小值，后一部分是给局部最小值</p>
<p>时间复杂度 <span class="math inline">\(O(nm2^k)\)</span> 其中 <span class="math inline">\(k\le8\)</span></p>
<p>接下来讨论非局部最小值的合法性，考虑直接按上述式子 <span class="math inline">\(DP\)</span> 求出的是<strong>至少</strong>有<span class="math inline">\(0\)</span>个非局部最小值成为局部最小值，而题意要求<strong>恰好</strong>有<span class="math inline">\(0\)</span>个非局部最小值成为局部最小值，直接组合容斥即可</p>
<p>具体来说，设 <span class="math inline">\(h_k\)</span> 为至少有<span class="math inline">\(k\)</span>个非局部最小值成为局部最小值，那么就有</p>
<p><span class="math display">\[
ans\ =\ \sum(-1)^kh_k
\]</span></p>
<p>其中 <span class="math inline">\(h_k\)</span> 不需要具体求出，<span class="math inline">\(DFS\)</span> 枚举合法的转化数量即可</p>
<p>时间大概 <span class="math inline">\(O(tnm2^k)\)</span> 其中 <span class="math inline">\(t\in [\Pi(nm-9i-9k),\Pi(nm-4i-4k)]\)</span> <span class="math inline">\(t\)</span> 离上界相差很远，总之很优秀</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">int</span> f = <span class="number">1</span>, <span class="keyword">int</span> x = <span class="number">0</span>, <span class="keyword">char</span> ch = <span class="string">&#x27; &#x27;</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">isdigit</span>(ch = getchar())) <span class="keyword">if</span>(ch == <span class="string">&#x27;-&#x27;</span>) f = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch)) x = x*<span class="number">10</span>+ch-<span class="string">&#x27;0&#x27;</span>, ch = getchar();</span><br><span class="line">    <span class="keyword">return</span> f*x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">4</span>+<span class="number">5</span>, M = <span class="number">7</span>+<span class="number">5</span>, P = <span class="number">12345678</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> dx[<span class="number">8</span>] = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> dy[<span class="number">8</span>] = &#123;<span class="number">1</span>, <span class="number">-1</span>, <span class="number">1</span>, <span class="number">-1</span>, <span class="number">1</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;; </span><br><span class="line"><span class="keyword">int</span> t, n, m, d;</span><br><span class="line"><span class="keyword">char</span> w[N][M];</span><br><span class="line"><span class="keyword">int</span> f[N*M][<span class="number">1</span>&lt;&lt;<span class="number">8</span>], ans, g[<span class="number">1</span>&lt;&lt;<span class="number">8</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bit</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123; <span class="keyword">return</span> (i<span class="number">-1</span>)*m+j<span class="number">-1</span>; &#125;</span><br><span class="line">pair&lt;int, int&gt; dbit(int p) &#123; return make_pair(p/m+1, p%m+1); &#125;</span><br><span class="line"><span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; c[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hateMathers</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(f, <span class="number">0</span>, <span class="keyword">sizeof</span>(f)); d = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(g, <span class="number">0</span>, <span class="keyword">sizeof</span>(g)); </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++j)</span><br><span class="line">            <span class="keyword">if</span>(w[i][j] == <span class="string">&#x27;X&#x27;</span>) c[d++] = <span class="built_in">make_pair</span>(i, j);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> s = <span class="number">0</span>; s &lt; <span class="number">1</span>&lt;&lt;d; ++s)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; d; ++i) w[c[i].first][c[i].second] = (s&gt;&gt;i&amp;<span class="number">1</span>)?<span class="string">&#x27;.&#x27;</span>:<span class="string">&#x27;X&#x27;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(w[i][j] == <span class="string">&#x27;X&#x27;</span>) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">int</span> q = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">8</span>; ++k) <span class="keyword">if</span>(w[i+dx[k]][j+dy[k]] == <span class="string">&#x27;X&#x27;</span>) q = <span class="number">0</span>;</span><br><span class="line">                g[s] += q;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;        </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; d; ++i) w[c[i].first][c[i].second] = <span class="string">&#x27;X&#x27;</span>;</span><br><span class="line">    f[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n*m; ++i) </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> s = <span class="number">0</span>; s &lt; <span class="number">1</span>&lt;&lt;d; ++s)</span><br><span class="line">        &#123;</span><br><span class="line">            f[i][s] = <span class="number">1l</span>l*f[i<span class="number">-1</span>][s]*(g[s]-i+<span class="number">1</span>)%P;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> p = <span class="number">0</span>; p &lt; d; ++p)</span><br><span class="line">                <span class="keyword">if</span>(s&gt;&gt;p&amp;<span class="number">1</span>) f[i][s] = (f[i][s]+f[i<span class="number">-1</span>][s^(<span class="number">1</span>&lt;&lt;p)])%P;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> f[n*m][(<span class="number">1</span>&lt;&lt;d)<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hateRoswaal</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p == n*m) <span class="keyword">return</span> <span class="keyword">void</span>(ans = (ans+k*hateMathers()+P)%P);</span><br><span class="line">    <span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; par = dbit(p); <span class="keyword">int</span> x = par.first, y = par.second;</span><br><span class="line">    <span class="keyword">if</span>(w[x][y] == <span class="string">&#x27;X&#x27;</span>) hateRoswaal(p+<span class="number">1</span>, k);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        hateRoswaal(p+<span class="number">1</span>, k);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; ++i) <span class="keyword">if</span>(w[x+dx[i]][y+dy[i]] == <span class="string">&#x27;X&#x27;</span>) <span class="keyword">return</span>;</span><br><span class="line">        w[x][y] = <span class="string">&#x27;X&#x27;</span>; hateRoswaal(p+<span class="number">1</span>, -k); w[x][y] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    freopen(<span class="string">&quot;garden.in&quot;</span>, <span class="string">&quot;r&quot;</span>, <span class="built_in">stdin</span>);</span><br><span class="line">    freopen(<span class="string">&quot;garden.out&quot;</span>, <span class="string">&quot;w&quot;</span>, <span class="built_in">stdout</span>); </span><br><span class="line">    t = read();</span><br><span class="line">    <span class="keyword">while</span>(t--)</span><br><span class="line">    &#123;</span><br><span class="line">        n = read(), m = read(); ans = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">memset</span>(w, <span class="number">0</span>, <span class="keyword">sizeof</span>(w));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, w[i]+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">bool</span> is_emp = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">8</span>&amp;&amp;is_emp; ++k)</span><br><span class="line">                    <span class="keyword">if</span>(w[i+dx[k]][j+dy[k]] == <span class="string">&#x27;X&#x27;</span>)</span><br><span class="line">                        is_emp = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">if</span>(!is_emp&amp;&amp;w[i][j] == <span class="string">&#x27;X&#x27;</span>) ans = <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">if</span>(ans == <span class="number">-1</span>) <span class="built_in">printf</span>(<span class="string">&quot;0\n&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> hateRoswaal(<span class="number">0</span>, <span class="number">1</span>), <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="throw">Throw</h2>
<blockquote>
<p>求 <span class="math inline">\((a,\ b,\ c)\)</span> 经过 <span class="math inline">\(f(a,\ b,\ c)\)</span> 变为 <span class="math inline">\((a&#39;,\ b&#39;,\ c&#39;)\)</span>
的最小操作个数</p>
</blockquote>
<p>很好的思维题</p>
<p>考试时写搜索时，想到双向搜索，想到双向搜索又想到建树，但没继续像，转而想
<span class="math inline">\(exgcd\)</span> 和毒瘤贪心</p>
<p>首先题目中的丢你拉姆过于花哨，与三元素中每一个元素等价这一条件显得十分不自然，我们结合
<a href="https://www.luogu.org/problemnew/show/P1007">P1007 独木桥</a>
的想法，我们把调换顺序看作平移相同距离，这样每个元素在变化上与等价的条件相应，即</p>
<p><span class="math display">\[
f_(a,\ b,\ c)\rightarrow
\begin{cases}
(a+(b-a),\ b+(b-a),\ c),\ b-a&lt;c-b\\\\
(a-(b-a),\ b-(b-a),\ c)\\\\
(a,\ b-(c-b),\ c-(c-b)),\ b-a&gt;c-b\\\\
(a,\ b+(c-b),\ c+(c-b))
\end{cases}
\]</span></p>
<p>显然 <span class="math inline">\((a,\ b,\ c)\)</span> 的变化不超过
<span class="math inline">\(3\)</span></p>
<p>我们考虑按照这种关系建树，发现以 <span class="math inline">\((A,\ B,\
C)\)</span> 其中 <span class="math inline">\(B-A=C-B\)</span>
时恰好为树的形态且还是一颗二叉树，那么答案就是树上两点的距离</p>
<p>其次答案具有单调性，所以先调整到同一高度，在二分向上跳的距离判断是否相等即可</p>
<p>在向上跳的过程中可以一下跳多步，用距离除一下贪心即可</p>
<p>或者按照这样理解</p>
<p>设 <span class="math inline">\(g(n,\ m)\)</span> 其中 <span class="math inline">\(n=b-a,\ m=c-b\)</span></p>
<p>那么向上跳是一个更相减损的过程，用辗转相除优化即可，这也是 <a href="https://www.luogu.org/problemnew/show/P3700">[CQOI2017]
小Q的表格</a> 最关键的一步</p>
<p>还有一些细节，在注释里标注</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">int</span> f = <span class="number">1</span>, <span class="keyword">int</span> x = <span class="number">0</span>, <span class="keyword">char</span> ch = <span class="string">&#x27; &#x27;</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">isdigit</span>(ch = getchar())) <span class="keyword">if</span>(ch == <span class="string">&#x27;-&#x27;</span>) f = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch)) x = x*<span class="number">10</span>+ch-<span class="string">&#x27;0&#x27;</span>, ch = getchar();</span><br><span class="line">    <span class="keyword">return</span> f*x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> p[<span class="number">3</span>];</span><br><span class="line">    <span class="keyword">int</span> <span class="keyword">operator</span> [] (<span class="keyword">const</span> <span class="keyword">int</span> x) &#123; <span class="keyword">return</span> p[x]; &#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> == (<span class="keyword">const</span> Node &amp;_) <span class="keyword">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> p[<span class="number">0</span>]==_.p[<span class="number">0</span>]&amp;&amp;p[<span class="number">1</span>]==_.p[<span class="number">1</span>]&amp;&amp;p[<span class="number">2</span>]==_.p[<span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> != (<span class="keyword">const</span> Node &amp;_) <span class="keyword">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> !(p[<span class="number">0</span>]==_.p[<span class="number">0</span>]&amp;&amp;p[<span class="number">1</span>]==_.p[<span class="number">1</span>]&amp;&amp;p[<span class="number">2</span>]==_.p[<span class="number">2</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    Node(<span class="keyword">int</span> x = <span class="number">0</span>, <span class="keyword">int</span> y = <span class="number">0</span>, <span class="keyword">int</span> z = <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        p[<span class="number">0</span>] = x, p[<span class="number">1</span>] = y, p[<span class="number">2</span>] = z; </span><br><span class="line">        sort(p, p+<span class="number">3</span>); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;s, t;</span><br><span class="line"><span class="keyword">int</span> ds, dt, ans, buf;</span><br><span class="line"><span class="function">Node <span class="title">get</span><span class="params">(Node p, <span class="keyword">int</span> up, <span class="keyword">int</span> &amp;d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = p[<span class="number">1</span>]-p[<span class="number">0</span>], b = p[<span class="number">2</span>]-p[<span class="number">1</span>], c;</span><br><span class="line">    <span class="keyword">if</span>(!up||a == b) <span class="keyword">return</span> p;</span><br><span class="line">    <span class="keyword">if</span>(a &lt; b) c = min(up, (b<span class="number">-1</span>)/a), p = Node(p[<span class="number">0</span>]+c*a, p[<span class="number">1</span>]+c*a, p[<span class="number">2</span>]); <span class="comment">// 不能相等，所以要减 1</span></span><br><span class="line">    <span class="keyword">else</span> c = min(up, (a<span class="number">-1</span>)/b), p = Node(p[<span class="number">0</span>], p[<span class="number">1</span>]-c*b, p[<span class="number">2</span>]-c*b);</span><br><span class="line">    d += c; up -= c;</span><br><span class="line">    <span class="keyword">return</span> get(p, up, d);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    freopen(<span class="string">&quot;throw.in&quot;</span>, <span class="string">&quot;r&quot;</span>, <span class="built_in">stdin</span>);</span><br><span class="line">    freopen(<span class="string">&quot;throw.out&quot;</span>, <span class="string">&quot;w&quot;</span>, <span class="built_in">stdout</span>);</span><br><span class="line">    s = Node(read(), read(), read());</span><br><span class="line">    t = Node(read(), read(), read());</span><br><span class="line">    <span class="keyword">if</span>(get(s, INF, ds) != get(t, INF, dt)) <span class="built_in">puts</span>(<span class="string">&quot;NO&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;YES&quot;</span>);   </span><br><span class="line">        <span class="keyword">if</span>(ds &lt; dt) swap(s, t), swap(ds, dt);</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = dt; s = get(s, ds-dt, buf);</span><br><span class="line">        <span class="keyword">while</span>(l &lt;= r)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(get(s, mid, buf) == get(t, mid, buf)) ans = mid, r = mid<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">else</span> l = mid+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans*<span class="number">2</span>+ds-dt); <span class="comment">// 注意乘2</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>思维</tag>
        <tag>动态规划</tag>
        <tag>容斥</tag>
      </tags>
  </entry>
  <entry>
    <title>42609102 NOIP模拟题</title>
    <url>/2019/06/24/42609102-NOIP%E6%A8%A1%E6%8B%9F%E9%A2%98/</url>
    <content><![CDATA[<h2 id="施工">施工</h2>
<blockquote>
<p>已知 <span class="math inline">\(F(t)\ =\
\sum_{i=1}^nt_i^2+\sum_{i=2}^n|h_i+t_i-t_{i-1}-h_{i-1}|\)</span> ，求
<span class="math inline">\(F_{min}\)</span></p>
</blockquote>
<p>设 <span class="math inline">\(f_{i,j}\)</span> 表示 <span class="math inline">\(t_i\ =\ j\)</span> 时 <span class="math inline">\(F_i(t)\)</span> 的最小值则有如下转移</p>
<p><span class="math display">\[
f_{i,j}\ =
\begin{cases}
f_{i-1,k}+j^2+|k+h_{i-1}-h_i-j| ,\ j&gt;1\\\\
j^2,\ i\ =\ 1
\end{cases}
\]</span> <a id="more"></a> 时间复杂度 <span class="math inline">\(O(nh_{max}^2)\)</span>，空间复杂度 <span class="math inline">\(O(nh_{max})\)</span>，期望得分 <span class="math inline">\(11\)</span></p>
<p>考虑优化，很明显最关键的是优化掉第二维，结合贪心我们发现最终一定有一定的区间的
<span class="math inline">\(t+h\)</span> 相同，不依次来转移</p>
<p><span class="math display">\[
f_i\ =
\begin{cases}
f_j+\sum_{k=j+1}^{i-1}(h-h_k)^2+c(h_i+h_j-2h),\ j&lt;i-1,max_{j+1\le
k\le i-1}\lbrace h_k\rbrace \le \min\lbrace h_i,h_j\rbrace \\\\
f_j+|h_i-h_j|,\ j\ =\ i-1
\end{cases}
\]</span></p>
<p>观察上述式子，其中 <span class="math inline">\(h\)</span>
可由二次函数对称轴确定，具体来说</p>
<p><span class="math display">\[
\begin{aligned}
g(h)\ &amp;=\ \sum_{k=j+1}^{i-1}(h-h_i)^2+c(h_i+h_j-2h)\\\\
&amp;=\ \sum_{k=j+1}^{i-1}(h^2+h_i^2-2hh_i)-c(h_i+h_j)-2ch\\\\
&amp;=\
(i-j-1)h^2-2(\sum_{k=j+1}^{i-1}h_k+c)h+\sum_{k=j+1}^{i-1}h_k^2-c(h_i+h_j)
\end{aligned}
\]</span></p>
<p>那么当<span class="math inline">\(h\approx
\frac{\sum_{k=j+1}^{i-1}h_k+c}{i-j-1}\)</span> 时，<span class="math inline">\(g\)</span> 值最小</p>
<p>现在空间复杂度 <span class="math inline">\(O(n)\)</span>
考虑优化时间</p>
<p>注意到第一个转移的条件 <span class="math inline">\(j&lt;i-1,max_{j+1\le k\le i-1}\lbrace
h_k\rbrace\)</span></p>
<p><del>这不就是个裸的单调栈吗</del></p>
<p>用单调栈维护即可 <span class="math inline">\(O(n)\)</span></p>
<p><del>还有一件事</del></p>
<p>这样表示状态对于 <span class="math inline">\(i=1\)</span> 或 <span class="math inline">\(i=n\)</span>
比较麻烦，所以我们不妨增加两个虚拟节点，之后特判即可</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> int64;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">int</span> f = <span class="number">1</span>, <span class="keyword">int</span> x = <span class="number">0</span>, <span class="keyword">char</span> ch = <span class="string">&#x27; &#x27;</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">isdigit</span>(ch = getchar())) <span class="keyword">if</span>(ch == <span class="string">&#x27;-&#x27;</span>) f = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch)) x = x*<span class="number">10</span>+ch-<span class="string">&#x27;0&#x27;</span>, ch = getchar();</span><br><span class="line">    <span class="keyword">return</span> f*x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> int64 INF = <span class="number">0x3f3f3f3f3f3f3f3f</span>LL;</span><br><span class="line"><span class="keyword">int</span> n, m, c, h[N];</span><br><span class="line">int64 ans = INF, f[N], s1[N], s2[N];</span><br><span class="line"><span class="keyword">int</span> s[N], top;</span><br><span class="line"><span class="function">int64 <span class="title">calc</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> hk)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    int64 A = i-j<span class="number">-1</span>;</span><br><span class="line">    int64 B = <span class="number">-2</span>*(s1[i<span class="number">-1</span>]-s1[j])-(i!=n+<span class="number">1</span>)*c-(j!=<span class="number">0</span>)*c;</span><br><span class="line">    int64 C = s2[i<span class="number">-1</span>]-s2[j]+<span class="number">1l</span>l*(i!=n+<span class="number">1</span>)*h[i]*c+<span class="number">1l</span>l*(j!=<span class="number">0</span>)*h[j]*c;</span><br><span class="line">    <span class="keyword">int</span> x = (<span class="keyword">int</span>)round(<span class="number">-1.0</span>*<span class="keyword">double</span>(B)/<span class="keyword">double</span>(A)/<span class="number">2.0</span>);</span><br><span class="line">    x = max(x, hk);</span><br><span class="line">    <span class="keyword">if</span>(i != n+<span class="number">1</span>) x = min(x, h[i]);</span><br><span class="line">    <span class="keyword">if</span>(j != <span class="number">0</span>) x = min(x, h[j]);</span><br><span class="line">    <span class="keyword">return</span> A*x*x+B*x+C;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    freopen(<span class="string">&quot;construct.in&quot;</span>, <span class="string">&quot;r&quot;</span>, <span class="built_in">stdin</span>);</span><br><span class="line">    freopen(<span class="string">&quot;construct.out&quot;</span>, <span class="string">&quot;w&quot;</span>, <span class="built_in">stdout</span>);</span><br><span class="line">    n = read(), c = read();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) </span><br><span class="line">        h[i] = read(), m = max(h[i], m),</span><br><span class="line">        s1[i] = s1[i<span class="number">-1</span>]+h[i],</span><br><span class="line">        s2[i] = s2[i<span class="number">-1</span>]+<span class="number">1l</span>l*h[i]*h[i];</span><br><span class="line">    s[++top] = <span class="number">0</span>; h[<span class="number">0</span>] = h[n+<span class="number">1</span>] = m+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n+<span class="number">1</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        f[i] = f[i<span class="number">-1</span>]+<span class="number">1l</span>l*(i != <span class="number">1</span>&amp;&amp;i != n+<span class="number">1</span>)*c*<span class="built_in">abs</span>(h[i]-h[i<span class="number">-1</span>]);</span><br><span class="line">        <span class="keyword">while</span>(top&amp;&amp;h[s[top]] &lt;= h[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(top &gt; <span class="number">1</span>) f[i] = min(f[i], f[s[top<span class="number">-1</span>]]+calc(i, s[top<span class="number">-1</span>], h[s[top]]));</span><br><span class="line">            --top;</span><br><span class="line">        &#125;</span><br><span class="line">        s[++top] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, f[n+<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">## 蔬菜</span><br><span class="line">&gt; 求矩形区域内颜色的出现次数的平方和</span><br><span class="line"></span><br><span class="line">玄学题目，正解是按照出现次数分组，然而莫队可以水过去，但考场上看到转移是 $O(n)$ 就果断放弃了，但确实能过 ㄟ( ▔, ▔ )ㄏ</span><br><span class="line"></span><br><span class="line">莫队复杂度 $O(qT+\frac&#123;n^<span class="number">2</span>&#125;&#123;T&#125;+\frac&#123;n^<span class="number">3</span>&#125;&#123;T^<span class="number">2</span>&#125;+\frac&#123;n^<span class="number">4</span>&#125;&#123;T^<span class="number">3</span>&#125;)$ 差不多在 $T = \frac&#123;n&#125;&#123;q^&#123;\frac&#123;<span class="number">1</span>&#125;&#123;<span class="number">4</span>&#125;&#125;&#125;$ 时最优</span><br><span class="line"></span><br><span class="line">最后，记得跳指针时先扩张再减小</span><br><span class="line"></span><br><span class="line">```cpp</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cctype&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> int64;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">int</span> f = <span class="number">1</span>, <span class="keyword">int</span> x = <span class="number">0</span>, <span class="keyword">char</span> ch = <span class="string">&#x27; &#x27;</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">isdigit</span>(ch = getchar())) <span class="keyword">if</span>(ch == <span class="string">&#x27;-&#x27;</span>) f = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch)) x = x*<span class="number">10</span>+ch-<span class="string">&#x27;0&#x27;</span>, ch = getchar();</span><br><span class="line">    <span class="keyword">return</span> f*x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">2e2</span>+<span class="number">5</span>, N = <span class="number">1e6</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, t;</span><br><span class="line"><span class="keyword">int</span> _[N], tot;</span><br><span class="line"><span class="keyword">int</span> c[M][M];</span><br><span class="line"><span class="keyword">int</span> bel[N], T;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Query</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> px, py, qx, qy, p;</span><br><span class="line">    Query(<span class="keyword">int</span> px = <span class="number">0</span>, <span class="keyword">int</span> py = <span class="number">0</span>, <span class="keyword">int</span> qx = <span class="number">0</span>, <span class="keyword">int</span> qy = <span class="number">0</span>, <span class="keyword">int</span> p = <span class="number">0</span>):px(px), py(py), qx(qx), qy(qy), p(p) &#123;&#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Query &amp;_) <span class="keyword">const</span></span><br><span class="line">    &#123;   </span><br><span class="line">        <span class="keyword">if</span>(bel[px] != bel[_.px]) <span class="keyword">return</span> px &lt; _.px;</span><br><span class="line">        <span class="keyword">if</span>(py != _.py) <span class="keyword">return</span> py &lt; _.qy;</span><br><span class="line">        <span class="keyword">if</span>(qx != _.qx) <span class="keyword">return</span> qx &lt; _.qx;</span><br><span class="line">        <span class="keyword">return</span> qy &lt; _.qy;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;q[N];</span><br><span class="line"><span class="keyword">int</span> ans[N];</span><br><span class="line"><span class="keyword">int</span> px = <span class="number">1</span>, py = <span class="number">1</span>, qx = <span class="number">1</span>, qy = <span class="number">1</span>, cnt[N], ret = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cUpdate</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> y = py; y &lt;= qy; ++y)</span><br><span class="line">        <span class="keyword">if</span>(c[x][y])</span><br><span class="line">            ret -= cnt[c[x][y]]*cnt[c[x][y]],</span><br><span class="line">            cnt[c[x][y]] += d,</span><br><span class="line">            ret += cnt[c[x][y]]*cnt[c[x][y]];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rUpdate</span><span class="params">(<span class="keyword">int</span> y, <span class="keyword">int</span> d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> x = px; x &lt;= qx; ++x)</span><br><span class="line">        <span class="keyword">if</span>(c[x][y])</span><br><span class="line">            ret -= cnt[c[x][y]]*cnt[c[x][y]],</span><br><span class="line">            cnt[c[x][y]] += d,</span><br><span class="line">            ret += cnt[c[x][y]]*cnt[c[x][y]];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n = read(), m = read(), t = read();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++j)</span><br><span class="line">            c[i][j] = read(), _[++tot] = c[i][j];</span><br><span class="line">    sort(_+<span class="number">1</span>, _+tot+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++j) </span><br><span class="line">            c[i][j] = lower_bound(_+<span class="number">1</span>, _+tot+<span class="number">1</span>, c[i][j])-_;</span><br><span class="line">    T = <span class="keyword">int</span>(<span class="number">1.0</span>*n/<span class="built_in">pow</span>(t, <span class="number">0.25</span>))+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) bel[i] = i/T+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= t; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> px = read(), py = read(), qx = read(), qy = read();</span><br><span class="line">        q[i] = Query(px, py, qx, qy, i);</span><br><span class="line">    &#125;</span><br><span class="line">    sort(q+<span class="number">1</span>, q+<span class="number">1</span>+t); ++cnt[c[<span class="number">1</span>][<span class="number">1</span>]];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= t; ++i)</span><br><span class="line">    &#123;         </span><br><span class="line">        <span class="keyword">while</span>(px &gt; q[i].px) --px, cUpdate(px, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">while</span>(qx &lt; q[i].qx) ++qx, cUpdate(qx, <span class="number">1</span>);        </span><br><span class="line">        <span class="keyword">while</span>(px &lt; q[i].px) cUpdate(px, <span class="number">-1</span>), ++px;</span><br><span class="line">        <span class="keyword">while</span>(qx &gt; q[i].qx) cUpdate(qx, <span class="number">-1</span>), --qx;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(py &gt; q[i].py) --py, rUpdate(py, <span class="number">1</span>);   </span><br><span class="line">        <span class="keyword">while</span>(qy &lt; q[i].qy) ++qy, rUpdate(qy, <span class="number">1</span>);               </span><br><span class="line">        <span class="keyword">while</span>(py &lt; q[i].py) rUpdate(py, <span class="number">-1</span>), ++py;</span><br><span class="line">        <span class="keyword">while</span>(qy &gt; q[i].qy) rUpdate(qy, <span class="number">-1</span>), --qy;</span><br><span class="line">        ans[q[i].p] = ret;       </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= t; ++i) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>单调栈</tag>
        <tag>莫队</tag>
      </tags>
  </entry>
  <entry>
    <title>[JXOI2017]颜色</title>
    <url>/2019/05/11/JXOI2017-%E9%A2%9C%E8%89%B2/</url>
    <content><![CDATA[<h2 id="题面描述">题面描述</h2>
<p>一个颜色序列删去颜色的方案使得最后剩下来的序列非空且连续</p>
<h2 id="题解">题解</h2>
<p>首先一个序列非空且连续就是原颜色序列的一段连续区间，这段颜色区间的每个颜色仅在该区间里出现，对于每个颜色都有一个左端点和右端点，我们枚举合法区间的左端点就可以通过某些数据结构来后面的位置找有多少个合法右端点即可
<a id="more"></a>
然而分析到这就结束了，因为认为对于合法区间有可能会算重合法方案</p>
<p><strong>我真傻，真的</strong></p>
<p>让我们复读看一下这句话</p>
<p><strong>这段颜色区间的每个颜色仅在该区间里出现</strong></p>
<p>若存在两个区间的颜色集合相同又怎么可以合法呢</p>
<p>但是就直接去看了题解</p>
<p>同时在看题解时看到了一个神奇的解法</p>
<p>对于每种颜色的每个位置随机赋值，最后一个位置赋值为前面位置的和的相反数，合法区间的权值为
<span class="math inline">\(0\)</span>
所以说我们维护前缀和，扫描数组前缀和相同累积答案</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdint&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">int</span> f = <span class="number">1</span>, <span class="keyword">int</span> x = <span class="number">0</span>, <span class="keyword">char</span> ch = <span class="string">&#x27; &#x27;</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">isdigit</span>(ch = getchar())) <span class="keyword">if</span>(ch == <span class="string">&#x27;-&#x27;</span>) f = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch)) x = x*<span class="number">10</span>+ch-<span class="string">&#x27;0&#x27;</span>, ch = getchar();</span><br><span class="line">    <span class="keyword">return</span> f*x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">3e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int64_t</span> P = <span class="number">1e12</span>; <span class="comment">// 哈希冲突有些严重，大一点好</span></span><br><span class="line"><span class="keyword">int</span> n, t, a[N];</span><br><span class="line"><span class="keyword">int64_t</span> f[N];</span><br><span class="line"><span class="keyword">int64_t</span> sum, ans; </span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; p[N];</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int64_t</span>, <span class="keyword">int</span>&gt; h;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    t = read();</span><br><span class="line">    <span class="keyword">while</span>(t--)</span><br><span class="line">    &#123;</span><br><span class="line">        n = read(); ans = <span class="number">0</span>; h.clear();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) f[i] = <span class="number">0</span>, p[i].clear();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) a[i] = read(), p[a[i]].push_back(i);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(p[i].size() &lt; <span class="number">2</span>) <span class="keyword">continue</span>;</span><br><span class="line">            sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; p[i].size()<span class="number">-1</span>; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> q = p[i][j];</span><br><span class="line">                <span class="keyword">int64_t</span> d = <span class="number">1l</span>l*rand()*rand()%P*rand()%P*rand()%P;</span><br><span class="line">                <span class="keyword">if</span>(rand()&amp;<span class="number">1</span>) d = -d; </span><br><span class="line">                sum += d; f[q] = d; </span><br><span class="line">            &#125;</span><br><span class="line">            f[p[i][p[i].size()<span class="number">-1</span>]] = -sum;</span><br><span class="line">        &#125;</span><br><span class="line">        sum = <span class="number">0</span>; h[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">            sum += f[i], ans += h[sum], ++h[sum];</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>思维</tag>
        <tag>组合计数</tag>
      </tags>
  </entry>
  <entry>
    <title>[JXOI2017]数列</title>
    <url>/2019/05/11/JXOI2017-%E6%95%B0%E5%88%97/</url>
    <content><![CDATA[<h2 id="题面描述">题面描述</h2>
<p>求满足题目中限制条件的合法填数数量</p>
<h2 id="题解">题解</h2>
<p>我不会推性质，只好写一个状压得 <span class="math inline">\(60\)</span> 暴力分</p>
<p>我们发现题目中得状态必须和位置与至于有关，不妨考虑状态 <span class="math inline">\(f_{i,l,r}\)</span> 代表在位置 <span class="math inline">\(i\)</span> 取值范围为 <span class="math inline">\([l,\ r]\)</span>
得方案数，考虑这个状态如何转移出去 <a id="more"></a> 我们发现 <span class="math inline">\(A_{i-1}\)</span> 和 <span class="math inline">\(A_i\)</span>
都不会超过这个值域，我们讨论一下他们的大小</p>
<p>当 <span class="math inline">\(A_i\ =\ A_{i-1}\ = l\)</span>
时，<span class="math inline">\(A_{i+1}\in [l,\ l]\)</span></p>
<p>当 <span class="math inline">\(l &lt; A_i\ \le\ A_{i-1}\ &lt;
r\)</span> 时，<span class="math inline">\(A_{i+1}\in [l,\
A_{i-1}]\)</span></p>
<p>当 <span class="math inline">\(l &lt; A_{i-1}\ \le\ A_i\ &lt;
r\)</span> 时，<span class="math inline">\(A_{i+1}\in [A_{i-1},\
r]\)</span></p>
<p>当 <span class="math inline">\(A_i\ =\ A_{i-1}\ = r\)</span>
时，<span class="math inline">\(A_{i+1}\in [r,\ r]\)</span></p>
<p>因此我们可以通过枚举 <span class="math inline">\(A_{i-1}\)</span>
的取值确定下一部分的值</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">int</span> f = <span class="number">1</span>, <span class="keyword">int</span> x = <span class="number">0</span>, <span class="keyword">char</span> ch = <span class="string">&#x27; &#x27;</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">isdigit</span>(ch = getchar())) <span class="keyword">if</span>(ch == <span class="string">&#x27;-&#x27;</span>) f = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch)) x = x*<span class="number">10</span>+ch-<span class="string">&#x27;0&#x27;</span>, ch = getchar();</span><br><span class="line">    <span class="keyword">return</span> f*x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">50</span>+<span class="number">5</span>, M = <span class="number">150</span>+<span class="number">5</span>, P = <span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">int</span> n, a[N];</span><br><span class="line"><span class="keyword">int</span> f[N][M][M];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dp</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p == n+<span class="number">1</span>) <span class="keyword">return</span> f[p][l][r] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> &amp;ret = f[p][l][r]; <span class="keyword">if</span>(~ret) <span class="keyword">return</span> ret; ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = max(l, <span class="number">1</span>); i &lt;= min(r, a[p]); ++i) <span class="comment">// 枚举 A_i-1 的值</span></span><br><span class="line">        <span class="keyword">if</span>(i == l||i == r) ret = (ret+dp(p+<span class="number">1</span>, i, i))%P;</span><br><span class="line">        <span class="keyword">else</span> ret = (((ret+dp(p+<span class="number">1</span>, l, i))%P+dp(p+<span class="number">1</span>, i, r))%P-dp(p+<span class="number">1</span>, i, i)+P)%P; <span class="comment">// 减去重复的</span></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n = read(); <span class="built_in">memset</span>(f, <span class="number">-1</span>, <span class="keyword">sizeof</span>(f));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) a[i] = read();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, dp(<span class="number">1</span>, <span class="number">0</span>, <span class="number">151</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>构造</tag>
        <tag>组合计数</tag>
      </tags>
  </entry>
  <entry>
    <title>[FJOI2017]矩阵填数</title>
    <url>/2019/05/11/FJOI2017-%E7%9F%A9%E9%98%B5%E5%A1%AB%E6%95%B0/</url>
    <content><![CDATA[<h2 id="题面描述">题面描述</h2>
<p>给定矩阵和多个子矩形权值，对矩阵填数满足给定子矩阵的最大值为权值，求方案数</p>
<h2 id="题解">题解</h2>
<p>很容易想到容斥，但是我太菜了不知道怎么算，一直认为补集转换时由等于必须变为不等于，但是却没想到全集是可以自己定义的，这样就可以由等于变为小于了，剩下就比较好办了，离散化后分割矩阵即可
<a id="more"></a> 具体来说我们定义问题的全集 <span class="math inline">\(S\)</span> 每个元素的值域为 <span class="math inline">\([1,\ min(m,v_k)]\)</span>
我们现在对限制进行补集转化，变为性质 <span class="math inline">\(p_k=w_{i,j}&lt;v_k\)</span>，具有该性质的集合为
<span class="math inline">\(A_k\)</span>
，我们现在要求求出不满足任意一条性质的方案数 <span class="math inline">\(T\)</span>，根据组合容斥公式 <span class="math display">\[
T\ =\ |S|-\sum_{k=1}^n(-1)^k\sum_{1\le i_1&lt;i_2&lt;...&lt;i_k\le
n}|A_{i_1}\cap A_{i_2}\cap ...\cap A_{i_k}|
\]</span></p>
<p>代码如下</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">int</span> f = <span class="number">1</span>, <span class="keyword">int</span> x = <span class="number">0</span>, <span class="keyword">char</span> ch = <span class="string">&#x27; &#x27;</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">isdigit</span>(ch = getchar())) <span class="keyword">if</span>(ch == <span class="string">&#x27;-&#x27;</span>) f = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch)) x = x*<span class="number">10</span>+ch-<span class="string">&#x27;0&#x27;</span>, ch = getchar();</span><br><span class="line">    <span class="keyword">return</span> f*x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> P = <span class="number">1e9</span>+<span class="number">7</span>, N = <span class="number">1e3</span>+<span class="number">5</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">qpow</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>( ; b; b &gt;&gt;= <span class="number">1</span>, a = <span class="number">1l</span>l*a*a%P) <span class="keyword">if</span>(b&amp;<span class="number">1</span>) ret = <span class="number">1l</span>l*ret*a%P;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n, a, b, m;</span><br><span class="line"><span class="keyword">int</span> t, tx, ty, tv;</span><br><span class="line"><span class="keyword">int</span> xs[N], ys[N], vs[N], w[N][N], fv[N][N], c[N];</span><br><span class="line"><span class="keyword">int</span> x1[N], y1[N], x2[N], y2[N], v[N];</span><br><span class="line"><span class="keyword">int</span> ans;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    t = read();</span><br><span class="line">    <span class="keyword">while</span>(t--)</span><br><span class="line">    &#123;</span><br><span class="line">        a = read(), b = read(), m = read(), n = read();</span><br><span class="line">        tx = ty = tv = ans = <span class="number">0</span>; </span><br><span class="line">        xs[++tx] = <span class="number">1</span>; xs[++tx] = a+<span class="number">1</span>; </span><br><span class="line">        ys[++ty] = <span class="number">1</span>; ys[++ty] = b+<span class="number">1</span>; </span><br><span class="line">        vs[++tv] = m;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            x1[i] = read(), y1[i] = read();</span><br><span class="line">            x2[i] = read(), y2[i] = read();</span><br><span class="line">            v[i] = read(); vs[++tv] = v[i]; vs[++tv] = v[i]<span class="number">-1</span>;</span><br><span class="line">            xs[++tx] = x1[i]; xs[++tx] = x2[i]+<span class="number">1</span>; <span class="comment">// 左闭右开</span></span><br><span class="line">            ys[++ty] = y1[i]; ys[++ty] = y2[i]+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        sort(xs+<span class="number">1</span>, xs+<span class="number">1</span>+tx); sort(ys+<span class="number">1</span>, ys+<span class="number">1</span>+ty); sort(vs+<span class="number">1</span>, vs+<span class="number">1</span>+tv);</span><br><span class="line">        tx = unique(xs+<span class="number">1</span>, xs+<span class="number">1</span>+tx)-xs<span class="number">-1</span>;</span><br><span class="line">        ty = unique(ys+<span class="number">1</span>, ys+<span class="number">1</span>+ty)-ys<span class="number">-1</span>;</span><br><span class="line">        tv = unique(vs+<span class="number">1</span>, vs+<span class="number">1</span>+tv)-vs<span class="number">-1</span>;         </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; tx; ++i)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; ty; ++j)   </span><br><span class="line">                w[i][j] = (xs[i+<span class="number">1</span>]-xs[i])*(ys[j+<span class="number">1</span>]-ys[j]); </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            x1[i] = lower_bound(xs+<span class="number">1</span>, xs+<span class="number">1</span>+tx, x1[i])-xs;</span><br><span class="line">            y1[i] = lower_bound(ys+<span class="number">1</span>, ys+<span class="number">1</span>+ty, y1[i])-ys;</span><br><span class="line">            x2[i] = lower_bound(xs+<span class="number">1</span>, xs+<span class="number">1</span>+tx, x2[i]+<span class="number">1</span>)-xs;</span><br><span class="line">            y2[i] = lower_bound(ys+<span class="number">1</span>, ys+<span class="number">1</span>+ty, y2[i]+<span class="number">1</span>)-ys;</span><br><span class="line">            v[i] = lower_bound(vs+<span class="number">1</span>, vs+<span class="number">1</span>+tv, v[i])-vs;       </span><br><span class="line">        &#125;        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> s = <span class="number">0</span>; s &lt; <span class="number">1</span>&lt;&lt;n; ++s)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> f = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; tx; ++i)</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; ty; ++j)</span><br><span class="line">                    fv[i][j] = tv;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> cv = v[i];</span><br><span class="line">                <span class="keyword">if</span>(s&gt;&gt;(i<span class="number">-1</span>)&amp;<span class="number">1</span>) f = P-f, --cv;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = x1[i]; j &lt; x2[i]; ++j)</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> k = y1[i]; k &lt; y2[i]; ++k)</span><br><span class="line">                        fv[j][k] = min(cv, fv[j][k]); </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= tv; ++i) c[i] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; tx; ++i)</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; ty; ++j)</span><br><span class="line">                    c[fv[i][j]] += w[i][j];</span><br><span class="line">            <span class="keyword">int</span> ret = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= tv; ++i) ret = <span class="number">1l</span>l*ret*qpow(vs[i], c[i])%P;</span><br><span class="line">            ans = (ans+<span class="number">1l</span>l*f*ret%P)%P;   </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>组合计数</tag>
        <tag>容斥</tag>
      </tags>
  </entry>
  <entry>
    <title>数论出题组比赛 数列</title>
    <url>/2019/05/11/%E6%95%B0%E8%AE%BA%E5%87%BA%E9%A2%98%E7%BB%84%E6%AF%94%E8%B5%9B-%E6%95%B0%E5%88%97/</url>
    <content><![CDATA[<h2 id="题目描述">题目描述</h2>
<p>求二阶线性常系数齐次递推的平方和。</p>
<h2 id="题解">题解</h2>
<p><em>由于这道题意要求，下文数列下标都从 1 开始</em></p>
<h3 id="前置知识">前置知识</h3>
<h4 id="线性常系数齐次递推关系">线性常系数齐次递推关系</h4>
<p>若递推关系满足</p>
<p><span class="math display">\[
f_n\ =\ \sum_{i=1}^kc_if_{n-i}\ (n &gt;k)
\]</span> <a id="more"></a> 且对于 <span class="math inline">\(f_1,\ c_1,\
f_2,\ c_2\ ...\ f_k,\ c_k\)</span> 都为常数</p>
<p>则称这种递推关系为<strong>线性常系数齐次递推关系</strong>，其中 <span class="math inline">\(k\)</span> 为阶数</p>
<p>斐波那契数列就是常见的满足二阶线性常系数齐次递推关系的数列</p>
<h4 id="特征方程">特征方程</h4>
<p>求解线性常系数齐次递推方法的有很多，特征方程是常见的一种</p>
<p>对于递推 <span class="math inline">\(f_n\ =\
2f_{n-1}+3f_{n-2}\)</span> 来说</p>
<p>我们构造等比数列 <span class="math inline">\(\langle\ 1,\ -1,\ 1\
...\ \rangle\)</span> 满足这种关系，其中 <span class="math inline">\(g_n\ =\ (-1)^{n-1}\)</span></p>
<p>又另一个构造等比数列 <span class="math inline">\(\langle\ 1,\ 3,\ 9\
...\ \rangle\)</span> 满足这种关系，其中 <span class="math inline">\(h_n\ =\ 3^{n-1}\)</span></p>
<p>仔细思考发现对于常数 <span class="math inline">\(\alpha\)</span> 和
<span class="math inline">\(\beta\)</span> 而言 <span class="math inline">\(\lbrace \alpha g_n\rbrace\)</span> 和 <span class="math inline">\(\lbrace \beta h_n\rbrace\)</span> 都满足</p>
<p>进一步思考后感觉对于 <span class="math inline">\(\lbrace \alpha g_n\
+\ \beta h_n\rbrace\)</span> 也都满足，其正确性十分明显无需多言</p>
<p>也就是说我们可以通过一些等比数列作为基底，通过它们的线性组合，生成很多满足线性常系数齐次递推的数列</p>
<p>如何找到这些等比数列呢？拿二阶来说</p>
<p>我们不妨设等比数列 <span class="math inline">\(q_n\)</span> 的公比为
<span class="math inline">\(x\)</span>，我们发现递推关系可以写成 <span class="math display">\[
x^2q_n\ =\ axq_n+\ bq_n
\]</span> 两边同时消去 <span class="math inline">\(q_n\)</span>，只剩下
<span class="math display">\[
x^2\ =\ ax\ + b
\]</span></p>
<p>这个方程叫做<strong>特征方程</strong>，通过这个我们就可以找到所有满足条件的等比数列</p>
<p>现在用斐波那契数列举例，特征方程为</p>
<p><span class="math display">\[
x^2\ =\ x\ +\ 1
\]</span></p>
<p>解得 <span class="math inline">\(x_1\ =\
\frac{1+\sqrt{5}}{2}\)</span>，<span class="math inline">\(x_2\ =\
\frac{1-\sqrt{5}}{2}\)</span></p>
<p>我们现在要解出 <span class="math inline">\(\alpha\)</span> 和 <span class="math inline">\(\beta\)</span>，则有 <span class="math inline">\(f_n=
\alpha(x_1)^{n-1}+\beta(x_2)^{n-1}\)</span></p>
<p>带入 <span class="math inline">\(f_1=1\)</span> 和 <span class="math inline">\(f_2=1\)</span> 得</p>
<p><span class="math display">\[\begin{cases}
\alpha+\beta=1\\\\
\alpha x_1+\beta x_2=1\\
\end{cases}
\Rightarrow
\begin{cases}
\alpha=\frac{\sqrt{5}-1}{2\sqrt{5}}\\\\
\beta=\frac{\sqrt{5}+1}{2\sqrt{5}}\\
\end{cases}
\]</span></p>
<p>所以 <span class="math inline">\(f_n=\frac{1}{\sqrt{5}}[(\frac{1+\sqrt{5}}{2})^n-\frac{1-\sqrt{5}}{2})^n]\)</span></p>
<h4 id="模意义下的根式运算">模意义下的根式运算</h4>
<p>假如我们在计算过程中出现了根式，但保证根号下的数不变且结果一定不包含根式，要求在模<span class="math inline">\(P\)</span>意义下进行，保证计算过程中的任何数有逆元，如何解决呢？</p>
<p>我们可以把根式写作类似复数的形式 <span class="math inline">\(a+\sqrt{k}b\)</span> 其中 <span class="math inline">\(k\)</span> 是所有数的根号下面的部分，如 <span class="math inline">\(a+\sqrt{2}\ b\)</span> 等</p>
<p>我们把 <span class="math inline">\(a\)</span> 称作有理部，<span class="math inline">\(b\)</span> 称作无理部，<span class="math inline">\(\sqrt{k}\)</span> 称作基</p>
<p>下面给出几项重要的运算，基不会被取模</p>
<p>加法 <span class="math inline">\((a+\sqrt{k}b)+(c+\sqrt{k}d)\ \equiv\
(a+b)+\sqrt{k}(c+d)\ (mod\ P)\)</span></p>
<p>减法 <span class="math inline">\((a-\sqrt{k}b)+(c-\sqrt{k}d)\ \equiv\
(a-b)+\sqrt{k}(c-d)\ (mod\ P)\)</span></p>
<p>共轭 <span class="math inline">\(conj(a+\sqrt{k}b)\ \equiv\
a+\sqrt{k}(-b)\ (mod\ P)\)</span></p>
<p>乘法 <span class="math inline">\((a+\sqrt{k}b)(c+\sqrt{k}d)\ \equiv\
(ac+bdk)+\sqrt{k}(ad+bc)\ (mod\ P)\)</span></p>
<p>除法比较特殊，我们需要先将分母有理化，即同时将分子和分母同时乘上分母的共轭，这是分母就只剩下有理部了，这是再把分子部分除以分母有理部的逆元即可</p>
<p>除法 <span class="math inline">\(\frac{a+\sqrt{k}b}{c+\sqrt{k}d}\
\equiv\ \frac{(a+\sqrt{k}b)(c+\sqrt{k}d)}{c^2-kd^2} (mod\
P)\)</span></p>
<p>写出来就是</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Complex</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> rat, irr; <span class="comment">// rat 有理部 irr 无理部 irr_base 基</span></span><br><span class="line">    Complex(<span class="keyword">int</span> rat = <span class="number">0</span>, <span class="keyword">int</span> irr = <span class="number">0</span>):rat(rat), irr(irr) &#123;&#125;;</span><br><span class="line">    <span class="function">Complex <span class="title">conj</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> Complex(rat, P-irr); &#125;</span><br><span class="line">    Complex <span class="keyword">operator</span> - (<span class="keyword">const</span> Complex &amp;_) <span class="keyword">const</span> &#123; <span class="keyword">return</span> Complex((rat-_.rat+P)%P, (irr-_.irr+P)%P); &#125;</span><br><span class="line">    Complex <span class="keyword">operator</span> + (<span class="keyword">const</span> Complex &amp;_) <span class="keyword">const</span> &#123; <span class="keyword">return</span> Complex((rat+_.rat)%P, (irr+_.irr)%P); &#125;   </span><br><span class="line">    Complex <span class="keyword">operator</span> * (<span class="keyword">const</span> Complex &amp;_) <span class="keyword">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        Complex ret; </span><br><span class="line">        ret.rat = (rat*_.rat%P+irr*_.irr%P*irr_base%P)%P;</span><br><span class="line">        ret.irr = (rat*_.irr%P+irr*_.rat%P)%P;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    Complex <span class="keyword">operator</span> / (<span class="keyword">const</span> Complex &amp;_) <span class="keyword">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        Complex a = Complex(rat, irr)*_.conj(); Complex b = _*_.conj();</span><br><span class="line">        a = a*Complex(qpow(b.rat, P<span class="number">-2</span>), <span class="number">0</span>); <span class="comment">// 求逆</span></span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="题目主体">题目主体</h3>
<p>题干给出的是一个二阶线性常系数齐次递推数列，而让求出前 <span class="math inline">\(n\)</span> 项平方和</p>
<p>有前置知识得出这个数列的通项的是几个等比数列的线性组合，那么最后也无非是几个等比数列求和罢了</p>
<p>同时这道题保证了特征方程有两根和根式模运算的前提条件，所以下面做法极其暴力</p>
<p>设数列为 <span class="math inline">\(\lbrace f_n\rbrace\)</span>
其他变量名含义与前置知识中的相同</p>
<p>则有 <span class="math display">\[
\begin{cases}
x_1\ =\ \frac{a+\sqrt{a^2+4b}}{2}\\\\
x_2\ =\ \frac{a-\sqrt{a^2+4b}}{2}\\\\
\alpha\ =\ \frac{x_1f_1-f_2}{x_1-x_2}\\\\
\beta\ =\ \frac{f_2-x_2f_1}{x_1-x_2}
\end{cases}
\]</span></p>
<p>而 <span class="math inline">\(f_n=
\alpha(x_1)^{n-1}+\beta(x_2)^{n-1}\)</span> 那么 <span class="math inline">\(f_n^2=
\alpha^2(x_1^2)^{n-1}+\beta^2(x_2^2)^{n-1}+2\alpha\beta(x_1x_2)^{n-1}\)</span></p>
<p>每一部分都是等比数列，用公式 <span class="math inline">\(S_n\ =\
\frac{x^n-1}{x-1}\)</span> 即可</p>
<p>暴力代码如下，没有加任何常数优化居然跑得最快</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long <span class="comment">// 虽然习惯不好，但是在这题比较方便</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> P = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> n, t, a, b, irr_base, f1, f2;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qpow</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>( ; b; b &gt;&gt;= <span class="number">1</span>, a = a*a%P) <span class="keyword">if</span>(b&amp;<span class="number">1</span>) ret = ret*a%P;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Complex</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> rat, irr;</span><br><span class="line">    Complex(<span class="keyword">int</span> rat = <span class="number">0</span>, <span class="keyword">int</span> irr = <span class="number">0</span>):rat(rat), irr(irr) &#123;&#125;;</span><br><span class="line">    <span class="function">Complex <span class="title">conj</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> Complex(rat, P-irr); &#125;</span><br><span class="line">    Complex <span class="keyword">operator</span> - (<span class="keyword">const</span> Complex &amp;_) <span class="keyword">const</span> &#123; <span class="keyword">return</span> Complex((rat-_.rat+P)%P, (irr-_.irr+P)%P); &#125;</span><br><span class="line">    Complex <span class="keyword">operator</span> + (<span class="keyword">const</span> Complex &amp;_) <span class="keyword">const</span> &#123; <span class="keyword">return</span> Complex((rat+_.rat)%P, (irr+_.irr)%P); &#125;   </span><br><span class="line">    Complex <span class="keyword">operator</span> * (<span class="keyword">const</span> Complex &amp;_) <span class="keyword">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        Complex ret; </span><br><span class="line">        ret.rat = (rat*_.rat%P+irr*_.irr%P*irr_base%P)%P;</span><br><span class="line">        ret.irr = (rat*_.irr%P+irr*_.rat%P)%P;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    Complex <span class="keyword">operator</span> / (<span class="keyword">const</span> Complex &amp;_) <span class="keyword">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        Complex a = Complex(rat, irr)*_.conj(); Complex b = _*_.conj();</span><br><span class="line">        a = a*Complex(qpow(b.rat, P<span class="number">-2</span>), <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">Complex <span class="title">qpow</span><span class="params">(Complex a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Complex ret = Complex(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>( ; b; b &gt;&gt;= <span class="number">1</span>, a = a*a) <span class="keyword">if</span>(b&amp;<span class="number">1</span>) ret = ret*a;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line">Complex alpha, beta, x1, x2, fn;</span><br><span class="line">Complex sum1, sum2, sum3, ans;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;t);</span><br><span class="line">    <span class="keyword">while</span>(t--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld%lld%lld%lld&quot;</span>, &amp;n, &amp;f1, &amp;f2, &amp;a, &amp;b);</span><br><span class="line">        irr_base = (a*a%P+<span class="number">4</span>*b%P)%P;</span><br><span class="line">        x1 = Complex(a, <span class="number">1</span>)/Complex(<span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">        x2 = Complex(a, P<span class="number">-1</span>)/Complex(<span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">        alpha = (Complex(f2, <span class="number">0</span>)-x2*Complex(f1, <span class="number">0</span>))/(x1-x2);</span><br><span class="line">        beta = (x1*Complex(f1, <span class="number">0</span>)-Complex(f2, <span class="number">0</span>))/(x1-x2);</span><br><span class="line">        fn = alpha*qpow(x1, n<span class="number">-1</span>)+beta*qpow(x2, n<span class="number">-1</span>);</span><br><span class="line">        sum1 = (qpow(x1*x1, n)-Complex(<span class="number">1</span>, <span class="number">0</span>))/(x1*x1-Complex(<span class="number">1</span>, <span class="number">0</span>))*alpha*alpha;</span><br><span class="line">        sum2 = (qpow(x2*x2, n)-Complex(<span class="number">1</span>, <span class="number">0</span>))/(x2*x2-Complex(<span class="number">1</span>, <span class="number">0</span>))*beta*beta;</span><br><span class="line">        sum3 = (qpow(x1*x2, n)-Complex(<span class="number">1</span>, <span class="number">0</span>))/(x1*x2-Complex(<span class="number">1</span>, <span class="number">0</span>))*beta*alpha*Complex(<span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">        ans = sum1+sum2+sum3;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans.rat);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>递推</tag>
      </tags>
  </entry>
  <entry>
    <title>90509102 NOIP模拟题</title>
    <url>/2019/05/09/90509102-NOIP%E6%A8%A1%E6%8B%9F%E9%A2%98/</url>
    <content><![CDATA[<h2 id="c">C</h2>
<h3 id="题面描述">题面描述</h3>
<p>树上快速维护位运算</p>
<h3 id="题解">题解</h3>
<p>设 <span class="math inline">\(u\)</span> 和 <span class="math inline">\(v\)</span> 的有向简单路径构成的集合为 <span class="math inline">\(S(u,\ v)\)</span> 题意即是求 <span class="math display">\[
\sum_{w\in S(u,v)}a_w\ or\ dis(u,\ w)
\]</span></p>
<p><span class="math inline">\(dis(u,\ w)\)</span> 表示边数
<a id="more"></a> <del>位运算和倍增结合的神仙题，题解看了好久</del></p>
<p>首先，题目询问有向路径，我们把路径用 <span class="math inline">\(lca(u,\ v)\)</span> 分为两半</p>
<p>先考虑向上部分，首先 <span class="math inline">\(or\)</span>
操作不会使贡献减少，它一定有 <span class="math inline">\(\sum_{w\in
S}a_w\)</span> 的基础贡献，并且对于位 <span class="math inline">\(k\)</span> 它会增加 <span class="math inline">\(2^k\)</span> 贡献仅当 <span class="math inline">\(2^k\ and\ dis(u,w) =\ 2^k\)</span></p>
<p>我们发现这样和倍增的思想意外的吻合，倍增中的合并是貌似可以在<strong>不考虑进位</strong>的情况下快速计算增加的贡献</p>
<p>不妨设 <span class="math inline">\(c_{i,x}\)</span> 表示 <span class="math inline">\(x\)</span> 到根的路径上满足 <span class="math inline">\(x\)</span> 的位 <span class="math inline">\(i\)</span> 为 <span class="math inline">\(0\)</span> 的个数，<span class="math inline">\(fa_{i,x}\)</span> 表示 <span class="math inline">\(x\)</span> 的 <span class="math inline">\(2^i\)</span> 级祖先</p>
<p>很容易写出转移</p>
<p><span class="math display">\[
\begin{aligned}
fa_{i,x}\ &amp;=\ fa_{i-1,fa_{i-1,x}}\ (i&gt;0)\\\\
c_{i,x}\ &amp;=\ c_{i,fa_{x,0}}+[a_x&gt;&gt;k\&amp;1==0]\\   
\end{aligned}
\]</span></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">20</span>; ++i) fa[i][x] = fa[i<span class="number">-1</span>][fa[i<span class="number">-1</span>][x]];</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">20</span>; ++i) c[i][x] = c[i][fa[<span class="number">0</span>][x]]+((a[x]&gt;&gt;i&amp;<span class="number">1</span>)==<span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<p>设 <span class="math inline">\(f_{i,x}\)</span> 表示 <span class="math inline">\(x\)</span> 向上走 <span class="math inline">\(2^i-1\)</span> 条边的收益，它经过点集 <span class="math inline">\(S\)</span></p>
<p>即</p>
<p><span class="math display">\[
f_{i,x}\ =\ \sum_{w\in S}a_w\ or\ dis(x,\ w)
\]</span></p>
<p>首先边界为 <span class="math inline">\(f_{0,x}\ =\ a_x\)</span></p>
<p>考虑转移，设 <span class="math inline">\(y\ =\ fa_{i-1,x},\ z\ =\
fa_{i,x}\)</span> 则有</p>
<p><span class="math display">\[
f_{i,x}\ =\ f_{i-1,x}+f_{i-1,y}+2^{i-1}(c_{i-1,y}-c_{i-1,z})
\]</span></p>
<p>其道理蕴含在下面</p>
<p><img src="/2019/05/09/90509102-NOIP%E6%A8%A1%E6%8B%9F%E9%A2%98/trans.png"></p>
<p>原来的答案并不会减少所以先把基础贡献相加，而多出的贡献来源于右半部分原本位
<span class="math inline">\(i-1\)</span> 为 <span class="math inline">\(0\)</span> 的 <span class="math inline">\(a\)</span> 却因为相对距离原本多加了 <span class="math inline">\(2^{i-1}\)</span> 而在 <span class="math inline">\(i-1\)</span>
产生了贡献，利用前缀和的思想从而得出转移方程</p>
<p>这一过程并不会多算或没有考虑进位，因为对于右半部分最大的相对距离
<span class="math inline">\(2^{i-1}-1\)</span> 小于 <span class="math inline">\(2^{i-1}\)</span> 因此不会进位</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">20</span>; ++i)</span><br><span class="line">    f[i][x] = f[i<span class="number">-1</span>][x]+f[i<span class="number">-1</span>][fa[i<span class="number">-1</span>][x]]+(<span class="number">1l</span>l&lt;&lt;(i<span class="number">-1</span>))*(c[i<span class="number">-1</span>][fa[i<span class="number">-1</span>][x]]-c[i<span class="number">-1</span>][fa[i][x]]);</span><br></pre></td></tr></table></figure>
<p>预处理出这些后我们考虑怎么查询向上的答案</p>
<p>由于倍增数组，我们无非是对于 <span class="math inline">\(u\)</span>
到 <span class="math inline">\(lca\)</span>
的路径长度二进制分解，再向上跳父亲的过程中像上述转移方程一样计算后半部分相对距离增加后对答案的贡献</p>
<p>比如说</p>
<p><img src="/2019/05/09/90509102-NOIP%E6%A8%A1%E6%8B%9F%E9%A2%98/ex.png"></p>
<p>我们现在在 <span class="math inline">\(1\)</span> 号节点到 <span class="math inline">\(6\)</span> 号节点，可以使用 <span class="math inline">\(1\)</span>
的倍增数组，因为相对距离的偏移量再之前已经算过了</p>
<p>我们现在可以跳到 <span class="math inline">\(5\)</span>
号节点，中间累加 <span class="math inline">\(f_{1,2}\)</span>
的贡献即点集 <span class="math inline">\(S(1,4)\)</span>
的贡献，同时后半部分 <span class="math inline">\(S(5,6)\)</span> 再从
<span class="math inline">\(5\)</span> 出发相对距离增加 <span class="math inline">\(4\)</span>，即位 <span class="math inline">\(2\)</span> 由 <span class="math inline">\(0\)</span> 变为 <span class="math inline">\(1\)</span> ，类比上述转移，答案增加 <span class="math inline">\(2^2(cnt_{2,5}-cnt_{2,7})\)</span></p>
<p>但是我们是从小到大进行二进制分解，还是从大到小是一个问题</p>
<p><strong>我们是必须要避免相对距离增加过程是否有进位的</strong></p>
<p>所以假设从大到小枚举 <span class="math inline">\(i\)</span> 对于当前
<span class="math inline">\(2^i\)</span>，而后面的和由等比数列求和得到
<span class="math inline">\(2^i-1\)</span>
所以没有进位，而逆序枚举就不一样了</p>
<p>所以向上统计时需要这样做</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int64_t</span> <span class="title">queryUp</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> tar)</span> <span class="comment">// tar 是 lca 的父亲，但最后点集只会到lca，想一想为什么(考虑fa[i][x]和f[i][x]走到节点的不同)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> w = u; <span class="keyword">int64_t</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">20</span>; ~i; --i)</span><br><span class="line">        <span class="keyword">if</span>(d[fa[i][w]] &gt;= d[tar]) <span class="comment">// 从大到小枚举即使贪心的向上条就行了</span></span><br><span class="line">        &#123;</span><br><span class="line">            ret += f[i][w]; w = fa[i][w];</span><br><span class="line">            ret += (<span class="number">1l</span>l&lt;&lt;i)*(c[i][w]-c[i][tar]);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>向下差不多就是类比向上了</p>
<p>设 <span class="math inline">\(g_{i,x}\)</span> 表示 <span class="math inline">\(x\)</span> 从 <span class="math inline">\(2^i-1\)</span>级祖先，向下走 <span class="math inline">\(2^i-1\)</span> 条边的收益</p>
<p>边界为 <span class="math inline">\(g_{0,x}\ =\ a_x\)</span></p>
<p>考虑转移，设 <span class="math inline">\(y\ =\
fa_{i-1,x}\)</span>，则有</p>
<p><span class="math display">\[
g_{i,x}\ =\ g_{i-1,x}+g_{i-1,y}+2^{i-1}(c_{i-1,x}-c_{i-1,y})
\]</span></p>
<p>转移过程差不多和 <span class="math inline">\(f\)</span>
一样，只不过产生贡献是左半部分</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">20</span>; ++i)</span><br><span class="line">    g[i][x] = g[i<span class="number">-1</span>][x]+g[i<span class="number">-1</span>][fa[i<span class="number">-1</span>][x]]+(<span class="number">1l</span>l&lt;&lt;(i<span class="number">-1</span>))*(c[i<span class="number">-1</span>][x]-c[i<span class="number">-1</span>][fa[i<span class="number">-1</span>][x]]);  </span><br></pre></td></tr></table></figure>
<p>我们考虑怎么统计向下路径，标程的想法极富创造性</p>
<p><img src="/2019/05/09/90509102-NOIP%E6%A8%A1%E6%8B%9F%E9%A2%98/mir.png"></p>
<p>我们要统计 <span class="math inline">\(3\)</span> 向下到 <span class="math inline">\(6\)</span> 的路径，可是相对距离增初始加的就不是
<span class="math inline">\(2\)</span> 的整数次幂，就非常麻烦</p>
<p>我们考虑把路径的另一半对称上去，使其变为到根节点的直链</p>
<p>这时就相当于从 <span class="math inline">\(u\)</span> 的 <span class="math inline">\(dis(u,v)\)</span> 级祖先向下走 <span class="math inline">\(dis(u,v)\)</span> 步的收益，利用前缀和的思想再减去
从 <span class="math inline">\(lca\)</span> 的 <span class="math inline">\(dis(u,lca)\)</span> 级祖先向下走 <span class="math inline">\(dis(u,lca)\)</span> 步 的收益</p>
<p>这样貌似就是对 <span class="math inline">\(g\)</span>
做二进制拆分的操作了</p>
<p>但此时 <span class="math inline">\(i\)</span>
出现了枚举顺序的问题</p>
<p>考虑从<span class="math inline">\(3\)</span>向上跳到<span class="math inline">\(5\)</span>的过程，这是 <span class="math inline">\(S(1,2)\)</span> 的相对路径增加了 <span class="math inline">\(2\)</span>，贡献增加了 <span class="math inline">\(2^1(cnt_{1,3}-cnt_{1,1})\)</span></p>
<p>所以我们再不进位的情况下要求前缀和小与当前值，当从小到大枚举时，前缀和
<span class="math inline">\(2^i-1\)</span> 小于 <span class="math inline">\(2^i\)</span></p>
<p>所以进行如下操作</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int64_t</span> <span class="title">queryDown</span><span class="params">(<span class="keyword">int</span> v, <span class="keyword">int</span> dis)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> w = v; <span class="keyword">int64_t</span> ret = <span class="number">0</span>; ++dis; <span class="comment">// 和上文的 tar 同理</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">20</span>; ++i) <span class="comment">// 从小到大枚举</span></span><br><span class="line">        <span class="keyword">if</span>(dis&gt;&gt;i&amp;<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ret += g[i][w]; </span><br><span class="line">            ret += (<span class="number">1l</span>l&lt;&lt;i)*(c[i][v]-c[i][w]); w = fa[i][w];</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>完整如下</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdint&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">int</span> f = <span class="number">1</span>, <span class="keyword">int</span> x = <span class="number">0</span>, <span class="keyword">char</span> ch = <span class="string">&#x27; &#x27;</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">isdigit</span>(ch = getchar())) <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch)) x = x*<span class="number">10</span>+ch-<span class="string">&#x27;0&#x27;</span>, ch = getchar();</span><br><span class="line">    <span class="keyword">return</span> f*x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">3e5</span>+<span class="number">5</span>, L = <span class="number">21</span>;</span><br><span class="line"><span class="keyword">int</span> n, q;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; edge[N];</span><br><span class="line"><span class="keyword">int</span> fa[L][N], d[N], a[N];</span><br><span class="line"><span class="keyword">int64_t</span> g[L][N], f[L][N], c[L][N]; <span class="comment">// 由于毒瘤卡常所以小的一维在前</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> f)</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    fa[<span class="number">0</span>][x] = f; d[x] = d[f]+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">20</span>; ++i) c[i][x] = c[i][f]+((a[x]&gt;&gt;i&amp;<span class="number">1</span>)==<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; edge[x].size(); ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> y = edge[x][i]; </span><br><span class="line">        <span class="keyword">if</span>(y == f) <span class="keyword">continue</span>;</span><br><span class="line">        dfs(y, x);   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LCA</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(d[x] &lt; d[y]) swap(x, y);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">20</span>; ~i; --i) <span class="keyword">if</span>(d[fa[i][x]] &gt;= d[y]) x = fa[i][x];</span><br><span class="line">    <span class="keyword">if</span>(x == y) <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">20</span>; ~i; --i) <span class="keyword">if</span>(fa[i][x] != fa[i][y]) x = fa[i][x], y = fa[i][y];</span><br><span class="line">    <span class="keyword">return</span> fa[<span class="number">0</span>][x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int64_t</span> <span class="title">queryUp</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> tar)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> w = u; <span class="keyword">int64_t</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">20</span>; ~i; --i)</span><br><span class="line">        <span class="keyword">if</span>(d[fa[i][w]] &gt;= d[tar])</span><br><span class="line">        &#123;</span><br><span class="line">            ret += f[i][w]; w = fa[i][w];</span><br><span class="line">            ret += (<span class="number">1l</span>l&lt;&lt;i)*(c[i][w]-c[i][tar]);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int64_t</span> <span class="title">queryDown</span><span class="params">(<span class="keyword">int</span> v, <span class="keyword">int</span> dis)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> w = v; <span class="keyword">int64_t</span> ret = <span class="number">0</span>; ++dis;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">20</span>; ++i)</span><br><span class="line">        <span class="keyword">if</span>(dis&gt;&gt;i&amp;<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ret += g[i][w]; </span><br><span class="line">            ret += (<span class="number">1l</span>l&lt;&lt;i)*(c[i][v]-c[i][w]); w = fa[i][w];</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n = read(); q = read();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> x = <span class="number">1</span>; x &lt;= n; ++x) f[<span class="number">0</span>][x] = g[<span class="number">0</span>][x] = a[x] = read();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> x = read(), y = read();</span><br><span class="line">        edge[x].push_back(y); </span><br><span class="line">        edge[y].push_back(x);</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">20</span>; ++i)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x = <span class="number">1</span>; x &lt;= n; ++x)</span><br><span class="line">        &#123;</span><br><span class="line">            fa[i][x] = fa[i<span class="number">-1</span>][fa[i<span class="number">-1</span>][x]];</span><br><span class="line">            f[i][x] = f[i<span class="number">-1</span>][x]+f[i<span class="number">-1</span>][fa[i<span class="number">-1</span>][x]]+(<span class="number">1l</span>l&lt;&lt;(i<span class="number">-1</span>))*(c[i<span class="number">-1</span>][fa[i<span class="number">-1</span>][x]]-c[i<span class="number">-1</span>][fa[i][x]]);</span><br><span class="line">            g[i][x] = g[i<span class="number">-1</span>][x]+g[i<span class="number">-1</span>][fa[i<span class="number">-1</span>][x]]+(<span class="number">1l</span>l&lt;&lt;(i<span class="number">-1</span>))*(c[i<span class="number">-1</span>][x]-c[i<span class="number">-1</span>][fa[i<span class="number">-1</span>][x]]);          </span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">while</span>(q--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> u = read(), v = read();</span><br><span class="line">        <span class="keyword">int</span> uv = LCA(u, v);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, queryUp(u, fa[<span class="number">0</span>][uv])+queryDown(v, d[u]+d[v]<span class="number">-2</span>*d[uv])-queryDown(uv, d[u]-d[uv]));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>组合计数</tag>
        <tag>概率期望</tag>
        <tag>倍增</tag>
        <tag>进制</tag>
      </tags>
  </entry>
  <entry>
    <title>永远学不会的Miller–Rabin和Pollard-Rho算法</title>
    <url>/2019/05/07/%E6%B0%B8%E8%BF%9C%E5%AD%A6%E4%B8%8D%E4%BC%9A%E7%9A%84Miller%E2%80%93Rabin%E5%92%8CPollard-Rho%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p><em>下文未特殊说明则使用 <span class="math inline">\(p\)</span>
代表素数, <span class="math inline">\(n\)</span> 代表自然数</em></p>
<h2 id="miller-rabin素性检验">Miller-Rabin素性检验</h2>
<h3 id="前置知识">前置知识</h3>
<h4 id="费马小定理">费马小定理</h4>
<p>费马小定理的一般表述为</p>
<p><span class="math display">\[
\begin{aligned}
a^{p-1}\ \equiv\ 1\ (\ mod\ p\ ),\ \forall\ a \in \mathbb{N},\ (a,\ p)\
=\ 1
\end{aligned}
\]</span> <a id="more"></a>
然而遗憾的是费马小定理的逆命题并不成立，也就是</p>
<p><span class="math display">\[
\begin{aligned}
a^{n-1}\ \equiv\ 1\ (\ mod\ n\ ),\ \exists\ a \in \mathbb{N},\ \,(a,\
p)\ =\ 1 \nRightarrow n \in\ P
\end{aligned}
\]</span></p>
<p>尤其是对于一类强伪素数 <span class="math inline">\(Carmichael\)</span> 数
恰好能满足能满足费马小定理，例如 <span class="math inline">\(561\)</span></p>
<p>因此，仅使用费马小定理逆命题进行素性检验喜闻乐见的失败了</p>
<p>然而幸运的是，费马小定理存在逆否定理，我们可以据此给素性判定提供证据</p>
<h4 id="二次探测">二次探测</h4>
<p>再用费马小定理进行素性检验失败后，我们注意到一个十分有趣的引理</p>
<p><span class="math display">\[
\begin{aligned}
\forall p,\ x^2\ \equiv\ 1\ (\ mod\ p)\ \Rightarrow x_1\ =\ -1,\ x_2\ =\
1
\end{aligned}
\]</span></p>
<p>我们把 <span class="math inline">\(-1,\ 1\)</span> 称作 <span class="math inline">\(1\ mod\ p\)</span> 的平凡平方根</p>
<p>并且，对于 <span class="math inline">\(p\)</span>
而言不存在非凡平凡根</p>
<p>下面给出一个简短的证明</p>
<p>设 <span class="math inline">\(1\ mod\ p\)</span> 存在非凡平方根
<span class="math inline">\(x\)</span> 满足 <span class="math inline">\(x\ \ne 1,\ x\ \ne\ -1\)</span></p>
<p><span class="math inline">\(\because\ x^2\ \equiv\ 1\ (\ mod\ p)\
\therefore\ (x-1)(x+1)\ \equiv\ 0\ (\ mod\ p)\)</span></p>
<p><span class="math inline">\(\because(x-1)\perp(x+1)\ \therefore\ p\
|\ (x-1)\)</span> 或 <span class="math inline">\(p\ |\
(x+1)\)</span></p>
<p>与假设矛盾，所以不成立</p>
<p>我们就可以提供另一类强伪证</p>
<h3 id="算法内容">算法内容</h3>
<p>具体来说，我们对 <span class="math inline">\(n\)</span>
进行素性检测时</p>
<p>若 <span class="math inline">\(n\)</span>
为偶数，则可以直接提供证据</p>
<p>若 <span class="math inline">\(n\)</span> 为奇数，则有 <span class="math inline">\(n-1\ =\ 2^tr\)</span></p>
<p>我们设 <span class="math inline">\(x_k\ =\ x^{2^kt}\)</span> 则有
<span class="math inline">\(x_k\ =\ x_{k-1}^2\)</span></p>
<p>根据上述引理当 <span class="math inline">\(x_k\ \equiv\ 1\ (\ mod\
n)\)</span> 我们只需验证 <span class="math inline">\(x_{k-1}\)</span>
是否为 <span class="math inline">\(1\)</span> 或 <span class="math inline">\(-1\)</span> 就可以提供证据</p>
<p>同时，通过最后的 <span class="math inline">\(x^{n-1}\ mod\ p\)</span>
的值使用费马小定理的逆否定理再此提供证据</p>
<p>也就是说我们选择足够多的 <span class="math inline">\(x\)</span>
就可以通过这些强伪证得出 <span class="math inline">\(n\)</span>
时否为质数的结论</p>
<p>假设 <span class="math inline">\(k\)</span> 为试验次数，出错概率
<span class="math inline">\(P\ =\ 4^{-k}\)</span></p>
<p>而事实上，对于算法竞赛的常见数据范围，我们可以通过一些特定的 <span class="math inline">\(x\)</span> 判断，如图</p>
<figure>
<img src="/2019/05/07/%E6%B0%B8%E8%BF%9C%E5%AD%A6%E4%B8%8D%E4%BC%9A%E7%9A%84Miller%E2%80%93Rabin%E5%92%8CPollard-Rho%E7%AE%97%E6%B3%95/candidated_x.png" alt="x的选取">
<figcaption aria-hidden="true">x的选取</figcaption>
</figure>
<p>一般来说，前 <span class="math inline">\(12\)</span> 个质数即可</p>
<h3 id="p3383-模板线性筛素数素性检测"><a href="https://www.luogu.org/problemnew/show/P3383">P3383
[模板]<del>线性筛素数</del>素性检测</a></h3>
<p>虽然这是线筛的板子，但是 <span class="math inline">\(Miller-Robin\)</span> 素性检验明显由于线筛</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> int64;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">int</span> f = <span class="number">1</span>, <span class="keyword">int</span> x = <span class="number">0</span>, <span class="keyword">char</span> ch = <span class="string">&#x27; &#x27;</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">isdigit</span>(ch = getchar())) <span class="keyword">if</span>(ch == <span class="string">&#x27;-&#x27;</span>) f = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch)) x = x*<span class="number">10</span>+ch-<span class="string">&#x27;0&#x27;</span>, ch = getchar();</span><br><span class="line">    <span class="keyword">return</span> f*x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> p[] = &#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">13</span>, <span class="number">17</span>, <span class="number">19</span>, <span class="number">23</span>, <span class="number">29</span>, <span class="number">31</span>, <span class="number">37</span>&#125;; <span class="comment">// 前12个质数即可</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qpow</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>( ; b; b &gt;&gt;= <span class="number">1</span>, a = <span class="number">1l</span>l*a*a%n) <span class="keyword">if</span>(b&amp;<span class="number">1</span>) ret = <span class="number">1l</span>l*ret*a%n;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">miller_rabin</span><span class="params">(int64 n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">12</span>; ++i) <span class="keyword">if</span>(n%p[i] == <span class="number">0</span>) <span class="keyword">return</span> n == p[i]; <span class="comment">// 整除直接判断</span></span><br><span class="line">    int64 r, x, y; <span class="keyword">int</span> t;</span><br><span class="line">    <span class="keyword">for</span>(r = n<span class="number">-1</span>, t = <span class="number">0</span>; ~r&amp;<span class="number">1</span>; r &gt;&gt;= <span class="number">1</span>, ++t); <span class="comment">// n = r*2^t</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">12</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        x = qpow(p[i], r, n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= t; ++j) <span class="comment">// 二次探测</span></span><br><span class="line">        &#123;            </span><br><span class="line">            y = <span class="number">1l</span>l*x*x%n;</span><br><span class="line">            <span class="keyword">if</span>(y == <span class="number">1</span>&amp;&amp;x != n<span class="number">-1</span>&amp;&amp;x != <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 确定一定为合数</span></span><br><span class="line">            x = y;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(x != <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 费马小定理逆否定理确定为合数</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 通过这些强伪证证明是素数</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> t, n;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n = read(); t = read();</span><br><span class="line">    <span class="keyword">while</span>(t--)</span><br><span class="line">    &#123;</span><br><span class="line">        n = read();</span><br><span class="line">        <span class="keyword">if</span>(miller_rabin(n)) <span class="built_in">printf</span>(<span class="string">&quot;Yes\n&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;No\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="pollard-rho算法">Pollard-Rho算法</h2>
<h3 id="前置知识-1">前置知识</h3>
<h4 id="生日悖论">生日悖论</h4>
<p>在一个房间里需要有 <span class="math inline">\(23\)</span>
人使两个人生日相同的概率超过 <span class="math inline">\(50\%\)</span></p>
<p>在一个房间里需要有 <span class="math inline">\(64\)</span>
使人两个人生日相同的概率接近 <span class="math inline">\(1\)</span></p>
<p>所以，这种组合随机抽样的方式有很高的概率出现相同</p>
<p>由于这个问题与常识不相同，所以被叫做生日悖论</p>
<h4 id="floyd判圈算法">Floyd判圈算法</h4>
<p>假设序列 <span class="math inline">\(\{x_k\}\)</span> 再 <span class="math inline">\(x_u\)</span> 之后出现长度为 <span class="math inline">\(v\)</span> 的循环，既满足 <span class="math inline">\(x_{u+v}\ =\
x_u\)</span>，考虑龟兔赛跑的过程，我们让一个指针走的快，另一个指针走的慢，最后一定会的相遇而此时周期即为时间
<span class="math inline">\(t\)</span></p>
<h5 id="算法演示"><a href="https://visualgo.net/zh/cyclefinding">算法演示</a></h5>
<figure>
<img src="/2019/05/07/%E6%B0%B8%E8%BF%9C%E5%AD%A6%E4%B8%8D%E4%BC%9A%E7%9A%84Miller%E2%80%93Rabin%E5%92%8CPollard-Rho%E7%AE%97%E6%B3%95/cyclefinding.png" alt="判圈算法">
<figcaption aria-hidden="true">判圈算法</figcaption>
</figure>
<h3 id="算法内容-1">算法内容</h3>
<p>考虑 <span class="math inline">\(n\ =\ ab\)</span> 其中 <span class="math inline">\(a,\ b\)</span> 是 <span class="math inline">\(n\)</span> 的非平凡因子，即 <span class="math inline">\(a,\ b\ \ne\ 1,\ n\)</span> 且 <span class="math inline">\(a,\ b\ |\ n\)</span></p>
<p>我们如果单纯随机 <span class="math inline">\(a\)</span>
是不可能的</p>
<p>我们注意到如果 <span class="math inline">\(x-y\ |\ a\)</span> 和
<span class="math inline">\(x-y\ \nmid n\)</span> 那么 <span class="math inline">\(a\ =\ (x-y,\ n)\)</span></p>
<p>所以，我们可以随机选择不相等的 <span class="math inline">\(x\)</span>
和 <span class="math inline">\(y\)</span> 的算出 <span class="math inline">\(a\)</span> 而且我们只需随机 <span class="math inline">\(O(n^{\frac{1}{4}})\)</span> 组即可
关键是如何选出不相等的和如何储存大量随机数</p>
<p>考虑模 <span class="math inline">\(n\)</span> 意义下随机多项式 <span class="math inline">\(g(x)\ \equiv\ x^2+c\ (mod\ n)\)</span>
生成伪随机数列 <span class="math inline">\(\{x_k\}\)</span></p>
<p>但由于 <span class="math inline">\(\{x_k\}\)</span> 是 <span class="math inline">\(n\)</span> 的剩余系，所以是有限的</p>
<p>因此根据生日悖论 <span class="math inline">\(O(\sqrt{n})\)</span>
的期望下我们可以找到一个相同的 <span class="math inline">\(x\)</span> 和
<span class="math inline">\(y\)</span> 之后出现周期，实现即使用 <span class="math inline">\(Floyd\)</span>
判圈算法，而在出现环前我们有极大可能找到了非平凡因子，否则就更换参数
<span class="math inline">\(c\)</span> 重新寻找</p>
<p>这个过程就像走希腊字母 <span class="math inline">\(\rho\)</span>
路径因此得名</p>
<figure>
<img src="/2019/05/07/%E6%B0%B8%E8%BF%9C%E5%AD%A6%E4%B8%8D%E4%BC%9A%E7%9A%84Miller%E2%80%93Rabin%E5%92%8CPollard-Rho%E7%AE%97%E6%B3%95/rho.jpg" alt="Rho的来历">
<figcaption aria-hidden="true">Rho的来历</figcaption>
</figure>
<h3 id="p4718-模板pollard-rho算法"><a href="https://www.luogu.org/problemnew/show/P4718">P4718
[模板]Pollard-Rho算法</a></h3>
<p>Pollar-Rho板子题</p>
<p>按照上述<del>口胡</del></p>
<p>我们大致写出程序主体，但事实上发现喜闻乐见的 <span class="math inline">\(TLE\)</span> 了</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">uint64 <span class="title">func</span><span class="params">(uint64 x, uint64 c, uint64 n)</span> </span>&#123; <span class="keyword">return</span> ((int128)x*x%n+c)%n; &#125;</span><br><span class="line"><span class="function">uint64 <span class="title">find</span><span class="params">(uint64 n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">12</span>; ++i) <span class="keyword">if</span>(n%p[i] == <span class="number">0</span>) <span class="keyword">return</span> p[i]; <span class="comment">// 用12个质数判一下，小数据不能达到期望</span></span><br><span class="line">    <span class="keyword">int</span> s = <span class="number">0</span>, c = rand(); uint64 x, y;</span><br><span class="line">    x = y = func(rand(), c, n);</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        uint64 d = gcd((x-y+n)%n, n); <span class="comment">// 验证是否为非平凡因子</span></span><br><span class="line">        <span class="keyword">if</span>(d != <span class="number">1</span>&amp;&amp;d != n) <span class="keyword">return</span> d;</span><br><span class="line">        x = func(x, c, n); y = func(func(y, c, n), c, n); ++s; <span class="comment">// floyd 判圈</span></span><br><span class="line">    &#125; <span class="keyword">while</span>(x != y&amp;&amp;s &lt;= S);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pollar_rho</span><span class="params">(uint64 n, uint64 &amp;mfact)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n &lt;= mfact) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">while</span>(~n&amp;<span class="number">1</span>) n &gt;&gt;= <span class="number">1</span>, mfact = max(mfact, (uint64)<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">1</span>||miller_robin(n)) <span class="keyword">return</span> <span class="keyword">void</span>(mfact = max(mfact, n));</span><br><span class="line">    uint64 d = find(n); <span class="keyword">for</span>( ; !d; d = find(n));</span><br><span class="line">    d = max(d, n/d); <span class="comment">// 继续分解</span></span><br><span class="line">    pollar_rho(d, mfact); pollar_rho(n/d, mfact); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以下是我也看不懂，但感觉很有道理的优化</p>
<p><span class="math inline">\(TLE\)</span> 的瓶颈在于 <span class="math inline">\(gcd\)</span> 的多次计算</p>
<p>考虑 <span class="math inline">\(gcd(ac,\ b) = gcd(a,
b)\)</span>，我们可以把多个 <span class="math inline">\(gcd\)</span>
一起计算</p>
<p>同时使用倍增的思想依次增大样本集合，每次选择组大小一定的 <span class="math inline">\(x, y\)</span> 一起计算</p>
<p>目的是达到不再环上停留同时优化 <span class="math inline">\(gcd\)</span></p>
<p>至于组的大小，<span class="math inline">\(wiki\)</span> 上是 <span class="math inline">\(100\)</span>，<span class="math inline">\(zzt\)</span> 是 <span class="math inline">\(512\)</span>，也有人是 <span class="math inline">\(127\)</span></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">uint64 <span class="title">find</span><span class="params">(uint64 n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">12</span>; ++i) <span class="keyword">if</span>(n%p[i] == <span class="number">0</span>) <span class="keyword">return</span> p[i];</span><br><span class="line">    <span class="keyword">int</span> c = rand(); uint64 y = rand(), x = y, z, g;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> s = <span class="number">1</span>; ; s &lt;&lt;= <span class="number">1</span>, x = y)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= s; k += S) <span class="comment">// 一组一组的算</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> t = min(S, s-k); g = <span class="number">1</span>, z = y;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= t; ++i) y = f(y), g = (int128)g*(y-x+n)%n;</span><br><span class="line">            g = gcd(g, n);</span><br><span class="line">            <span class="keyword">if</span>(g == <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(g == n) <span class="keyword">for</span>(g = <span class="number">1</span>, y = z; g == <span class="number">1</span>; ) y = f(y), g = gcd(y-x+n, n); <span class="comment">// 若最大公约数不为 1 则出现了 大于 1的因子</span></span><br><span class="line">            <span class="keyword">return</span> g;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>完整代码 <del>数据类型转换过于毒瘤</del></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> f(x) ((int128)x*x+c)%n</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> uint64;</span><br><span class="line"><span class="keyword">typedef</span> __int128 int128;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> uint64 <span class="title">read</span><span class="params">(<span class="keyword">int</span> f = <span class="number">1</span>, uint64 x = <span class="number">0</span>, <span class="keyword">char</span> ch = <span class="string">&#x27; &#x27;</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">isdigit</span>(ch = getchar())) <span class="keyword">if</span>(ch == <span class="string">&#x27;-&#x27;</span>) f = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch)) x = x*<span class="number">10</span>+ch-<span class="string">&#x27;0&#x27;</span>, ch = getchar();</span><br><span class="line">    <span class="keyword">return</span> f*x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> p[] = &#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">13</span>, <span class="number">17</span>, <span class="number">19</span>, <span class="number">23</span>, <span class="number">29</span>, <span class="number">31</span>, <span class="number">37</span>&#125;, S = <span class="number">127</span>;</span><br><span class="line"><span class="function">uint64 <span class="title">qpow</span><span class="params">(uint64 a, uint64 b, uint64 n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    uint64 ret = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>( ; b; b &gt;&gt;= <span class="number">1</span>, a = (int128)a*a%n) <span class="keyword">if</span>(b&amp;<span class="number">1</span>) ret = (int128)ret*a%n;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">uint64 <span class="title">gcd</span><span class="params">(uint64 a, uint64 b)</span> </span>&#123; <span class="keyword">return</span> b?gcd(b, a%b):a; &#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">miller_robin</span><span class="params">(uint64 n)</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">12</span>; ++i) <span class="keyword">if</span>(n%p[i] == <span class="number">0</span>) <span class="keyword">return</span> n == p[i];</span><br><span class="line">    uint64 r; <span class="keyword">int</span> t;</span><br><span class="line">    <span class="keyword">for</span>(r = n<span class="number">-1</span>, t = <span class="number">0</span>; ~r&amp;<span class="number">1</span>; r &gt;&gt;= <span class="number">1</span>, ++t);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">12</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        uint64 x = qpow(p[i], r, n), xs;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= t; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            xs = (int128)x*x%n;</span><br><span class="line">            <span class="keyword">if</span>(xs == <span class="number">1</span>&amp;&amp;x != <span class="number">1</span>&amp;&amp;x != n<span class="number">-1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            x = xs;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(x != <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">uint64 <span class="title">find</span><span class="params">(uint64 n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">12</span>; ++i) <span class="keyword">if</span>(n%p[i] == <span class="number">0</span>) <span class="keyword">return</span> p[i];</span><br><span class="line">    <span class="keyword">int</span> c = rand(); uint64 y = rand(), x = y, z, g;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> s = <span class="number">1</span>; ; s &lt;&lt;= <span class="number">1</span>, x = y)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= s; ++i) y = f(y);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= s; k += S)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> t = min(S, s-k); g = <span class="number">1</span>, z = y;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= t; ++i) y = f(y), g = (int128)g*(y-x+n)%n;</span><br><span class="line">            g = gcd(g, n);</span><br><span class="line">            <span class="keyword">if</span>(g == <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(g == n) <span class="keyword">for</span>(g = <span class="number">1</span>, y = z; g == <span class="number">1</span>; ) y = f(y), g = gcd(y-x+n, n);</span><br><span class="line">            <span class="keyword">return</span> g;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pollard_rho</span><span class="params">(uint64 n, uint64 &amp;mfact)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n &lt;= mfact) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">while</span>(~n&amp;<span class="number">1</span>) n &gt;&gt;= <span class="number">1</span>, mfact = max(mfact, (uint64)<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">1</span>||miller_robin(n)) <span class="keyword">return</span> <span class="keyword">void</span>(mfact = max(mfact, n));</span><br><span class="line">    uint64 d = find(n); <span class="keyword">for</span>( ; d == n; d = find(n));</span><br><span class="line">    d = max(d, n/d);</span><br><span class="line">    pollar_rho(d, mfact); pollar_rho(n/d, mfact); </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> t;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    srand(<span class="number">19260817</span>);</span><br><span class="line">    t = read();</span><br><span class="line">    <span class="keyword">while</span>(t--)</span><br><span class="line">    &#123;</span><br><span class="line">        uint64 n = read(), m = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(miller_robin(n)) <span class="built_in">puts</span>(<span class="string">&quot;Prime&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> pollar_rho(n, m), <span class="built_in">printf</span>(<span class="string">&quot;%llu\n&quot;</span>, m);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><em>特别感谢 wikipedia visualgo whzzt LinearOD</em></p>
<p><em>资料来源</em></p>
<p><a href="https://www.luogu.org/blog/JasonZhou200337/pollard-rho-suan-fa-jian-jie">Pollard
Rho 算法简介</a></p>
<p><a href="https://en.wikipedia.org/wiki/Pollard%27s_rho_algorithm">Pollard-Rho
algorithm</a></p>
<p><a href="https://en.wikipedia.org/wiki/Birthday_problem">Birthday
problem</a></p>
<p><a href="https://blog.csdn.net/whzzt/article/details/81069289#comments">Pollard's
Rho Algorithm</a></p>
<p><a href="https://en.wikipedia.org/wiki/Miller%E2%80%93Rabin_primality_test">Miller-Rabin
primality test</a></p>
]]></content>
      <categories>
        <category>模板</category>
      </categories>
      <tags>
        <tag>数论</tag>
        <tag>素数相关</tag>
      </tags>
  </entry>
  <entry>
    <title>60509102 NOIP模拟题</title>
    <url>/2019/05/06/60509102-NOIP%E6%A8%A1%E6%8B%9F%E9%A2%98/</url>
    <content><![CDATA[<h2 id="zyb和售货机">ZYB和售货机</h2>
<h2 id="题面描述">题面描述</h2>
<p>基环内向树森林，每个点有一个容量和权值，每次可以选择一个容量不为
<span class="math inline">\(0\)</span>
的点把它的出点容量减少，答案增加减少量乘点权，最大化收益</p>
<h2 id="题解">题解</h2>
<p>由题意知，<span class="math inline">\((i,\ f_i)\)</span>
构成的边集和所给点集构成了基环内向树森林</p>
<p>基环内向树即使有且仅有一个有向环，且所有点出度为 <span class="math inline">\(1\)</span> 的树形图</p>
<p><img src="/2019/05/06/60509102-NOIP%E6%A8%A1%E6%8B%9F%E9%A2%98/graph.png" alt="基环内向树">
<a id="more"></a>
稍加思考我们可以发现对于每一个非叶节点的容量都可以通过找连向它的点权最大值来配对直到容量变为
<span class="math inline">\(1\)</span></p>
<p>并且通过每个节点找连向它的节点的最大值这样的构造使树形图分割成若干个有向链和不超过
<span class="math inline">\(1\)</span> 个的有向环</p>
<p>并且在这种构造下，每个点的入度和出度都不超过 <span class="math inline">\(1\)</span> 所以一定不相交</p>
<p>而且如果存在环，一定是基环树的环</p>
<p>像这样</p>
<figure>
<img src="/2019/05/06/60509102-NOIP%E6%A8%A1%E6%8B%9F%E9%A2%98/plan_2.png" alt="只有链">
<figcaption aria-hidden="true">只有链</figcaption>
</figure>
<p>或这样</p>
<figure>
<img src="/2019/05/06/60509102-NOIP%E6%A8%A1%E6%8B%9F%E9%A2%98/plan_1.png" alt="有链和环">
<figcaption aria-hidden="true">有链和环</figcaption>
</figure>
<p>对于链而言，我们从出度为 <span class="math inline">\(0\)</span>
的点一直选下去就是合法的</p>
<p>对于环而言，我们必须断掉一个环边换成树边，所以我们必须找到一个最大值和次大值差最小的点</p>
<p>断环加边不会出现新的环，因为基环树只有一个环</p>
<p>对于上一张图，需要这样断</p>
<figure>
<img src="/2019/05/06/60509102-NOIP%E6%A8%A1%E6%8B%9F%E9%A2%98/plan_3.png" alt="断环">
<figcaption aria-hidden="true">断环</figcaption>
</figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> int64;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">int</span> f = <span class="number">1</span>, <span class="keyword">int</span> x = <span class="number">0</span>, <span class="keyword">char</span> ch = <span class="string">&#x27; &#x27;</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">isdigit</span>(ch = getchar())) <span class="keyword">if</span>(ch == <span class="string">&#x27;-&#x27;</span>) f = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch)) x = x*<span class="number">10</span>+ch-<span class="string">&#x27;0&#x27;</span>, ch = getchar();</span><br><span class="line">    <span class="keyword">return</span> f*x; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span>+<span class="number">5</span>, INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> n, f[N], c[N], d[N], a[N];</span><br><span class="line"><span class="keyword">int</span> col[N], w[N], fm[N], sm[N], mind;</span><br><span class="line">int64 ans;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(col[x] == p) </span><br><span class="line">    &#123;</span><br><span class="line">        ans -= mind; </span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(col[x]) <span class="keyword">return</span>; <span class="comment">// 是之前遍历到的链</span></span><br><span class="line">    col[x] = p;</span><br><span class="line">    <span class="keyword">if</span>(!fm[x]) <span class="keyword">return</span>;</span><br><span class="line">    ans += <span class="number">1l</span>l*w[fm[x]]*a[x];</span><br><span class="line">    mind = min(mind, w[fm[x]]-w[sm[x]]);</span><br><span class="line">    <span class="keyword">if</span>(fm[x] != x) dfs(fm[x], p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">    freopen(<span class="string">&quot;goods.in&quot;</span>, <span class="string">&quot;r&quot;</span>, <span class="built_in">stdin</span>);</span><br><span class="line">    freopen(<span class="string">&quot;goods.out&quot;</span>, <span class="string">&quot;w&quot;</span>, <span class="built_in">stdout</span>);</span><br><span class="line">    n = read();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> x = <span class="number">1</span>; x &lt;= n; ++x) f[x] = read(), c[x] = read(), d[x] = read(), a[x] = read();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> x = <span class="number">1</span>; x &lt;= n; ++x)</span><br><span class="line">    &#123;</span><br><span class="line">        w[x] = d[f[x]]-c[x];</span><br><span class="line">        <span class="keyword">if</span>(w[x] &gt; w[fm[f[x]]]) sm[f[x]] = fm[f[x]], fm[f[x]] = x;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(w[x] &gt; w[sm[f[x]]]) sm[f[x]] = x; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> x = <span class="number">1</span>; x &lt;= n; ++x)</span><br><span class="line">        <span class="keyword">if</span>(!col[x]) mind = INF, dfs(x, x); <span class="comment">// 如果x在环上则一定遍历了环的所有部分，而链有可能只有一部分</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="zyb玩字符串">ZYB玩字符串</h2>
<blockquote>
<p>给定字符串并已知该字符串是由若干个原串按顺序离散后重组成的，求出长度最小且字典序最小原串</p>
</blockquote>
<p>我们考虑判断一个串是否合法的过程，发现如果按从左向右的顺序依次考虑则对于
<span class="math inline">\([l,\ r]\)</span> 来说以合法地删去若干原串
<span class="math inline">\(p\)</span> 后剩下的部分一定是 <span class="math inline">\(p\)</span> 的前缀</p>
<p>考虑状态 <span class="math inline">\(f_{l,r}\)</span> 表示 <span class="math inline">\([l,\ r]\)</span> 合法地删去若干原串后是否为 <span class="math inline">\(p\)</span> 的前缀，并且当 <span class="math inline">\(l_p|r-l+1\)</span> 时 <span class="math inline">\([l,\ r]\)</span> 恰好被 <span class="math inline">\(p\)</span> 删完</p>
<p>所以考虑 <span class="math inline">\(f_{l,r}\)</span>
如何转移出去</p>
<p>首先可以在 <span class="math inline">\(f_{l,r}\)</span>
后匹配当前前缀的下一个字符</p>
<p><span class="math display">\[
\begin{aligned}
f_{l,r+1}\ =\ f_{l,r}\ \&amp;\ [\ s[r+1]\ ==\ p[(r-l+1)\ mod\ l_p+1]\ ]
\end{aligned}
\]</span></p>
<p>其次可以在 <span class="math inline">\(f_{l,r}\)</span>
后加上一个合法的恰好被完全删完的区间</p>
<p><span class="math display">\[
\begin{aligned}
f_{l,r+k\times l_p}\ =\ f_{l,r}\ \&amp;\ f_{r+1,r+k\times l_p}
\end{aligned}
\]</span></p>
<p>我们把刷表改成填表差不多就是一个常规的区间 <span class="math inline">\(DP\)</span> 了</p>
<p>注意微小的剪枝即可</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e2</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> t, n;</span><br><span class="line"><span class="built_in">string</span> s, p;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; ans;</span><br><span class="line"><span class="keyword">int</span> f[N][N];</span><br><span class="line"><span class="keyword">int</span> c[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> lp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(~f[l][r]) <span class="keyword">return</span> f[l][r];</span><br><span class="line">    <span class="keyword">if</span>(l == r) <span class="keyword">return</span> f[l][r] = p[<span class="number">1</span>] == s[l];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>; l &lt;= r-k*lp; ++k) </span><br><span class="line">        <span class="keyword">if</span>(dfs(l, r-k*lp, lp)&amp;&amp;dfs(r-k*lp+<span class="number">1</span>, r, lp)) </span><br><span class="line">            <span class="keyword">return</span> f[l][r] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(s[r] == p[(r-l)%lp+<span class="number">1</span>]) <span class="keyword">return</span> f[l][r] = dfs(l, r<span class="number">-1</span>, lp);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> f[l][r] = <span class="number">0</span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">valid</span><span class="params">(<span class="keyword">int</span> lp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(f, <span class="number">-1</span>, <span class="keyword">sizeof</span>(f));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="string">&#x27;a&#x27;</span>; i &lt;= <span class="string">&#x27;z&#x27;</span>; ++i) c[i] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= lp; ++i) ++c[p[i]];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="keyword">if</span>(!c[s[i]]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> dfs(<span class="number">1</span>, n, lp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    freopen(<span class="string">&quot;string.in&quot;</span>, <span class="string">&quot;r&quot;</span>, <span class="built_in">stdin</span>);</span><br><span class="line">    freopen(<span class="string">&quot;string.out&quot;</span>, <span class="string">&quot;w&quot;</span>, <span class="built_in">stdout</span>);</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;s; n = s.length(); s = <span class="string">&#x27; &#x27;</span>+s; ans.clear();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> lp = <span class="number">1</span>; lp &lt;= n&amp;&amp;ans.empty(); ++lp)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(n%lp) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n-lp+<span class="number">1</span>; ++i)</span><br><span class="line">            &#123;</span><br><span class="line">                p = s.substr(i, lp); p = <span class="string">&#x27; &#x27;</span>+p;</span><br><span class="line">                <span class="keyword">if</span>(valid(lp)) ans.push_back(s.substr(i, lp));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        sort(ans.begin(), ans.end());</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;ans[<span class="number">0</span>]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>贪心</tag>
        <tag>基环树</tag>
      </tags>
  </entry>
  <entry>
    <title>[TJOI2017]异或和</title>
    <url>/2019/05/06/TJOI2017-%E5%BC%82%E6%88%96%E5%92%8C/</url>
    <content><![CDATA[<h2 id="题面描述">题面描述</h2>
<p>连续和的异或值。</p>
<h2 id="题解">题解</h2>
<p>题目实际要求出</p>
<p><span class="math display">\[
\begin{aligned}
ans\ =\ \oplus \sum_{i=1}^n\sum_{j=0}^{i-1}sum_i-sum_j
\end{aligned}
\]</span></p>
<p><del>然后，我看了一下二进制加法器后直接弃疗</del> <a id="more"></a>
实际上，几乎所有二进制题都是按位考虑的</p>
<p>我们把它改写成按位考虑的形式</p>
<p><span class="math display">\[
\begin{aligned}
ans = \sum_{k=0}^{2^k\le sum_n} (
\sum_{i=1}^n\sum_{j=0}^{i-1}(sum_i-sum_j)&gt;&gt;k\&amp; 1\ (mod 2)
)&lt;&lt;k
\end{aligned}
\]</span></p>
<p>按位考虑后实际上就是对于 <span class="math inline">\(sum_i\)</span>
而言， 前面有多少 <span class="math inline">\(sum_j\)</span> 与 <span class="math inline">\(sum_i\)</span> 差在 <span class="math inline">\(k\)</span> 为 <span class="math inline">\(1\)</span></p>
<p>当 <span class="math inline">\(sum_i\)</span> 这一位为 <span class="math inline">\(1\)</span> 则差仍为此的情况必定为 <span class="math inline">\(sum_j\)</span> 这一位为 <span class="math inline">\(0\)</span> 且之前没有借位</p>
<p>另一种情况恰好相反</p>
<p>所以问题在于是否借位，考虑竖式计算的过程，发现 当且仅当 <span class="math inline">\(sum_i \&amp;(2^k-1)\ \ge\
sum_j\&amp;(2^k-1)\)</span> 不会借位</p>
<p>用权值树状数组维护一下就好了</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> int64;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">int</span> f = <span class="number">1</span>, <span class="keyword">int</span> x = <span class="number">0</span>, <span class="keyword">char</span> ch = <span class="string">&#x27; &#x27;</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">isdigit</span>(ch = getchar())) <span class="keyword">if</span>(ch == <span class="string">&#x27;-&#x27;</span>) f = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch)) x = x*<span class="number">10</span>+ch-<span class="string">&#x27;0&#x27;</span>, ch = getchar();</span><br><span class="line">    <span class="keyword">return</span> f*x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e6</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, sum[N];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Fenwick</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    int64 c[N];</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123; <span class="built_in">memset</span>(c, <span class="number">0</span>, <span class="keyword">sizeof</span>(c)); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; ++x; <span class="keyword">for</span>( ; x &lt;= m+<span class="number">1</span>; x += x&amp;-x) ++c[x]; &#125;</span><br><span class="line">    <span class="function">int64 <span class="title">ask</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="keyword">int</span> ret = <span class="number">0</span> ; ++x; <span class="keyword">for</span>( ; x; x -= x&amp;-x) ret += c[x]; <span class="keyword">return</span> ret; &#125;</span><br><span class="line">    <span class="function">int64 <span class="title">query</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123; <span class="keyword">return</span> ask(r)-ask(l<span class="number">-1</span>); &#125; </span><br><span class="line">&#125;t[<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> ans;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n = read();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) sum[i] = sum[i<span class="number">-1</span>]+read();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; (<span class="number">1</span>&lt;&lt;k) &lt;= sum[n]; ++k)</span><br><span class="line">    &#123;</span><br><span class="line">        m = (<span class="number">1</span>&lt;&lt;k)<span class="number">-1</span>; int64 p = <span class="number">0</span>;</span><br><span class="line">        t[<span class="number">0</span>].clear(); t[<span class="number">1</span>].clear();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> c = (sum[i]&gt;&gt;k&amp;<span class="number">1</span>), d = (sum[i]&amp;m);</span><br><span class="line">            p += t[c^<span class="number">1</span>].query(<span class="number">0</span>, d)+t[c^<span class="number">0</span>].query(d+<span class="number">1</span>, m); </span><br><span class="line">            t[c].add(d);</span><br><span class="line">        &#125;</span><br><span class="line">        ans += (<span class="number">1</span>&lt;&lt;k)*(p%<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>进制</tag>
        <tag>树状数组</tag>
      </tags>
  </entry>
  <entry>
    <title>[HEOI2013]SAO</title>
    <url>/2019/05/05/HEOI2013-SAO/</url>
    <content><![CDATA[<h2 id="题面描述">题面描述</h2>
<p>树形图拓扑排序计数</p>
<h2 id="题解">题解</h2>
<p><em>论用一种错误的顺序做三倍经验是一种怎样的体验</em> <a id="more"></a>
DAG 的拓扑排序计数一般是用 状压DP 解决的</p>
<p>但由于这道题树形图的特殊性质，我们可以考虑 树形DP</p>
<p>设 <span class="math inline">\(f_x\)</span> 表示以 <span class="math inline">\(x\)</span> 为根的子树拓扑排序的个数</p>
<p>考虑 <span class="math inline">\(f_x\)</span> 如何由 <span class="math inline">\(f_y\)</span> , <span class="math inline">\(y\in
son_x\)</span> 推出</p>
<p>发现目前状态不足以表示状态，我们需要知道拓扑排序的大致形态</p>
<p>注意到 <span class="math inline">\(x\)</span> 的取值只受 <span class="math inline">\(y\)</span> 的取值的影响，所以就有</p>
<p>设 <span class="math inline">\(f_{x,n}\)</span> 表示以 <span class="math inline">\(x\)</span> 为根的子树 <span class="math inline">\(x\)</span> 排名为 <span class="math inline">\(n\)</span> 的拓扑排序个数</p>
<p>以此设计转移</p>
<p>当 <span class="math inline">\(y\)</span> 在 <span class="math inline">\(x\)</span> 前面时 考虑把 <span class="math inline">\(y\)</span> 中有 <span class="math inline">\(j\)</span> 在排名已为 <span class="math inline">\(i\)</span> 的 <span class="math inline">\(x\)</span> 之前，我们枚举 <span class="math inline">\(y\)</span> 的不超过 <span class="math inline">\(j\)</span> 的排名就有</p>
<p><span class="math display">\[
\begin{aligned}
f_{x,i+j-1}\ =\ \sum_{k=1}^j\binom{i+j-1}{i-1}
\binom{size_x+size_y-i-j}{size_y-j}f_{x,i}
\ f_{y,k}
\end{aligned}
\]</span></p>
<p>当 <span class="math inline">\(y\)</span> 在 <span class="math inline">\(x\)</span> 后面时 考虑把 <span class="math inline">\(y\)</span> 中有 <span class="math inline">\(j\)</span> 在排名已为 <span class="math inline">\(i\)</span> 的 <span class="math inline">\(x\)</span> 之前，我们枚举 <span class="math inline">\(y\)</span> 的超过 <span class="math inline">\(j\)</span> 的排名就有</p>
<p><span class="math display">\[
\begin{aligned}
f_{x,i+j-1}\ =\ \sum_{k=j+1}^{size_y}\binom{i+j-1}{i-1}
\binom{size_x+size_y-i-j}{size_y-j}f_{x,i}
\ f_{y,k}
\end{aligned}
\]</span></p>
<p>当我们把交换和式后发现只需要维护前缀和和后缀和即可</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int unsigned long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">int</span> f = <span class="number">1</span>, <span class="keyword">int</span> x = <span class="number">0</span>, <span class="keyword">char</span> ch = <span class="string">&#x27; &#x27;</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">isdigit</span>(ch = getchar())) <span class="keyword">if</span>(ch == <span class="string">&#x27;-&#x27;</span>) f = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch)) x = x*<span class="number">10</span>+ch-<span class="string">&#x27;0&#x27;</span>, ch = getchar();</span><br><span class="line">    <span class="keyword">return</span> f*x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1000</span>+<span class="number">5</span>, P = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> t, n, c[N][N];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &gt; edge[N];</span><br><span class="line"><span class="keyword">int</span> f[N][N], size[N], g[N];</span><br><span class="line"><span class="keyword">int</span> pre[N][N], suf[N][N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">C</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123; <span class="keyword">return</span> n&lt;m?<span class="number">0</span>:c[n][m];  &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    size[x] = f[x][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; edge[x].size(); ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> y = edge[x][i].first, z = edge[x][i].second;</span><br><span class="line">        <span class="keyword">if</span>(y == fa) <span class="keyword">continue</span>; dfs(y, x); </span><br><span class="line">        <span class="built_in">memset</span>(g, <span class="number">0</span>, <span class="keyword">sizeof</span>(g));</span><br><span class="line">        <span class="keyword">if</span>(z) <span class="comment">// y 在 x 前面</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= size[x]; ++i)                    </span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= size[y]; ++j) <span class="comment">// 枚举有多少个在x前面</span></span><br><span class="line">                    g[i+j] = (g[i+j]+f[x][i]*pre[y][j]%P*C(i+j<span class="number">-1</span>, i<span class="number">-1</span>)%P*C(size[x]+size[y]-i-j, size[x]-i)%P)%P;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="comment">// y 在 x 后面</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= size[x]; ++i)                    </span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= size[y]; ++j) <span class="comment">// 枚举有多少个在x前面</span></span><br><span class="line">                        g[i+j] = (g[i+j]+f[x][i]*suf[y][j+<span class="number">1</span>]%P*C(i+j<span class="number">-1</span>, i<span class="number">-1</span>)%P*C(size[x]+size[y]-i-j, size[x]-i)%P)%P;      </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">memcpy</span>(f[x], g, <span class="keyword">sizeof</span>(f[x]));</span><br><span class="line">        size[x] += size[y];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= size[x]; ++i) pre[x][i] = (pre[x][i<span class="number">-1</span>]+f[x][i])%P;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = size[x]; i; --i) suf[x][i] = (suf[x][i+<span class="number">1</span>]+f[x][i])%P;   </span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">int</span> ans;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    t = read();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i) c[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N; ++i)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; ++j)</span><br><span class="line">            c[i][j] = (c[i<span class="number">-1</span>][j]+c[i<span class="number">-1</span>][j<span class="number">-1</span>])%P;</span><br><span class="line">    <span class="keyword">while</span>(t--)</span><br><span class="line">    &#123;</span><br><span class="line">        n = read();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x = <span class="number">1</span>; x &lt;= n; ++x) edge[x].clear();</span><br><span class="line">        <span class="built_in">memset</span>(pre, <span class="number">0</span>, <span class="keyword">sizeof</span>(pre));</span><br><span class="line">        <span class="built_in">memset</span>(suf, <span class="number">0</span>, <span class="keyword">sizeof</span>(suf));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> x, y, z; <span class="keyword">char</span> op[<span class="number">7</span>];</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%llu%s%llu&quot;</span>, &amp;x, op, &amp;y);</span><br><span class="line">            z = op[<span class="number">0</span>] == <span class="string">&#x27;&lt;&#x27;</span>; ++x; ++y;</span><br><span class="line">            edge[x].push_back(<span class="built_in">make_pair</span>(y, z));</span><br><span class="line">            edge[y].push_back(<span class="built_in">make_pair</span>(x, z^<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(<span class="number">1</span>, <span class="number">0</span>); ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) ans = (ans+f[<span class="number">1</span>][i])%P;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%llu\n&quot;</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>组合计数</tag>
      </tags>
  </entry>
  <entry>
    <title>[CQOI2017]老C的方块</title>
    <url>/2019/05/05/CQOI2017-%E8%80%81C%E7%9A%84%E6%96%B9%E5%9D%97/</url>
    <content><![CDATA[<h2 id="题面描述">题面描述</h2>
<p>在棋盘内破坏指定联通块的最小代价</p>
<p><img src="/2019/05/05/CQOI2017-%E8%80%81C%E7%9A%84%E6%96%B9%E5%9D%97/cc.png" alt="需要破坏的联通块">
<a id="more"></a></p>
<h2 id="题解">题解</h2>
<p>观察联通块，我们发现可以一个需要破坏的联通块是以蓝线为中心的八联通块，其中蓝线两边必须有2个方块，除此之外，蓝线两边至少要有1个方块</p>
<p>其次，我们知道破坏棋盘问题网络流一般是黑白染色</p>
<p>但是这道题无法黑白染色，因为无法体现蓝线的性质，所以我们采取如下的染色</p>
<figure>
<img src="/2019/05/05/CQOI2017-%E8%80%81C%E7%9A%84%E6%96%B9%E5%9D%97/chess.png" alt="染色方案">
<figcaption aria-hidden="true">染色方案</figcaption>
</figure>
<p>我们发现这样染色可以很好体现刚才分析的性质</p>
<figure>
<img src="/2019/05/05/CQOI2017-%E8%80%81C%E7%9A%84%E6%96%B9%E5%9D%97/ccc.png" alt="染色后的联通块">
<figcaption aria-hidden="true">染色后的联通块</figcaption>
</figure>
<p>蓝线恰好位于红蓝两色之前，除了红蓝两色以外，两边各有3个不同颜色的块</p>
<p>我们考虑建模表示破坏联通块的方法</p>
<p>断掉联通块后不连通，实际上就是就是求最小割</p>
<p>破坏的最小代价就是三绿，三黄，红，蓝最小值</p>
<p>网络流中并联表示或，串联表示与</p>
<p>因此采用如下建图</p>
<p>源点并联黄点 容量为黄点权值</p>
<p>绿点并联汇点 容量为绿点权值</p>
<p>黄点连红点 蓝点连绿点 容量为INF</p>
<p>红点连蓝点 容量为红蓝最小值</p>
<p>至于染色判断，找规律即可</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">int</span> f = <span class="number">1</span>, <span class="keyword">int</span> x = <span class="number">0</span>, <span class="keyword">char</span> ch = <span class="string">&#x27; &#x27;</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">isdigit</span>(ch = getchar())) <span class="keyword">if</span>(ch == <span class="string">&#x27;-&#x27;</span>) f = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch)) x = x*<span class="number">10</span>+ch-<span class="string">&#x27;0&#x27;</span>, ch = getchar();</span><br><span class="line">    <span class="keyword">return</span> f*x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">6e6</span>+<span class="number">5</span>, INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">1</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> dy[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> next, to, w;</span><br><span class="line">    Edge(<span class="keyword">int</span> next = <span class="number">0</span>, <span class="keyword">int</span> to = <span class="number">0</span>, <span class="keyword">int</span> w = <span class="number">0</span>): next(next), to(to), w(w) &#123;&#125;;</span><br><span class="line">&#125;edge[N];</span><br><span class="line"><span class="keyword">int</span> tot = <span class="number">1</span>, head[N], s, t, n, m;</span><br><span class="line"><span class="keyword">void</span> _add(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> z) &#123; edge[++tot] = Edge(head[x], y, z); head[x] = tot; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> z)</span> </span>&#123; _add(x, y, z); _add(y, x, <span class="number">0</span>); &#125;</span><br><span class="line"><span class="keyword">int</span> d[N];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">bfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="built_in">memset</span>(d, <span class="number">0</span>, <span class="keyword">sizeof</span>(d));</span><br><span class="line">   <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q; q.push(s); d[s] = <span class="number">1</span>;</span><br><span class="line">   <span class="keyword">while</span>(q.size())</span><br><span class="line">   &#123;</span><br><span class="line">       <span class="keyword">int</span> x = q.front(); q.pop();</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i = head[x]; i; i = edge[i].next)</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="keyword">int</span> y = edge[i].to, z = edge[i].w;</span><br><span class="line">           <span class="keyword">if</span>(!z||d[y]) <span class="keyword">continue</span>;</span><br><span class="line">           d[y] = d[x]+<span class="number">1</span>; q.push(y);</span><br><span class="line">           <span class="keyword">if</span>(y == t) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dinic</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> flow)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x == t) <span class="keyword">return</span> flow;</span><br><span class="line">    <span class="keyword">int</span> rest = flow, k;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = head[x]; i&amp;&amp;rest; i = edge[i].next)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> y = edge[i].to, z = edge[i].w;</span><br><span class="line">        <span class="keyword">if</span>(!z||d[y] != d[x]+<span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">        k = dinic(y, min(z, rest));</span><br><span class="line">        edge[i].w -= k; edge[i^<span class="number">1</span>].w += k; rest -= k;</span><br><span class="line">        <span class="keyword">if</span>(!k) d[y] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> flow-rest;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; , <span class="keyword">int</span>&gt; h;</span><br><span class="line"><span class="keyword">int</span> r, c, col[N], px[N], py[N], w[N]; </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">x%4 == 1&amp;&amp;y%2 == 1 = red  x%4 == 0&amp;&amp;y%2 == 0 = red </span></span><br><span class="line"><span class="comment">x%4 == 1&amp;&amp;y%2 == 0 = yellow  x%4 == 0&amp;&amp;y%2 == 1 = yellow</span></span><br><span class="line"><span class="comment">x%4 == 2&amp;&amp;y%2 == 1 = blue  x%4 == 3&amp;&amp;y%2 == 0 = blue</span></span><br><span class="line"><span class="comment">x%4 == 2&amp;&amp;y%2 == 0 = green  x%4 == 3&amp;&amp;y%2 == 1 = green</span></span><br><span class="line"><span class="comment">蓝线恰好在红块与蓝块之间</span></span><br><span class="line"><span class="comment">源点并联黄点 绿点并联汇点</span></span><br><span class="line"><span class="comment">黄点连红点 蓝点连绿点 红点连蓝点</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addpurple</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> _x = px[x], _y = py[x];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> nx = _x+dx[i], ny = _y;</span><br><span class="line">        <span class="keyword">if</span>(!h.count(<span class="built_in">make_pair</span>(nx, ny))) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">int</span> y = h[<span class="built_in">make_pair</span>(nx, ny)];</span><br><span class="line">        <span class="keyword">if</span>(col[y] == <span class="number">3</span>) add(x, y, min(w[x], w[y]));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addyellow</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> _x = px[x], _y = py[x];</span><br><span class="line">    add(s, x, w[x]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> nx = _x+dx[i], ny = _y+dy[i];</span><br><span class="line">        <span class="keyword">if</span>(!h.count(<span class="built_in">make_pair</span>(nx, ny))) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">int</span> y = h[<span class="built_in">make_pair</span>(nx, ny)];</span><br><span class="line">        <span class="keyword">if</span>(col[y] == <span class="number">1</span>) add(x, y, INF);   </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addgreen</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> _x = px[x], _y = py[x];</span><br><span class="line">    add(x, t, w[x]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> nx = _x+dx[i], ny = _y+dy[i];</span><br><span class="line">        <span class="keyword">if</span>(!h.count(<span class="built_in">make_pair</span>(nx, ny))) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">int</span> y = h[<span class="built_in">make_pair</span>(nx, ny)];</span><br><span class="line">        <span class="keyword">if</span>(col[y] == <span class="number">3</span>) add(y, x, INF);   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> maxflow, flow;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    c = read(), r = read(), n = read(); s = n+<span class="number">1</span>; t = n+<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        px[i] = read(), py[i] = read(), w[i] = read();</span><br><span class="line">        h[<span class="built_in">make_pair</span>(px[i], py[i])] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> x = px[i], y = py[i];</span><br><span class="line">        <span class="keyword">if</span>((x%<span class="number">4</span> == <span class="number">1</span>&amp;&amp;y%<span class="number">2</span> == <span class="number">1</span>)||(x%<span class="number">4</span> == <span class="number">0</span>&amp;&amp;y%<span class="number">2</span> == <span class="number">0</span>)) col[i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>((x%<span class="number">4</span> == <span class="number">1</span>&amp;&amp;y%<span class="number">2</span> == <span class="number">0</span>)||(x%<span class="number">4</span> == <span class="number">0</span>&amp;&amp;y%<span class="number">2</span> == <span class="number">1</span>)) col[i] = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>((x%<span class="number">4</span> == <span class="number">2</span>&amp;&amp;y%<span class="number">2</span> == <span class="number">1</span>)||(x%<span class="number">4</span> == <span class="number">3</span>&amp;&amp;y%<span class="number">2</span> == <span class="number">0</span>)) col[i] = <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">if</span>((x%<span class="number">4</span> == <span class="number">2</span>&amp;&amp;y%<span class="number">2</span> == <span class="number">0</span>)||(x%<span class="number">4</span> == <span class="number">3</span>&amp;&amp;y%<span class="number">2</span> == <span class="number">1</span>)) col[i] = <span class="number">4</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> x = <span class="number">1</span>; x &lt;= n; ++x)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(col[x] == <span class="number">1</span>) addpurple(x);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(col[x] == <span class="number">2</span>) addyellow(x);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(col[x] == <span class="number">4</span>) addgreen(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(bfs()) <span class="keyword">while</span>(flow = dinic(s, INF)) maxflow += flow;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, maxflow);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><em><a href="https://www.luogu.org/blog/ShadowassIIXVIIIIV/solution-p3756">图片来源</a></em></p>
<p><em>特别感谢 shadowice1984</em></p>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>网络流</tag>
      </tags>
  </entry>
  <entry>
    <title>一直学不会的莫比乌斯反演</title>
    <url>/2019/03/05/%E4%B8%80%E7%9B%B4%E5%AD%A6%E4%B8%8D%E4%BC%9A%E7%9A%84%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94/</url>
    <content><![CDATA[<center>
本文会出现大量口胡，请见谅
</center>
<h2 id="莫比乌斯函数">莫比乌斯函数</h2>
<p>设 <span class="math inline">\(x\in N\)</span> 唯一分解后为 <span class="math inline">\(x\ =\ p_1^{c_1}p_2^{c_2}p_3^{c_3}\cdots
p_n^{c_n}\)</span></p>
<p>我们定义莫比乌斯函数</p>
<p><span class="math display">\[ \mu(x)\ = \
\begin{cases}
0&amp;\exists\ c_i &gt; 1\\\\
-1&amp;n\ \equiv\ 1\ (\ mod\ 2\ )\\\\
1&amp;n\ \equiv\ 0\ (\mod\ 2\ )
\end{cases}
\]</span> <a id="more"></a> 通过观察定义，稍有常识的人 <del>除了我</del>
都能看出这是个积性函数，并且我们对莫比乌斯函数分析也通常是对唯一分解后的素数集合进行分析，这也是分析一般积性函数的一般方法</p>
<p>通过 <del>口胡</del> <del>打表</del> <strong>正经分析</strong>
得出对于莫比乌斯函数的积性函数的递推式</p>
<p><span class="math display">\[ \mu(np)\ = \
\begin{cases}
0&amp;\ n \perp p\\\\
-\mu(n)&amp;\ n \not\perp p
\end{cases}
\]</span></p>
<p>那么，欧拉筛莫比乌斯函数有如下操作</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sieve</span><span class="params">(<span class="keyword">int</span> d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    mo[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= d; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!vis[i]) p[++tp] = i, mo[i] = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= tp&amp;&amp;i*p[j] &gt; d; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            vis[i*p[j]] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(i%p[j] == <span class="number">0</span>) mo[i*p[j]] = <span class="number">0</span>, j += tp;	</span><br><span class="line">            <span class="keyword">else</span> mo[i*p[j]] = -mo[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="莫比乌斯反演">莫比乌斯反演</h2>
<p><del>蒟蒻一直学的是的假莫反</del></p>
<p>莫比乌斯反演通常表现为</p>
<p><span class="math display">\[
\begin{aligned}
&amp;g(x)\ =\ \sum_{d|x}f(d)\\\\
&amp;f(x)\ =\ \sum_{d|x}\mu(\frac{x}{d})g(d)
\end{aligned}
\]</span></p>
<p>或</p>
<p><span class="math display">\[
\begin{aligned}
&amp;g(x)\ =\ \sum_{x|d}^{n}f(d)\\\\
&amp;f(x)\ =\ \sum_{x|d}^{n}\mu(\frac{d}{x})g(d)
\end{aligned}
\]</span></p>
<p>可是蒟蒻都不会用</p>
<p>所以一直使用莫比乌斯函数，而是使用这一个性质</p>
<p><span class="math display">\[
\begin{aligned}
[\ x = 1\ ]\ =\ \sum_{d|x}\mu(d)
\end{aligned}
\]</span></p>
<p>下面给出这个性质的证明</p>
<p>我们考虑在只有枚举 <span class="math inline">\(d\)</span> 满足 <span class="math inline">\(d\ =\ p_1^{c_1}p_2^{c_2}p_3^{c_3}\cdots
p_n^{c_n},\ \forall c &lt; 2\)</span> 时才会对答案产生贡献</p>
<p>所以有</p>
<p><span class="math display">\[
\begin{aligned}
\sum_{d|x}\mu(d)\ =\ \sum_{i\ =\ 0}^n(-1)^{i+1}\tbinom{i}{n}
\end{aligned}
\]</span></p>
<p>则有</p>
<p><span class="math display">\[\sum_{d|x}\mu(d)\ =\
\begin{cases}
1&amp;n\ =\ 1\\\\
0&amp;n\ \neq\ 1\\
\end{cases}
=\ [x\ =\ 1]
\]</span></p>
<h2 id="例题">例题</h2>
<p><em>例题中的 n 均小于 m，p是质数集合任意一个元素</em></p>
<h3 id="暂无裸题"><a href>暂无裸题</a></h3>
<p><span class="math display">\[
\begin{aligned}
\sum_{i=1}^n\sum_{j=1}^m[gcd(i,\ j)\ =\ 1]
\end{aligned}
\]</span></p>
<details>
<summary>
<mark><font color="darkred"></font></mark>
</summary>
<p>根据性质</p>
<p><span class="math inline">\(\sum_{i=1}^n\sum_{j=1}^m[gcd(i,\ j)\ =\
1] \ =\ \sum_{i=1}^n\sum_{j=1}^m\sum_{d|gcd(i,\ j)}\mu(d)\)</span></p>
<p>把 <span class="math inline">\(d|gcd(i,\ j)\)</span> 拆开</p>
<p><span class="math inline">\(\sum_{i=1}^n\sum_{j=1}^m\sum_{d|gcd(i,\
j)} =\ \sum_{i=1}^n\sum_{j=1}^m\sum_{d|i,\ d|j}\mu(d)\)</span></p>
<p>更改枚举形式，把条件写在和式右端，并根据条件扩大枚举范围</p>
<p><span class="math inline">\(\sum_{i=1}^n\sum_{j=1}^m\sum_{d|i,\
d|j}\mu(d)\ =\
\sum_{i=1}^n\sum_{j=1}^m\sum_{d=1}^n\mu(d)[d|i][d|j]\)</span></p>
<p>交换和式</p>
<p><span class="math inline">\(\sum_{i=1}^n\sum_{j=1}^m\sum_{d=1}^n\mu(d)[d|i][d|j]\
=\ \sum_{d=1}^n\mu(d)\sum_{i=1}^n[d|i]\sum_{j=1}^m[d|j]\)</span></p>
<p>发现实际上为枚举约数个数</p>
<p><span class="math inline">\(\sum_{d=1}^n\mu(d)\sum_{i=1}^n[d|i]\sum_{j=1}^m[d|j]\
=\ \sum_{d=1}^n\mu(d)\lfloor \frac{n}{d}\rfloor \lfloor
\frac{m}{d}\rfloor\)</span></p>
</details>
<hr>
<h3 id="p2522-haoi2011problem-b"><a href="https://www.luogu.org/problemnew/show/P2522">P2522
[HAOI2011]Problem b</a></h3>
<span class="math display">\[
\begin{aligned}
\sum_{i=1}^n\sum_{j=1}^m[gcd(i,\ j)\ =\ k]
\end{aligned}
\]</span>
<details>
<summary>
<mark><font color="darkred"></font></mark>
</summary>
<p>我们把所有满足条件的 <span class="math inline">\(gcd(i,\ j)\)</span>
剔除约数 <span class="math inline">\(k\)</span> 实际上相当于求</p>
<p><span class="math display">\[
\begin{aligned}
\sum_{i=1}^{\lfloor \frac{n}{k}\rfloor}\sum_{j=1}^{\lfloor
\frac{m}{k}\rfloor}[gcd(i,\ j)\ =\ 1]
\end{aligned}
\]</span></p>
所以 <span class="math display">\[
\begin{aligned}
\sum_{i=1}^{\lfloor \frac{n}{k}\rfloor}\sum_{j=1}^{\lfloor
\frac{m}{k}\rfloor}[gcd(i,\ j)\ =\ 1] =\ \sum_{d=1}^{\lfloor
\frac{n}{k}\rfloor}\mu(d)\lfloor \frac{n}{kd}\rfloor \lfloor
\frac{m}{kd}\rfloor
\end{aligned}
\]</span>
</details>
<hr>
<h3 id="暂无裸题-1"><a href>暂无裸题</a></h3>
<span class="math display">\[
\begin{aligned}
\sum_{i=1}^n\sum_{j=1}^mij[gcd(i,\ j)\ =\ k]
\end{aligned}
\]</span>
<details>
<summary>
<mark><font color="darkred"></font></mark>
</summary>
<p>与上题一样，我们把所有满足条件的 <span class="math inline">\(gcd(i,\
j)\)</span> 剔除约数 <span class="math inline">\(k\)</span>
实际上相当于求</p>
<p><span class="math display">\[
\begin{aligned}
\sum_{i=1}^{\lfloor \frac{n}{k}\rfloor}\sum_{j=1}^{\lfloor
\frac{m}{k}\rfloor}ij[gcd(i,\ j)\ =\ 1]\ k^2
\end{aligned}
\]</span></p>
<p>注意此时虽然我们把所有数剔除 <span class="math inline">\(k\)</span>
后，依然需要累加贡献</p>
<p><span class="math display">\[
\begin{aligned}
\sum_{i=1}^{\lfloor \frac{n}{k}\rfloor}\sum_{j=1}^{\lfloor
\frac{m}{k}\rfloor}ij[gcd(i,\ j)\ =\ 1]\ k^2\ &amp;=\
k^2\sum_{d=1}^{\lfloor \frac{n}{k}\rfloor}\mu(d)\sum_{i=1}^{\lfloor
\frac{n}{k}\rfloor}\sum_{j=1}^{\lfloor \frac{m}{k}\rfloor}ij[d|i][d|j]
\end{aligned}
\]</span></p>
<p>观察后面的和式，把 <span class="math inline">\(d\)</span>
提出即变成等差数列</p>
<span class="math display">\[
\begin{aligned}
k^2\sum_{d=1}^{\lfloor \frac{n}{k}\rfloor}\mu(d)*d^2\sum_{i=1}^{\lfloor
\frac{n}{kd}\rfloor}i\sum_{j=1}^{\lfloor \frac{m}{kd}\rfloor}j
\end{aligned}
\]</span>
</details>
<hr>
<h3 id="p1447-noi2010能量采集"><a href="https://www.luogu.org/problemnew/show/P1447">P1447
[NOI2010]能量采集</a></h3>
<span class="math display">\[
\begin{aligned}
\sum_{i=1}^n\sum_{j=1}^mgcd(i,\ j)
\end{aligned}
\]</span>
<details>
<summary>
<mark><font color="darkred"></font></mark>
</summary>
<p>这道题虽然可以根据欧拉函数性质直接得出</p>
<p><span class="math display">\[
\begin{aligned}
x \ =\ \sum_{d|x}\phi(d)
\end{aligned}
\]</span></p>
<p>从而</p>
<p><span class="math display">\[
\begin{aligned}
\sum_{i=1}^n\sum_{j=1}^mgcd(i,\ j)\ =\ \sum_{d=1}^n\phi(d)\lfloor
\frac{n}{d}\rfloor \lfloor \frac{m}{d}\rfloor
\end{aligned}
\]</span></p>
<p>但用莫比乌斯函数推导会更有意义一些</p>
<p>我们枚举 <span class="math inline">\(gcd(i,\ j)\)</span> 得到</p>
<p><span class="math inline">\(\sum_{d=1}^nd\sum_{i=1}^n\sum_{j=1}^m[gcd(i,\ j)\
=\ d]\)</span></p>
<p>后面根据前文，化简为</p>
<p><span class="math inline">\(\sum_{d=1}^nd\sum_{k=1}^{\lfloor
\frac{n}{d} \rfloor}\mu(k)\lfloor \frac{n}{kd} \rfloor \lfloor
\frac{m}{kd} \rfloor\)</span></p>
<p>设 <span class="math inline">\(T = kd\)</span> 则有</p>
<p><span class="math inline">\(\sum_{d=1}^nd\sum_{k=1}^{\lfloor
\frac{n}{d} \rfloor}\mu(k)\lfloor \frac{n}{T} \rfloor \lfloor
\frac{m}{T} \rfloor\ =\ \sum_{d=1}^nd\sum_{T=1}^n\mu(\frac{T}{d})\lfloor
\frac{n}{T} \rfloor \lfloor \frac{m}{T}\rfloor[d|T]\ =\
\sum_{T=1}^n\lfloor \frac{n}{T} \rfloor \lfloor
\frac{m}{T}\rfloor\sum_{d|T}\mu(\frac{T}{d})d\)</span></p>
<p>设 <span class="math inline">\(F(n)\ =\
\sum_{d|n}\mu(\frac{n}{d})d\)</span> ，并考虑在欧拉筛过程中求出</p>
<p>下面是一个很重要的技巧，考虑加入 <span class="math inline">\(p\)</span> 对于原来的约数集合的影响则有</p>
<p><span class="math inline">\(F(np)\ =\
\sum_{d|n}\mu(\frac{np}{d})d+\sum_{d|n}\mu(\frac{np}{dp})dp\)</span></p>
<p>当 <span class="math inline">\(n\ \perp\ p\)</span> 时，<span class="math inline">\(\sum_{d|n}\mu(\frac{np}{d})d+\sum_{d|n}\mu(\frac{np}{dp})dp\
=\ -F(n)+pF(n)\)</span></p>
<p>当 <span class="math inline">\(n\ \not\perp\ p\)</span> 时，<span class="math inline">\(\sum_{d|n}\mu(\frac{np}{d})d+\sum_{d|n}\mu(\frac{np}{dp})dp\
=\ pF(n)\)</span></p>
<p>综上，</p>
<p><span class="math display">\[ F(np)\ = \
\begin{cases}
(p-1)F(n)&amp;\ n \perp p\\\\
pF(n)&amp;\ n \not\perp p\\
\end{cases}
\]</span></p>
<p>我们发现这恰好是 <span class="math inline">\(\phi(n)\)</span>
的递推式，因此是正确的</p>
这样推式子是一种套路，请仔细思考
</details>
<hr>
<h3 id="p2257-yy的gcd"><a href="https://www.luogu.org/problemnew/show/P2257">P2257
YY的GCD</a></h3>
<p><span class="math display">\[
\begin{aligned}
\sum_{i=1}^n\sum_{j=1}^m[\ gcd(i,\ j)\ =\ p\ ]
\end{aligned}
\]</span></p>
<details>
<summary>
<mark><font color="darkred"></font></mark>
</summary>
<p>我们设有函数 <span class="math inline">\(f(n)\ =\ [n\ =\
p]\)</span></p>
<p>则题意变为</p>
<p><span class="math display">\[
\begin{aligned}
\sum_{i=1}^n\sum_{j=1}^mf(gcd(i,\ j))
\end{aligned}
\]</span></p>
<p>我们枚举 <span class="math inline">\(gcd(i,\ j)\)</span> 得到</p>
<p><span class="math inline">\(\sum_{d=1}^nf(d)\sum_{i=1}^n\sum_{j=1}^m[gcd(i,\
j)\ =\ d]\)</span></p>
<p>后面根据前文，化简为</p>
<p><span class="math inline">\(\sum_{d=1}^nf(d)\sum_{k=1}^{\lfloor
\frac{n}{d} \rfloor}\mu(k)\lfloor \frac{n}{kd} \rfloor \lfloor
\frac{m}{kd} \rfloor\)</span></p>
<p>设 <span class="math inline">\(T = kd\)</span> 则有</p>
<p><span class="math inline">\(\sum_{d=1}^nf(d)\sum_{k=1}^{\lfloor
\frac{n}{d} \rfloor}\mu(k)\lfloor \frac{n}{T} \rfloor \lfloor
\frac{m}{T} \rfloor =\sum_{d=1}^nf(d)\sum_{T=1}^n\mu(\frac{T}{d})\lfloor
\frac{n}{T} \rfloor \lfloor \frac{m}{T}\rfloor[d|T] =\sum_{T=1}^n\lfloor
\frac{n}{T} \rfloor \lfloor
\frac{m}{T}\rfloor\sum_{d|T}\mu(\frac{T}{d})f(d)\)</span></p>
<p>设 <span class="math inline">\(F(n)\ =\
\sum_{d|n}\mu(\frac{n}{d})f(d)\)</span> ，并考虑在欧拉筛过程中求出</p>
<p>考虑加入 <span class="math inline">\(p\)</span>
对于原来的约数集合的影响则有</p>
<p><span class="math inline">\(F(np)\ =\
\sum_{d|n}\mu(\frac{np}{d})f(d)+\sum_{d|n}\mu(\frac{np}{dp})f(dp)\)</span></p>
<p>当 <span class="math inline">\(n\ \perp\ p\)</span> 时，<span class="math inline">\(\sum_{d|n}\mu(\frac{np}{d})f(d)+\sum_{d|n}\mu(\frac{np}{dp})f(dp)\
=\ -F(n)+\mu(n)\)</span></p>
<p>当 <span class="math inline">\(n\ \not\perp\ p\)</span> 时，<span class="math inline">\(\sum_{d|n}\mu(\frac{np}{d})f(d)+\sum_{d|n}\mu(\frac{np}{dp})f(dp)\
=\ \mu(n)\)</span></p>
<p>综上，</p>
<p><span class="math display">\[ F(np)\ = \
\begin{cases}
-F(n)+\mu(n)&amp;\ n \perp p\\\\
\mu(n)&amp;\ n \not\perp p\\
\end{cases}
\]</span></p>
<p>我们发现这道和上一道有许多复读的部分，总结一下发现如果有一道题可以表示为</p>
<p><span class="math display">\[
\begin{aligned}
\sum_{i=1}^n\sum_{j=1}^mf(gcd(i,\ j))
\end{aligned}
\]</span></p>
<p>实际上就是求出</p>
<p><span class="math display">\[
\begin{aligned}
\sum_{T=1}^n\lfloor \frac{n}{T} \rfloor \lfloor
\frac{m}{T}\rfloor\sum_{d|T}\mu(\frac{T}{d})f(d)
\end{aligned}
\]</span></p>
并且按照上面的技巧讨论即可
</details>
<hr>
<h3 id="数据删除"><a href>数据删除</a></h3>
<h2 id="数据删除-1">[数据删除]</h2>
]]></content>
      <categories>
        <category>模板</category>
      </categories>
      <tags>
        <tag>莫比乌斯反演</tag>
      </tags>
  </entry>
  <entry>
    <title>40309102 省选模拟题</title>
    <url>/2019/03/04/40309102-%E7%9C%81%E9%80%89%E6%A8%A1%E6%8B%9F%E9%A2%98/</url>
    <content><![CDATA[<h2 id="loj6038-雅礼集训-2017-day5远行"><a href="https://loj.ac/problem/6038">LOJ6038 [雅礼集训 2017
Day5]远行</a></h2>
<blockquote>
<p>动态维护指定节点为端点的树上最长链</p>
</blockquote>
<p>树的直径的性质</p>
<ul>
<li>树上任意节点为一段的最长链必定是直径的一个端点</li>
<li>若存在树多个直径则一定相交</li>
<li>两个联通块合并时，新的树的直径的端点必定来自于原四个端点的其中两个
<a id="more"></a> 那么问题即转化为动态维护树的直径</li>
</ul>
<p>树的联通块及直径信息用并查集维护，树的联通性和简单路径用LCT维护</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">300000</span>+<span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> f = <span class="number">1</span>, x = <span class="number">0</span>; <span class="keyword">char</span> ch;</span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">isdigit</span>(ch = getchar())) <span class="keyword">if</span>(ch == <span class="string">&#x27;-&#x27;</span>) f = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch)) &#123; x = x*<span class="number">10</span>+ch-<span class="string">&#x27;0&#x27;</span>; ch = getchar(); &#125;</span><br><span class="line">    <span class="keyword">return</span> f*x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, q, type;</span><br><span class="line"><span class="keyword">int</span> ch[N][<span class="number">2</span>], fa[N], f[N];</span><br><span class="line"><span class="keyword">int</span> val[N], rev[N];</span><br><span class="line"><span class="keyword">int</span> d1[N], d2[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushup</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="keyword">if</span>(x) val[x] = val[ch[x][<span class="number">0</span>]]+val[ch[x][<span class="number">1</span>]]+<span class="number">1</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">nroot</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="keyword">return</span> ch[fa[x]][<span class="number">0</span>] == x || ch[fa[x]][<span class="number">1</span>] == x; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushr</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="keyword">if</span>(x) swap(ch[x][<span class="number">0</span>], ch[x][<span class="number">1</span>]), rev[x] ^= <span class="number">1</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushdown</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="keyword">if</span>(rev[x]) pushr(ch[x][<span class="number">0</span>]), pushr(ch[x][<span class="number">1</span>]), rev[x] = <span class="number">0</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> y = fa[x], z = fa[y], k = ch[y][<span class="number">1</span>]==x, w = ch[x][!k];</span><br><span class="line">    ch[x][!k] = y; ch[y][k] = w; <span class="keyword">if</span>(nroot(y)) ch[z][ch[z][<span class="number">1</span>]==y] = x; </span><br><span class="line">    fa[x] = z; fa[y] = x; <span class="keyword">if</span>(w) fa[w] = y;</span><br><span class="line">    pushup(y); pushup(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushshall</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(nroot(x)&amp;&amp;x) pushshall(fa[x]);</span><br><span class="line">    pushdown(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">splay</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    pushshall(x);</span><br><span class="line">    <span class="keyword">while</span>(nroot(x))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> y = fa[x], z = fa[y];</span><br><span class="line">        <span class="keyword">if</span>(nroot(y)) (ch[y][<span class="number">1</span>]==x)^(ch[z][<span class="number">1</span>]==y)?rotate(x):rotate(y);</span><br><span class="line">        rotate(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">access</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> y = <span class="number">0</span>; x; x = fa[y=x])</span><br><span class="line">        splay(x), ch[x][<span class="number">1</span>] = y, pushup(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">makeroot</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; access(x); splay(x); pushr(x); &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">split</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123; makeroot(x); access(y); splay(y); &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123; split(x, y); <span class="keyword">return</span> val[y]; &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="keyword">return</span> f[x] == x?x:f[x] = find(f[x]); &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">link</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    makeroot(x); fa[x] = y;</span><br><span class="line">    <span class="keyword">int</span> fx = find(x), fy = find(y); f[fx] = fy; </span><br><span class="line">    <span class="keyword">int</span> x1 = d1[fx], y1 = d2[fx], x2 = d1[fy], y2 = d2[fy];</span><br><span class="line">    <span class="keyword">int</span> v = query(x2, y2), t = <span class="number">0</span>;</span><br><span class="line">    t = query(x1, y1); <span class="keyword">if</span>(t &gt; v) v = t, d1[fy] = x1, d2[fy] = y1;</span><br><span class="line">    t = query(x1, y2); <span class="keyword">if</span>(t &gt; v) v = t, d1[fy] = x1, d2[fy] = y2;</span><br><span class="line">    t = query(x2, y1); <span class="keyword">if</span>(t &gt; v) v = t, d1[fy] = x2, d2[fy] = y1;</span><br><span class="line">    t = query(x1, x2); <span class="keyword">if</span>(t &gt; v) v = t, d1[fy] = x1, d2[fy] = x2;</span><br><span class="line">    t = query(y1, y2); <span class="keyword">if</span>(t &gt; v) v = t, d1[fy] = y1, d2[fy] = y2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// freopen(&quot;hike.in&quot;, &quot;r&quot;, stdin);</span></span><br><span class="line">    <span class="comment">// freopen(&quot;hike.out&quot;, &quot;w&quot;, stdout);  </span></span><br><span class="line">    type = read();</span><br><span class="line">    n = read(), q = read();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> x = <span class="number">1</span>; x &lt;= n; ++x) val[x] = <span class="number">1</span>, d1[x] = d2[x] = f[x] = x;</span><br><span class="line">    <span class="keyword">while</span>(q--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> op = read(), x = read()^ans, y;</span><br><span class="line">        <span class="keyword">if</span>(op == <span class="number">1</span>) y = read()^ans, link(x, y);</span><br><span class="line">        <span class="keyword">else</span> y = find(x), <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans = max(query(d1[y], x), query(d2[y], x))<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">if</span>(!type) ans = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>动态树</tag>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title>再也学不会的置换与群</title>
    <url>/2019/03/03/%E5%86%8D%E4%B9%9F%E5%AD%A6%E4%B8%8D%E4%BC%9A%E7%9A%84%E7%BD%AE%E6%8D%A2%E4%B8%8E%E7%BE%A4/</url>
    <content><![CDATA[<p><del>这就是BZOJ挨个做题的下场吗</del></p>
<h2 id="群的定义">群的定义</h2>
<p>对于二元组 <span class="math inline">\((G,\ \circ )\)</span> 其中
<span class="math inline">\(G\)</span> 是一个集合，$$
是一个二元运算，若满足以下性质，则称 <span class="math inline">\(G\)</span> 是 $$ 下的群 <a id="more"></a> * 封闭性:
<span class="math inline">\(\forall \ a,\ b \in G, \ a\circ b \in
G\)</span> * 交换律: <span class="math inline">\(\forall \ a,\ b,\ c \in
G,\ a\circ b\circ c\ =\ a\circ (b\circ c)\)</span> * 单位元: <span class="math inline">\(\exists \ e\ \in G,\ \forall\ a\ \in G,\ a\circ e\
=\ a\)</span> * 逆元: <span class="math inline">\(\forall \ a\ \in G,\
\exists\ a^{-1}\ \in\ G,\ a\circ a^{-1} = e\)</span></p>
<p>比如，复数集合 <span class="math inline">\(C\)</span> 是二元运算
<span class="math inline">\(+\)</span> 的群，即加法群</p>
<h2 id="置换群">置换群</h2>
<p>定义 <span class="math inline">\(G\)</span> 为 <span class="math inline">\(S = \{ 1,\ 2,\ 3,\ 4,\ ...\ ,\ n \}\)</span>
上双射构成的集合，并定义二元运算 <span class="math inline">\(\circ\)</span> 满足 <span class="math inline">\((f\ \circ\ g)[x] = f(g(x))\)</span>，若保证运算
<span class="math inline">\(\circ\)</span> 对于 <span class="math inline">\(S\)</span> 封闭，则称 <span class="math inline">\(G\)</span> 是运算 <span class="math inline">\(\circ\)</span>
的置换群，且这种双射称为置换，通常以这种形式表示 <span class="math display">\[\begin{bmatrix}
1&amp;2&amp;3&amp;{\cdots}&amp;n\\\\
{a_1}&amp;{a_2}&amp;{a_3}&amp;{\cdots}&amp;{a_n}\\
\end{bmatrix}\]</span></p>
<p>其中置换</p>
<p><span class="math display">\[\begin{bmatrix}
1&amp;2&amp;3&amp;{\cdots}&amp;n\\\\
{1}&amp;{2}&amp;{3}&amp;{\cdots}&amp;{n}\\
\end{bmatrix}\]</span></p>
<p>为 <span class="math inline">\(G\)</span> 的单位元</p>
<p>其中</p>
<p><span class="math display">\[\begin{bmatrix}
{a_1}&amp;{a_2}&amp;{a_3}&amp;{\cdots}&amp;{a_n}\\\\
1&amp;2&amp;3&amp;{\cdots}&amp;n\\
\end{bmatrix}\]</span></p>
<p>为 <span class="math inline">\(G\)</span> 的逆元</p>
<p>同时，我们定义：</p>
<p><span class="math inline">\(E_i\)</span> 表示元素 <span class="math inline">\(i\)</span> 经过 <span class="math inline">\(G\)</span>
的诱导下可以得到的元素集合，即等价类</p>
<p><del>就是置换形成的有向图的环·</del></p>
<p><span class="math inline">\(Z_i\)</span> 表示使元素 <span class="math inline">\(i\)</span> 为不动点的置换的全体所构成的集合</p>
<h2 id="burnside-引理">Burnside 引理</h2>
<p>设 <span class="math inline">\(G\)</span> 是作用在 <span class="math inline">\(S = \{1,\ 2,\ 3,\ \cdots,\ n\}\)</span>
的置换群，则对于等价类 <span class="math inline">\(E\)</span> 的个数
<span class="math inline">\(l\)</span> 有</p>
<p><span class="math display">\[l\ =\ \frac{1}{|G|}\sum_{g\ \in\
G}D(g)\]</span></p>
<p>其中 <span class="math inline">\(D(x)\)</span> 表示置换 <span class="math inline">\(x\)</span> 中的不动点的数量</p>
<h2 id="证明">### 证明</h2>
<p><strong>引理</strong></p>
<p><span class="math display">\[\sum_{i=1}^n|Z_i| = \sum_{g\ \in\
G}D(g)\]</span></p>
<details>
<summary>
<mark><font color="darkred"></font></mark>
</summary>
<p><del>自己口胡一遍就行了</del></p>
<p><span class="math inline">\(\sum_{i=1}^n|Z_i|\ =\
\sum_{i=1}^n\sum_{g\ \in \ G}[i == a_i][a_i\ \in g]\ =\ \sum_{g\ \in \
G}\sum_{i=1}^n[i == a_i][a_i\ \in g]\ =\ \sum_{g\ \in \
G}D(g)\)</span></p>
</details>
<hr>
<p><strong>引理</strong></p>
<p><span class="math display">\[\forall\ k\ \in\ S,\ |E_k||Z_k|\ =\
|G|\]</span></p>
<details>
<summary>
<mark><font color="darkred"></font></mark>
</summary>
<p>设 <span class="math inline">\(E_k\ =\ \{a_1,\ a_2,\ a_3,\ \cdots,\
a_{|E_k|} \},\ a_1\ =\ k\)</span></p>
<p>由 <span class="math inline">\(E_k\)</span> 的定义知，<span class="math inline">\(\exists\ p_i\ \in\ G,\ p_i(a_1)\ =\
a_i\)</span></p>
<p>于是构造 <span class="math inline">\(Z_kp_i\ =\ \{\pi\circ p_i\ |\
\pi \in\ Z_k\}\)</span></p>
<p>对于 <span class="math inline">\(Z_kp_i\)</span> 具有以下性质</p>
<p><span class="math display">\[|Z_kp_i|\ =\ |Z_k|\]</span></p>
<p><span class="math inline">\(\because \pi_1\circ p_i\ =\ \pi_2\circ
p_i \rightarrow\ \pi_1\ =\ \pi_2\ \therefore\ \pi_1\ \ne\ \pi_2\
\rightarrow \pi_1\circ p_i\ \ne\ \pi_2\circ p_i\)</span></p>
<p><del>结合下一条性质感性理解</del></p>
<p><span class="math display">\[Z_kp_i\ \cap\ Z_kp_j = \varnothing\ (i\
\ne\ j)\]</span></p>
<p><span class="math inline">\(\because\ Z_kp_i(a_1)\ =\ a_i,\
Z_kp_j(a_1)\ =\ a_j\ \therefore\ p_i(a_1)\ \ne\ p_j(a_1)\)</span></p>
<p><span class="math display">\[G\ =\ Z_kp_1\ \cup\ Z_kp_2\ \cup\
Z_kp_3\ \cup\ \cdots\ \cup\ Z_kp_{|E_k|}\]</span> 首先，显然</p>
<p><span class="math inline">\(Z_kp_1\ \cup\ Z_kp_2\ \cup\ Z_kp_3\ \cup\
\cdots\ \cup\ Z_kp_{|E_k|}\ \subseteq G\)</span></p>
<p><span class="math inline">\(\forall\ p\ \in\ G,\ p(a_1) = a =
k\rightarrow a\ \in \ E_k\)</span>，设 <span class="math inline">\(a =
a_j\)</span></p>
<p><span class="math inline">\(\because\ p\circ p_j^{-1}(a_1)\ =\
p_j^{-1}\circ p(a_1)\ =\ a_1\)</span></p>
<p><span class="math inline">\(\therefore\ p\circ p_j^{-1}\ \in\ Z_k,\
p\ \in\ Z_kp_j\)</span></p>
<p><span class="math inline">\(\ \ \ \ G\ \subseteq\ Z_kp_1\ \cup\
Z_kp_2\ \cup\ Z_kp_3\ \cup\ \cdots\ \cup\ Z_kp_{|E_k|}\)</span></p>
<p><span class="math inline">\(\therefore\ G\ =\ Z_kp_1\ \cup\ Z_kp_2\
\cup\ Z_kp_3\ \cup\ \cdots\ \cup\ Z_kp_{|E_k|}\)</span></p>
<p>综合各项性质</p>
<p><span class="math inline">\(|G|\ = \sum_{i=1}^{|E_k|}|Z_kp_i|\ =
\sum_{i=1}^{E_k}|Z_k|\ = |E_k||Z_k|\)</span></p>
</details>
<hr>
<p><strong>综上</strong></p>
<p><span class="math inline">\(\frac{1}{|G|}\sum_{g\ \in\ G}D(g)\ =
\frac{1}{|G|}\sum_{i=1}^{n}|Z_i| \ = \frac{1}{|G|}\sum_{i=1}^l\sum_{j\
\in\ E_i}|Z_j| \ = \frac{1}{|G|}\sum_{i=1}^l|G|\ = l\)</span></p>
<h3 id="例题">例题</h3>
<blockquote>
<p>一正方形分成4格，2着色，求方案，其中，经过转动相同的图象算同一方案</p>
</blockquote>
<figure>
<img src="/2019/03/03/%E5%86%8D%E4%B9%9F%E5%AD%A6%E4%B8%8D%E4%BC%9A%E7%9A%84%E7%BD%AE%E6%8D%A2%E4%B8%8E%E7%BE%A4/Burnside_1.jpg" alt="题目图片">
<figcaption aria-hidden="true">题目图片</figcaption>
</figure>
<p>设 <span class="math inline">\(G\ =\ \{a_1,\ a_2,\ a_3,\
a_4\}\)</span> 分别代表顺时针 <span class="math inline">\(0^{\circ}\)</span> ，<span class="math inline">\(90^{\circ}\)</span> ，<span class="math inline">\(180^{\circ}\)</span> ，<span class="math inline">\(270^{\circ}\)</span></p>
<p>由题意得</p>
<p><span class="math display">\[a_1\ = \begin{bmatrix}
1&amp;2&amp;3&amp;4&amp;5&amp;6&amp;7&amp;8&amp;9&amp;10&amp;11&amp;12&amp;13&amp;14&amp;15&amp;16\\\\
1&amp;2&amp;3&amp;4&amp;5&amp;6&amp;7&amp;8&amp;9&amp;10&amp;11&amp;12&amp;13&amp;14&amp;15&amp;16\\
\end{bmatrix}\]</span></p>
<p><span class="math display">\[a_2\ = \begin{bmatrix}
1&amp;2&amp;3&amp;4&amp;5&amp;6&amp;7&amp;8&amp;9&amp;10&amp;11&amp;12&amp;13&amp;14&amp;15&amp;16\\\\
1&amp;2&amp;6&amp;3&amp;4&amp;5&amp;10&amp;7&amp;8&amp;9&amp;12&amp;11&amp;16&amp;13&amp;14&amp;15\\
\end{bmatrix}\]</span></p>
<p><span class="math display">\[a_3\ = \begin{bmatrix}
1&amp;2&amp;3&amp;4&amp;5&amp;6&amp;7&amp;8&amp;9&amp;10&amp;11&amp;12&amp;13&amp;14&amp;15&amp;16\\\\
1&amp;2&amp;5&amp;6&amp;3&amp;4&amp;9&amp;10&amp;7&amp;8&amp;11&amp;12&amp;15&amp;16&amp;13&amp;14\\
\end{bmatrix}\]</span></p>
<p><span class="math display">\[a_4\ = \begin{bmatrix}
1&amp;2&amp;3&amp;4&amp;5&amp;6&amp;7&amp;8&amp;9&amp;10&amp;11&amp;12&amp;13&amp;14&amp;15&amp;16\\\\
1&amp;2&amp;4&amp;5&amp;6&amp;3&amp;8&amp;9&amp;10&amp;7&amp;12&amp;11&amp;14&amp;15&amp;16&amp;13\\
\end{bmatrix}\]</span></p>
<p>由Burnside引理得</p>
<p><span class="math display">\[l\ =\ \frac{1}{4}\times (16+2+4+2)\ =\
6\]</span></p>
<h2 id="polya-定理">Polya 定理</h2>
<p>我们考虑染色问题，<span class="math inline">\(S\)</span>
大小是指数级的，无法枚举，所以产生了Polya定理</p>
<p>引入循环的概念</p>
<p>约定一个记号</p>
<p><span class="math display">\[(a_1\ a_2\ a_3\ \cdots\ a_n)\ =\
\begin{bmatrix}
{a_1}&amp;{a_2}&amp;{a_3}&amp;{\cdots}&amp;{a_n}\\\\
{a_2}&amp;{a_3}&amp;{a_4}&amp;{\cdots}&amp;{a_1}\\
\end{bmatrix}\]</span></p>
<p>循环可以理解为压缩表示的置换，对于循环内的数没有先后之分</p>
<p>一个十分显然的结论，一个置换可以表示成若干个不相交循环的组合</p>
<p>例如</p>
<p><span class="math display">\[(a_1\ a_2\ a_3)(a_4\ a_5)\ =\
\begin{bmatrix}
{a_1}&amp;{a_2}&amp;{a_3}&amp;{a_4}&amp;{a_5}\\\\
{a_2}&amp;{a_3}&amp;{a_1}&amp;{a_5}&amp;{a_4}\\
\end{bmatrix}\]</span></p>
<p>设 <span class="math inline">\(G\)</span> 是作用在 <span class="math inline">\(S = \{1,\ 2,\ 3,\ \cdots,\ n\}\)</span>
的置换群，我们需要对 <span class="math inline">\(n\)</span> 染 <span class="math inline">\(m\)</span> 种颜色，则对于等价类 <span class="math inline">\(E\)</span> 的个数 <span class="math inline">\(l\)</span> 有</p>
<p><span class="math display">\[l\ =\ \frac{1}{|G|}\sum_{g\ \in\
G}m^{C(g)}\]</span></p>
<p>其中 <span class="math inline">\(C(x)\)</span> 表示置换 <span class="math inline">\(x\)</span> 中的不相交循环的数量</p>
<h3 id="证明-1">证明</h3>
<p>对于每个循环都对应的是该置换的不动点，我们只要把循环内的数染成相同颜色即可，即
<span class="math inline">\(m^{C(g)}\)</span> 个</p>
<h3 id="人类本质"><del>人类本质</del></h3>
<blockquote>
<p>一正方形分成4格，2着色，求方案，其中，经过转动相同的图象算同一方案</p>
</blockquote>
<figure>
<img src="/2019/03/03/%E5%86%8D%E4%B9%9F%E5%AD%A6%E4%B8%8D%E4%BC%9A%E7%9A%84%E7%BD%AE%E6%8D%A2%E4%B8%8E%E7%BE%A4/Polya_1.png" alt="题目图片">
<figcaption aria-hidden="true">题目图片</figcaption>
</figure>
<p>设 <span class="math inline">\(G\ =\ \{a_1,\ a_2,\ a_3,\
a_4\}\)</span> 分别代表顺时针 <span class="math inline">\(0^{\circ}\)</span> ，<span class="math inline">\(90^{\circ}\)</span> ，<span class="math inline">\(180^{\circ}\)</span> ，<span class="math inline">\(270^{\circ}\)</span></p>
<p>由题意得</p>
<p><span class="math display">\[a_1\ =\ (1)(2)(3)(4)\]</span></p>
<p><span class="math display">\[a_2\ =\ (1\ \ \ 2\ \ \ 3\ \ \
4)\]</span></p>
<p><span class="math display">\[a_3\ =\ (1\ \ \ 3)(2\ \ \
4)\]</span></p>
<p><span class="math display">\[a_4\ =\ (1\ \ \ 2\ \ \ 3\ \ \
4)\]</span></p>
<p>由Polya定理得</p>
<p><span class="math display">\[l\ =\ \frac{1}{4}\times
(2^4+2^1+2^2+2^1)\ =\ 6\]</span></p>
<h2 id="p4980-模板polya定理"><a href="https://www.luogu.org/problemnew/show/P4980">P4980
【模板】Polya定理</a></h2>
<p><del>群论真是人类的智慧</del></p>
]]></content>
      <categories>
        <category>模板</category>
      </categories>
      <tags>
        <tag>群论</tag>
      </tags>
  </entry>
  <entry>
    <title>后缀数组十三题</title>
    <url>/2019/02/21/%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84%E5%8D%81%E4%B8%89%E9%A2%98/</url>
    <content><![CDATA[<center>
由于蒟蒻的分组导致多个字符串有个可能需要特判只有1个情况
</center>
<center>
本文也会出现大量口胡，请见谅
</center>
<p>蒟蒻的字符串太差了(ಥ _ ಥ)</p>
<p>蒟蒻这辈子再也学不会了≡(▔﹏▔)≡</p>
<h2 id="p2743-usaco5.1乐曲主题musical-themes"><a href="https://www.luogu.org/problemnew/show/P2743">P2743
[USACO5.1]乐曲主题Musical Themes</a></h2>
<h3 id="题面描述">题面描述</h3>
<p><strong>求不重叠的最长重复子串</strong>，其中两个字符串相等的条件变为相同位置两字符差值一定</p>
<h3 id="题解">题解</h3>
<p>首先，我们需要解决被重新定义的匹配的问题，相同位置字符差值一定，那么同一个字符串相邻差值与另一个位置的差值相等
<a id="more"></a> 例如： <span class="math display">\[1\quad 2\quad 3\quad 5
\\\\ 3\quad 4\quad 5\quad 2\]</span> 两个字符串转成差分后变为</p>
<p><span class="math display">\[1\quad 1\quad\ 2 \\\\ 1\quad 1\quad
\text{-3}\]</span> 那么 1 2 3 与 3 4 5 相等， 就可以由 1 1 与 1 1
相等得出</p>
<p>即问题变为在差分数组下求原定义的相等的不重叠最大子串，需注意的是差分数组的子串长度+1才是原子串</p>
<p>其次，我们要知道，最大重复子串即为height数组里的最大值，这不难证明，因为重复子串必定是任意两后缀的LCP，而LCP就对应的是height数组一段连续区间的最小值，必定小于等于height的最大值</p>
<p>而现在题目要求不重叠，对长度k进行二分，将问题变为判定长为k的不重叠重复子串的存在问题</p>
<p>所以我们把height值大于等于k的归在一组，只有这样才存在至少长为k的不重叠子串，该组内sa的最大值与最小值的差若小于等于k，就存在</p>
<p>按height分组是常见方法，如图</p>
<figure>
<img src="/2019/02/21/%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84%E5%8D%81%E4%B8%89%E9%A2%98/SA_1.png" alt="按height分组">
<figcaption aria-hidden="true">按height分组</figcaption>
</figure>
<p>实现格式较固定</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">&#123;        </span><br><span class="line">    <span class="keyword">if</span>(height[i] &lt; k) maxv = -INF, minv = INF;<span class="comment">// 重新更新 </span></span><br><span class="line">    <span class="comment">// 每一组内维护的信息</span></span><br><span class="line">    <span class="comment">// 判断是否合法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>因此第一道题就解决了</p>
<p>差分转化</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">n = read();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) a[i] = read();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) s[i] = a[i]-a[i<span class="number">-1</span>]+<span class="number">100</span>; <span class="comment">// 防止负数</span></span><br></pre></td></tr></table></figure>
<p>判断二分答案合法</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">valid</span><span class="params">(<span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> maxv = -INF, minv = INF;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    &#123;        </span><br><span class="line">        <span class="keyword">if</span>(height[i] &lt; k) maxv = -INF, minv = INF;        </span><br><span class="line">        maxv = max(sa[i], maxv);</span><br><span class="line">        minv = min(sa[i], minv);</span><br><span class="line">        <span class="keyword">if</span>(maxv-minv &gt; k) <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">//注意为小于k，因为这是差分数组</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>二分答案</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> l = <span class="number">0</span>, r = n;</span><br><span class="line"><span class="keyword">while</span>(l &lt;= r)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> mid = (l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(valid(mid)) l = mid+<span class="number">1</span>, ans = mid;</span><br><span class="line">    <span class="keyword">else</span> r = mid<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">++ans;</span><br><span class="line"><span class="keyword">if</span>(ans &lt; <span class="number">5</span>) ans = <span class="number">0</span>; <span class="comment">// 按题意判断</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br></pre></td></tr></table></figure>
<h2 id="p2852-usaco06dec牛奶模式milk-patterns"><a href="https://www.luogu.org/problemnew/show/P2852">P2852
[USACO06DEC]牛奶模式Milk Patterns</a></h2>
<h3 id="题面描述-1">题面描述</h3>
<p><strong>求至少出现k次的最长重复子串</strong></p>
<h3 id="题解-1">题解</h3>
<p>同样，我们发现答案具有单调性，因此问题变为在字符串中判定长度为m的重复子串是否出现k次，height分组后每一组重复子串为这些后缀的公共前缀，那么有多少个后缀就有子串就重复了多少次，若存在一组后缀个数大于k那么m是合法解</p>
<p>判断二分答案</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">valid</span><span class="params">(<span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(height[i] &lt; k) cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(++cnt &gt;= tot) <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 子串重复次数即为组的大小</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="sp694-disubstr---distinct-substrings"><a href="https://www.luogu.org/problemnew/show/SP694">SP694 DISUBSTR -
Distinct Substrings</a></h2>
<h3 id="题面描述-2">题面描述</h3>
<p><strong>求本质不同的子串个数</strong></p>
<h3 id="题解-2">题解</h3>
<p>每一个后缀的一段前缀就对应了一个子串，我们枚举排名i会产生n-sa[i]+1，由于本质不同，需要减去和已经枚举重复的，即实际贡献n-sa[i]+1-height[i]，注意只需要减与上一个后缀的LCP，因为更前面的实际上已包含在该LCP里了</p>
<p>其次，SPOJ不支持swap(x, y)，所以有些改动</p>
<p>不需要浪费变量名了ヾ(≧▽≦*)o</p>
<p>不开long long 见祖宗</p>
<p>累积答案</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    ans += n-sa[i]+<span class="number">1</span>-height[i];</span><br></pre></td></tr></table></figure>
<h2 id="ural1297-palindrome"><a href="https://vjudge.net/problem/URAL-1297">URAL1297 Palindrome</a></h2>
<h3 id="题面描述-3">题面描述</h3>
<p><strong>求一个字符串的最大回文子串</strong></p>
<h3 id="题解-3">题解</h3>
<p>把正串和反串拼在一起，枚举对称轴，问题就转化为新字符串中某两个后缀的LCP，长度要用奇偶性分类讨论</p>
<p>查询LCP</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LCP</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> <span class="comment">// 查询位置为i和j的后缀的LCP</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l = rak[i], r = rak[j];</span><br><span class="line">    <span class="keyword">if</span>(l &gt; r) swap(l, r); ++l;</span><br><span class="line">    <span class="keyword">int</span> k = log2(r-l+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> min(f[l][k], f[r-(<span class="number">1</span>&lt;&lt;k)+<span class="number">1</span>][k]); <span class="comment">// f为喜闻乐见的ST表</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>合并正反两串</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s+<span class="number">1</span>); len = <span class="built_in">strlen</span>(s+<span class="number">1</span>); n = <span class="number">2</span>*len+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= len; ++i) </span><br><span class="line">    s[n+<span class="number">1</span>-i] = s[i];</span><br><span class="line">s[len+<span class="number">1</span>] = <span class="number">1</span>; <span class="comment">// 放置特殊特殊节点，最好是1，其他由于数据类型的原因会有奇怪错误</span></span><br></pre></td></tr></table></figure>
<p><em>这种写法较麻烦，后文有更普适的</em></p>
<p>奇偶分类讨论，画图模拟即可</p>
<figure>
<img src="/2019/02/21/%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84%E5%8D%81%E4%B8%89%E9%A2%98/SA_2.png" alt="奇偶分类">
<figcaption aria-hidden="true">奇偶分类</figcaption>
</figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= len; ++i)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> cur = LCP(i, n+<span class="number">1</span>-i);</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">2</span>*cur<span class="number">-1</span> &gt; ans)</span><br><span class="line">    &#123;</span><br><span class="line">        ans = <span class="number">2</span>*cur<span class="number">-1</span>;</span><br><span class="line">        pos1 = i-cur+<span class="number">1</span>;</span><br><span class="line">        pos2 = i+cur<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(i &lt; <span class="number">2</span>) <span class="keyword">continue</span>;       </span><br><span class="line">    cur = LCP(i, n+<span class="number">2</span>-i);</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">2</span>*cur &gt; ans)</span><br><span class="line">    &#123;</span><br><span class="line">        ans = <span class="number">2</span>*cur;</span><br><span class="line">        pos1 = i-cur;</span><br><span class="line">        pos2 = i+cur<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<h2 id="uva10298-power-strings"><a href="https://www.luogu.org/problemnew/show/UVA10298">UVA10298 Power
Strings</a></h2>
<h3 id="题面描述-4">题面描述</h3>
<p><strong>求循环同构串的最小循环节</strong></p>
<h3 id="题解-4">题解</h3>
<p>蒟蒻连KMP都不会写了 (～﹃～)~zZ</p>
<p>枚举长度的约数，假设枚举值为k，即查找位置为1与位置为k+1的后缀的LCP是否为n-k即可</p>
<p>画图感性理解</p>
<p>枚举过程</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>; k &lt; n; ++k)</span><br><span class="line">    <span class="keyword">if</span>(n%k == <span class="number">0</span> &amp;&amp; LCP(<span class="number">1</span>, k+<span class="number">1</span>) == n-k) ans = n/k, k = n;</span><br></pre></td></tr></table></figure>
<h2 id="poj3693-maximum-repetition-substring"><a href="http://poj.org/problem?id=3693">POJ3693 Maximum repetition
substring</a></h2>
<h3 id="题面描述-5">题面描述</h3>
<p><strong>求一个字符串的循环次数最多的循环同构子串，其次满足字典序最小</strong></p>
<h3 id="题解-5">题解</h3>
<p>蒟蒻调了好久，还是网上抄的的题解 ◑﹏◐</p>
<p>但是这确实是一道好题 o(<em>￣▽￣</em>)o</p>
<p>首先，这道题和上一道类似，我们可以考虑枚举循环节的长度，同时枚举每一个位置，假设当前枚举的位置为j，长度i，则计算j和i+j的LCP，那么这个循环同构子串循环为LCP/i+1，更新答案和位置即可</p>
<p>但是时间复杂度为O(n^2)，显然过不了，考虑优化</p>
<p>对于长度i的循环节，如果只枚举S(1, i), S(i+1, i*2+1) ...
会发生什么，我们会漏记循环次数，但此时它一定是一个更多循环次数子串的后缀，所以我们再向前寻找i个即可，向前匹配了LCP%i个字符循环次数+1</p>
<figure>
<img src="/2019/02/21/%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84%E5%8D%81%E4%B8%89%E9%A2%98/SA_3.png" alt="寻找循环同构子串">
<figcaption aria-hidden="true">寻找循环同构子串</figcaption>
</figure>
<p>但时间复杂度不太会算啊（；´д｀）ゞ ，
感性上，均摊和随机都比较优秀，<del>大概是O(nlogn+k)，k是一个与n无关的常数</del></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n/<span class="number">2</span>; ++i) <span class="comment">// 枚举到n/2即可</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j+i &lt;= n; j += i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(s[j] != s[j+i]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">int</span> lcp = LCP(j, j+i);</span><br><span class="line">        <span class="keyword">int</span> curr = lcp/i+<span class="number">1</span>, exl = j-(i-lcp%i), curl = j, cnt = <span class="number">0</span>; <span class="comment">// curr 重复次数，exl 匹配到这个位置curr+1</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = j<span class="number">-1</span>; k &gt; j-i&amp;&amp;k&amp;&amp;s[k] == s[i+k]; --k) <span class="comment">// 如果不大于exl则重复次数增加，但还会继续枚举</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(exl == k) ++curr, curl = k;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>接下来，我们考虑字典序最小</p>
<p><del>暴力统计</del>，我们考虑rank数组，通过rank[i] 和 rank[j]
我们可以比较任意两个后缀的排名，而子串一定是某个后缀的前缀，对于完全不同的子串，若首字符位置不同，我们可以通过直接比较后缀即可，若位置相同，就比较长度，对于完全相同的子串，<del>细节留给读者思考</del></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n/<span class="number">2</span>; ++i)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j+i &lt;= n; j += i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(s[j] != s[j+i]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">int</span> lcp = LCP(j, j+i);</span><br><span class="line">        <span class="keyword">int</span> curr = lcp/i+<span class="number">1</span>, exl = j-(i-lcp%i), curl = j, cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = j<span class="number">-1</span>; k &gt; j-i&amp;&amp;k&amp;&amp;s[k] == s[i+k]; --k)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(exl == k) ++curr, curl = k;</span><br><span class="line">            <span class="keyword">else</span> curl = rak[k]&lt; rak[curl]?k:curl; <span class="comment">// 时刻更新首字符</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(curr &gt; maxr) maxr = curr, len = i, p = curl;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(curr == maxr &amp;&amp; rak[curl] &lt; rak[p]) maxr = curr, len = i, p = curl; <span class="comment">// 按照长度枚举rank相同先枚举的字典序大</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="poj2274-long-long-message"><a href="http://poj.org/problem?id=2774">POJ2274 Long Long Message</a></h2>
<h3 id="题面描述-6">题面描述</h3>
<p><strong>求两个字符串的最长公共子串</strong></p>
<h3 id="题解-6">题解</h3>
<p>两个字符串的最长公共子串必定是两个字符串任意两个后缀的最长公共前缀，我们把两个字符串拼在一起，从中取满足sa[i-1]
和 sa[i] 分别属于两个字符串的height的最大值</p>
<figure>
<img src="/2019/02/21/%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84%E5%8D%81%E4%B8%89%E9%A2%98/SA_4.png" alt="拼接后的SA数组">
<figcaption aria-hidden="true">拼接后的SA数组</figcaption>
</figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i)</span><br><span class="line">    <span class="keyword">if</span>((sa[i] &lt; p &amp;&amp; sa[i<span class="number">-1</span>] &gt; p) || (sa[i] &gt; p&amp;&amp;sa[i<span class="number">-1</span>] &lt; p))</span><br><span class="line">        ans = max(ans, height[i]);</span><br></pre></td></tr></table></figure>
<p><em>之后会更改判断子串位置的写法</em></p>
<h2 id="poj3415-common-substrings"><a href="http://poj.org/problem?id=3415">POJ3415 Common Substrings</a></h2>
<h3 id="题面描述-7">题面描述</h3>
<p><strong>求两个字符串长度不小于 k
的公共子串的个数（可以相同）</strong></p>
<h3 id="题解-7">题解</h3>
<p>好题 ヾ(≧▽≦*)o</p>
<p><del>那一刻我仿佛会了单调栈</del></p>
<p>题意可以转化为，我们定义</p>
<p><span class="math display">\[A(i,\ k)\]</span></p>
<p>表示字符串A从第i个位置开始长度为k的子串</p>
<p>定义集合</p>
<p><span class="math display">\[S = \{(i,\ j,\ k)\ |\ K \le k,\ A(i,\ k)
= B(j,\ k) \}\]</span></p>
<p>代表公共子串集合，题目实际上就是求<span class="math inline">\(|S|\)</span></p>
<p>那么</p>
<p><span class="math display">\[|S|\ =
\sum_{i=1}\sum_{j=1}\sum_{k=1}[A(i,\ k)==B(j,\ k)][K \le k]\]</span></p>
<p><span class="math display">\[=\sum_{i=1}\sum_{j=1}LCP(i,\ j)-K+1[K
\le k]\ \]</span></p>
<p>所以，我们把两个字符串拼在一起，按照<span class="math inline">\(height\)</span>分组，先考虑枚举A的子串S，求出字典序比S小的B的子串<span class="math inline">\(LCP-K+1\)</span>的总和，然后在反过来枚举B的子串，相当于把大于A的子串字典序的贡献计算一遍，就得到了<span class="math inline">\(|S|\)</span></p>
<p>相当于对于枚举A的位置i来说它的贡献为</p>
<p><span class="math display">\[\sum_{j&lt;i}\min_{k=j}^{i}(height_k)-K+1[sa[j-1]\in
B]\ [sa[i] \in A]\]</span></p>
<p>很显然 <span class="math inline">\(\min_{k=j}^{i}(height_k)\)</span>
具有单调性，对于<span class="math inline">\(j&#39;\)</span>&lt;<span class="math inline">\(j\)</span>，就有 <span class="math inline">\(\min_{k=j}^{i}(height_k)\le\min_{k=j&#39;}^{i}(height_k)\)</span>，并且当<span class="math inline">\(i\ \rightarrow
i+1\)</span>时，决策集合靠后的可能会变小</p>
<p>所以，我们可以用一个单调栈维护<span class="math inline">\(height\)</span>和<span class="math inline">\(cnt\)</span>，当一个新的决策入栈后，把若<span class="math inline">\(height_{top} \ge
height_i\)</span>弹出栈顶，并更新具有相同<span class="math inline">\(height\)</span>的<span class="math inline">\(cnt\)</span></p>
<p>具体来说</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> top = <span class="number">0</span>; <span class="comment">// 枚举B，计算A</span></span><br><span class="line">ll sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(height[i] &lt; len) &#123; sum = top = <span class="number">0</span>; <span class="keyword">continue</span>; &#125; <span class="comment">// 和之前分组不同的是height是主要决策，当这一个height不满足时直接跳过</span></span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(bel[sa[i<span class="number">-1</span>]] == <span class="number">1</span>) ++cnt, sum += height[i]-len+<span class="number">1</span>; <span class="comment">// 假如是上一个后缀是Aheight更新贡献</span></span><br><span class="line">    <span class="keyword">while</span>(top&amp;&amp;stak[top][<span class="number">0</span>] &gt;= height[i])</span><br><span class="line">        sum -= stak[top][<span class="number">1</span>]*(stak[top][<span class="number">0</span>]-height[i]),</span><br><span class="line">        cnt += stak[top][<span class="number">1</span>],</span><br><span class="line">        --top; <span class="comment">// 维护单调性</span></span><br><span class="line">    stak[++top][<span class="number">0</span>] = height[i]; stak[top][<span class="number">1</span>] = cnt;</span><br><span class="line">    <span class="keyword">if</span>(bel[sa[i]] == <span class="number">2</span>) ans += sum; <span class="comment">// 如果是B串累计贡献</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="poj3294-life-forms"><a href="http://poj.org/problem?id=3294">POJ3294 Life Forms</a></h2>
<h3 id="题面描述-8">题面描述</h3>
<p><strong>求不小于k个字符串中的最长子串</strong></p>
<h3 id="题解-8">题解</h3>
<p>把字符串拼在一起，中间用特殊字符隔开</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= tot; ++k)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, inps+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; inps[i]; ++i) s[++n] = inps[i], bel[n] = k;</span><br><span class="line">    s[++n] = (++spc)+S; bel[n] = k;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><em>这是合并字符串的最终版本，s是int类型的，S是字符集大小</em></p>
<p>二分长度，判断每组内是否有k个不同的字符串</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">valid</span><span class="params">(<span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(height[i] &lt; k) <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= tot; ++j) t = cnt[j] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> x = bel[sa[i]];</span><br><span class="line">        <span class="keyword">if</span>(x &amp;&amp; ++cnt[x] == <span class="number">1</span>) ++t;</span><br><span class="line">        <span class="keyword">if</span>(t &gt;= tot/<span class="number">2</span>+<span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再把满足条件的最大长度，来统计字符串</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getAns</span><span class="params">(<span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!k) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> t = <span class="number">0</span>, ta = <span class="number">0</span>, tag = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(height[i] &lt; k) <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= tot; ++j) tag = t = cnt[j] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> x = bel[sa[i]];</span><br><span class="line">        <span class="keyword">if</span>(x &amp;&amp; ++cnt[x] == <span class="number">1</span>) ++t;</span><br><span class="line">        <span class="keyword">if</span>(t == tot/<span class="number">2</span>+<span class="number">1</span> &amp;&amp; !tag) ans[++ta] = sa[i], tag = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ta;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong><del>输出格式有锅 ㄟ( ▔, ▔ )ㄏ</del></strong></p>
<h2 id="sp220-phrases---relevant-phrases-of-annihilation"><a href="http://poj.org/problem?id=1226">SP220 PHRASES - Relevant Phrases
of Annihilation</a></h2>
<h3 id="题面描述-9">题面描述</h3>
<p><strong>求每个字符串至少出现两次且不重叠的最长子串</strong></p>
<h3 id="题解-9">题解</h3>
<p>前面几道题的综合，拼在一起，二分，统计每组不同串的个数，用相同串的<span class="math inline">\(sa_{max}-sa_{min}\)</span>是否大于二分值即可</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">valid</span><span class="params">(<span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> x = <span class="number">1</span>; x &lt;= tot; ++x) cnt[x] = <span class="number">0</span>, maxv[x] = <span class="number">-1</span>, minv[x] = n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(height[i] &lt; k) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">bool</span> cor = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> x = <span class="number">1</span>; x &lt;= tot &amp;&amp; cor; ++x)</span><br><span class="line">                <span class="keyword">if</span>(cnt[x] &lt; <span class="number">2</span>) cor = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(maxv[x]-minv[x] &lt; k) cor = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span>(cor) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> x = <span class="number">1</span>; x &lt;= tot; ++x) cnt[x] = <span class="number">0</span>, maxv[x] = <span class="number">-1</span>, minv[x] = n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> x = bel[sa[i]];</span><br><span class="line">        ++cnt[x]; </span><br><span class="line">        maxv[x] = max(maxv[x], sa[i]);</span><br><span class="line">        minv[x] = min(minv[x], sa[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="poj1226-substrings"><a href="https://www.luogu.org/problemnew/show/SP220">POJ1226
Substrings</a></h2>
<h3 id="题面描述-10">题面描述</h3>
<p><strong>求出现或反转后出现在每个字符串中的最长子串</strong></p>
<h3 id="题解-10">题解</h3>
<p>正串反串拼一块，所有串拼一块，二分即可</p>
<p>拼串</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= tot; ++k)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, inps+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> strl = <span class="built_in">strlen</span>(inps+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= strl; ++i) s[++n] = inps[i], bel[n] = k;</span><br><span class="line">    s[++n] = (++spc)+<span class="number">128</span>; bel[n] = k;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = strl; i; --i) s[++n] = inps[i], bel[n] = k;</span><br><span class="line">    s[++n] = (++spc)+<span class="number">128</span>; bel[n] = k;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>完结散花ヾ(•ω•`)o</strong></p>
<p><del>SA真是人类的智慧</del></p>
<p><em>可是蒟蒻还是不会字符串啊</em></p>
<p>参考论文 <a href="后缀数组——处理字符串的有力工具.pdf">后缀数组——处理字符串的有力工具</a></p>
<!-- 设$S(n)=\sum_{i=1}^n\mu(i)*i^2,f=\mu*id^2$

考虑$g(n)=n^2$

$f$与$g$的狄利克雷卷积为$(f*g)[n] = \sum_{d|n}\mu(d)*d^2*(\frac{n}{d})^2=\sum_{d|n}\mu(d)*n^2=n^2[n==1]$

所以$f*g$的前缀和很好求即为1

即有$g(1)S(n)=\sum_{i=1}^n(f*g)[i]-\sum_{i=2}^ng(i)*S(\lfloor \frac{n}{i} \rfloor)=1-\sum_{}(gs(r)-gs(l-1))*S(\lfloor \frac{n}{i} \rfloor)$ 其中 $gs(n)=\frac{n(n+1)(2n+1)}{6}$ -->
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>差分</tag>
        <tag>单调栈</tag>
        <tag>后缀数组</tag>
      </tags>
  </entry>
</search>
